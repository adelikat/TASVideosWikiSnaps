171
[p 
	"This page documents the the behavior and parameters of Lua functions available for the 
	(__wikiLink|BizHawk)
	" emulator.
	$LF
	[b 
		"This is an autogenerated page, do not edit
	]b
	$LF
]p
[p 
	"All type names represent the standard .NET types of the same name. Except for func which represents a lua function and table which represents a lua table. For more information on .NET types can be found in MSDN documentation.
	$LF
]p
[p 
	[b 
		"Types and notation
	]b
	$LF
]p
[ul 
	[li 
		" ? (question mark)
		$LF
		[ul 
			[li 
				" A question mark next to a value indicates that it is a Nullable type (only applies to types that are not normally nullable)
				$LF
			]li
		]ul
		" [] (brackets)
		$LF
		[ul 
			[li 
				" Brackets around a parameter indicate that the parameter is optional. optional parameters have an equals sign followed by the value that will be used if no value is supplied.
				$LF
			]li
			[li 
				" Brackets after a parameter type indicate it is an array
				$LF
			]li
		]ul
		" null
		$LF
		[ul 
			[li 
				" null is equivalent to the lua nil
				$LF
			]li
		]ul
		" Color
		$LF
		[ul 
			[li 
				" This is a .NET System.Drawing.Color struct. The value passed from lua is any value acceptable in the Color constructor. This means either a string with the color name such as "red", or a 0xAARRGGBB integer value.  Unless specified, this is not a nullable value
				$LF
			]li
		]ul
		" object
		$LF
		[ul 
			[li 
				" A System.Object, literally anything qualifies for this parameter. However, the context of particular function may suggest a narrower range of useful values.
				$LF
			]li
		]ul
		" luaf
		$LF
		[ul 
			[li 
				" A Lua function. Note that these are always parameters, and never return values of a call
				$LF
			]li
		]ul
		" table
		$LF
		[ul 
			[li 
				" A standard Lua table
				$LF
			]li
		]ul
	]li
]ul
[div class= 
	[ul class=nav nav-tabs role=tablist 
		[li class=nav-item 
			[a class=active nav-link data-toggle=tab href=#y-816 
				"userdata
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-817 
				"bit
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-818 
				"emu
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-819 
				"event
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-820 
				"gameinfo
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-821 
				"genesis
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-822 
				"joypad
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-823 
				"mainmemory
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-824 
				"memory
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-825 
				"memorysavestate
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-826 
				"movie
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-827 
				"nes
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-828 
				"snes
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-829 
				"SQL
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-830 
				"bizstring
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-831 
				"client
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-832 
				"comm
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-833 
				"console
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-834 
				"forms
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-835 
				"gui
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-836 
				"input
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-837 
				"savestate
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-838 
				"tastudio
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#y-839 
				"LuaCanvas
			]a
		]li
	]ul
	[div class=tab-content 
		[div class=tab-pane active id=y-816 
			[p 
				"A library for setting and retrieving dynamic data that will be saved and loaded with savestates
				$LF
			]p
			[p 
				[b 
					"userdata.set
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void userdata.set(string name, object value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" adds or updates the data with the given key with the given value
					$LF
				]li
			]ul
			[p 
				[b 
					"userdata.get
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" object userdata.get(string key)
					$LF
				]li
			]ul
			[ul 
				[li 
					" gets the data with the given key, if the key does not exist it will return nil
					$LF
				]li
			]ul
			[p 
				[b 
					"userdata.clear
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void userdata.clear()
					$LF
				]li
			]ul
			[ul 
				[li 
					" clears all user data
					$LF
				]li
			]ul
			[p 
				[b 
					"userdata.remove
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool userdata.remove(string key)
					$LF
				]li
			]ul
			[ul 
				[li 
					" remove the data with the given key. Returns true if the element is successfully found and removed; otherwise, false.
					$LF
				]li
			]ul
			[p 
				[b 
					"userdata.containskey
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool userdata.containskey(string key)
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns whether or not there is an entry for the given key
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-817 
			[p 
				"A library for performing standard bitwise operations.
				$LF
			]p
			[p 
				[b 
					"bit.band
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.band(uint  val, uint  amt)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Bitwise AND of 'val' against 'amt'
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.bnot
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.bnot(uint  val)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Bitwise NOT of 'val' against 'amt'
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.bor
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.bor(uint  val, uint  amt)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Bitwise OR of 'val' against 'amt'
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.bxor
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.bxor(uint  val, uint  amt)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Bitwise XOR of 'val' against 'amt'
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.lshift
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.lshift(uint  val, int amt)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Logical shift left of 'val' by 'amt' bits
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.rol
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.rol(uint  val, int amt)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Left rotate 'val' by 'amt' bits
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.ror
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.ror(uint  val, int amt)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Right rotate 'val' by 'amt' bits
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.rshift
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.rshift(uint  val, int amt)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Logical shift right of 'val' by 'amt' bits
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.arshift
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int bit.arshift(int val, int amt)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Arithmetic shift right of 'val' by 'amt' bits
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.check
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool bit.check(long num, int pos)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns result of bit 'pos' being set in 'num'
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.set
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.set(uint  num, int pos)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the bit 'pos' in 'num'
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.clear
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" long bit.clear(uint  num, int pos)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Clears the bit 'pos' in 'num'
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.byteswap_16
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" ushort bit.byteswap_16(ushort  val)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Byte swaps 'short', i.e. bit.byteswap_16(0xFF00) would return 0x00FF
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.byteswap_32
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint bit.byteswap_32(uint  val)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Byte swaps 'dword'
					$LF
				]li
			]ul
			[p 
				[b 
					"bit.byteswap_64
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" ulong bit.byteswap_64(ulong  val)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Byte swaps 'long'
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-818 
			[p 
				"A library for interacting with the currently loaded emulator core
				$LF
			]p
			[p 
				[b 
					"emu.displayvsync
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void emu.displayvsync(bool enabled)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the display vsync property of the emulator
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.frameadvance
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void emu.frameadvance()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Signals to the emulator to resume emulation. Necessary for any lua script while loop or else the emulator will freeze!
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.framecount
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int emu.framecount()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the current frame count
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.disassemble
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" object emu.disassemble(uint  pc, [string name = ])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the disassembly object (disasm string and length int) for the given PC address. Uses System Bus domain if no domain name provided
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.getregister
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int emu.getregister(string name)
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the value of a cpu register or flag specified by name. For a complete list of possible registers or flags for a given core, use getregisters
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.getregisters
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable emu.getregisters()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the complete set of available flags and registers for a given core
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.setregister
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void emu.setregister(string register, int value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" sets the given register name to the given value
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.totalexecutedcycles
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" long emu.totalexecutedcycles()
					$LF
				]li
			]ul
			[ul 
				[li 
					" gets the total number of executed cpu cycles
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.getsystemid
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string emu.getsystemid()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the ID string of the current core loaded. Note: No ROM loaded will return the string NULL
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.islagged
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool emu.islagged()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether or not the current frame is a lag frame
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.setislagged
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void emu.setislagged([bool value = True])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the lag flag for the current frame. If no value is provided, it will default to true
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.lagcount
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int emu.lagcount()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the current lag count
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.setlagcount
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void emu.setlagcount(int count)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the current lag count
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.limitframerate
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void emu.limitframerate(bool enabled)
					$LF
				]li
			]ul
			[ul 
				[li 
					" sets the limit framerate property of the emulator
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.minimizeframeskip
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void emu.minimizeframeskip(bool enabled)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the autominimizeframeskip value of the emulator
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.setrenderplanes
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void emu.setrenderplanes(bool[] luaparam)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Toggles the drawing of sprites and background planes. Set to false or nil to disable a pane, anything else will draw them
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.yield
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void emu.yield()
					$LF
				]li
			]ul
			[ul 
				[li 
					" allows a script to run while emulation is paused and interact with the gui/main window in realtime 
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.getdisplaytype
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string emu.getdisplaytype()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the display type (PAL vs NTSC) that the emulator is currently running in
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.getboardname
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string emu.getboardname()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns (if available) the board name of the loaded ROM
					$LF
				]li
			]ul
			[p 
				[b 
					"emu.getluacore
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string emu.getluacore()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the name of the Lua core currently in use
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-819 
			[p 
				"A library for registering lua functions to emulator events.
				$LF
			]p
			[pre 
				"All events support multiple registered methods.
				$LF
			]pre
			[p 
				"All registered event methods can be named and return a Guid when registered
				$LF
			]p
			[p 
				[b 
					"event.onframeend
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string event.onframeend(nluafunc luaf, [string name = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Calls the given lua function at the end of each frame, after all emulation and drawing has completed. Note: this is the default behavior of lua scripts
					$LF
				]li
			]ul
			[p 
				[b 
					"event.onframestart
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string event.onframestart(nluafunc luaf, [string name = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Calls the given lua function at the beginning of each frame before any emulation and drawing occurs
					$LF
				]li
			]ul
			[p 
				[b 
					"event.oninputpoll
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string event.oninputpoll(nluafunc luaf, [string name = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Calls the given lua function after each time the emulator core polls for input
					$LF
				]li
			]ul
			[p 
				[b 
					"event.onloadstate
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string event.onloadstate(nluafunc luaf, [string name = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Fires after a state is loaded. Receives a lua function name, and registers it to the event immediately following a successful savestate event
					$LF
				]li
			]ul
			[p 
				[b 
					"event.onmemoryexecute
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string event.onmemoryexecute(nluafunc luaf, uint  address, [string name = null], [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Fires after the given address is executed by the core
					$LF
				]li
			]ul
			[p 
				[b 
					"event.onmemoryread
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string event.onmemoryread(nluafunc luaf, [uint? address = null], [string name = null], [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Fires after the given address is read by the core. If no address is given, it will attach to every memory read
					$LF
				]li
			]ul
			[p 
				[b 
					"event.onmemorywrite
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string event.onmemorywrite(nluafunc luaf, [uint? address = null], [string name = null], [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Fires after the given address is written by the core. If no address is given, it will attach to every memory write
					$LF
				]li
			]ul
			[p 
				[b 
					"event.onsavestate
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string event.onsavestate(nluafunc luaf, [string name = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Fires after a state is saved
					$LF
				]li
			]ul
			[p 
				[b 
					"event.onexit
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string event.onexit(nluafunc luaf, [string name = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Fires after the calling script has stopped
					$LF
				]li
			]ul
			[p 
				[b 
					"event.unregisterbyid
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool event.unregisterbyid(string guid)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Removes the registered function that matches the guid. If a function is found and remove the function will return true. If unable to find a match, the function will return false.
					$LF
				]li
			]ul
			[p 
				[b 
					"event.unregisterbyname
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool event.unregisterbyname(string name)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Removes the first registered function that matches Name. If a function is found and remove the function will return true. If unable to find a match, the function will return false.
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-820 
			[p 
				[b 
					"gameinfo.getromname
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string gameinfo.getromname()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the path of the currently loaded rom, if a rom is loaded
					$LF
				]li
			]ul
			[p 
				[b 
					"gameinfo.getromhash
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string gameinfo.getromhash()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the hash of the currently loaded rom, if a rom is loaded
					$LF
				]li
			]ul
			[p 
				[b 
					"gameinfo.indatabase
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool gameinfo.indatabase()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns whether or not the currently loaded rom is in the game database
					$LF
				]li
			]ul
			[p 
				[b 
					"gameinfo.getstatus
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string gameinfo.getstatus()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the game database status of the currently loaded rom. Statuses are for example: GoodDump, BadDump, Hack, Unknown, NotInDatabase
					$LF
				]li
			]ul
			[p 
				[b 
					"gameinfo.isstatusbad
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool gameinfo.isstatusbad()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the currently loaded rom's game database status is considered 'bad'
					$LF
				]li
			]ul
			[p 
				[b 
					"gameinfo.getboardtype
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string gameinfo.getboardtype()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns identifying information about the 'mapper' or similar capability used for this game.  empty if no such useful distinction can be drawn
					$LF
				]li
			]ul
			[p 
				[b 
					"gameinfo.getoptions
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable gameinfo.getoptions()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the game options for the currently loaded rom. Options vary per platform
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-821 
			[p 
				"Functions specific to GenesisHawk (functions may not run when an Genesis game is not loaded)
				$LF
			]p
			[p 
				[b 
					"genesis.getlayer_bga
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool genesis.getlayer_bga()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the bg layer A is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"genesis.getlayer_bgb
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool genesis.getlayer_bgb()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the bg layer B is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"genesis.getlayer_bgw
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool genesis.getlayer_bgw()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the bg layer W is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"genesis.setlayer_bga
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void genesis.setlayer_bga(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the bg layer A is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"genesis.setlayer_bgb
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void genesis.setlayer_bgb(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the bg layer B is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"genesis.setlayer_bgw
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void genesis.setlayer_bgw(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the bg layer W is displayed
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-822 
			[p 
				[b 
					"joypad.get
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable joypad.get([int? controller = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns a lua table of the controller buttons pressed. If supplied, it will only return a table of buttons for the given controller
					$LF
				]li
			]ul
			[p 
				[b 
					"joypad.getimmediate
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable joypad.getimmediate()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns a lua table of any controller buttons currently pressed by the user
					$LF
				]li
			]ul
			[p 
				[b 
					"joypad.setfrommnemonicstr
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void joypad.setfrommnemonicstr(string inputlogentry)
					$LF
				]li
			]ul
			[ul 
				[li 
					" sets the given buttons to their provided values for the current frame, string will be interpretted the same way an entry from a movie input log would be
					$LF
				]li
			]ul
			[p 
				[b 
					"joypad.set
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void joypad.set(nluatable buttons, [int? controller = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" sets the given buttons to their provided values for the current frame
					$LF
				]li
			]ul
			[p 
				[b 
					"joypad.setanalog
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void joypad.setanalog(nluatable controls, [object controller = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" sets the given analog controls to their provided values for the current frame. Note that unlike set() there is only the logic of overriding with the given value.
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-823 
			[p 
				"Main memory library reads and writes from the Main memory domain (the default memory domain set by any given core)
				$LF
			]p
			[p 
				[b 
					"mainmemory.getname
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string mainmemory.getname()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the name of the domain defined as main memory for the given core
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.getcurrentmemorydomainsize
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint mainmemory.getcurrentmemorydomainsize()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the number of bytes of the domain defined as main memory
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.readbyte
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint mainmemory.readbyte(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" gets the value from the given address as an unsigned byte
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.writebyte
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.writebyte(int addr, uint  value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Writes the given value to the given address as an unsigned byte
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.readbyterange
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable mainmemory.readbyterange(int addr, int length)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Reads the address range that starts from address, and is length long. Returns the result into a table of key value pairs (where the address is the key).
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.writebyterange
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.writebyterange(nluatable memoryblock)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Writes the given values to the given addresses as unsigned bytes
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.readfloat
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" single mainmemory.readfloat(int addr, bool bigendian)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Reads the given address as a 32-bit float value from the main memory domain with th e given endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.writefloat
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.writefloat(int addr, double value, bool bigendian)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Writes the given 32-bit float value to the given address and endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_s8
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int mainmemory.read_s8(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed byte
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_s8
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_s8(int addr, uint  value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed byte
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_u8
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint mainmemory.read_u8(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned byte
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_u8
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_u8(int addr, uint  value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned byte
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_s16_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int mainmemory.read_s16_le(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 2 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_s16_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_s16_le(int addr, int value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 2 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_s16_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int mainmemory.read_s16_be(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 2 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_s16_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_s16_be(int addr, int value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 2 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_u16_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint mainmemory.read_u16_le(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 2 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_u16_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_u16_le(int addr, uint  value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 2 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_u16_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint mainmemory.read_u16_be(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 2 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_u16_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_u16_be(int addr, uint  value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 2 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_s24_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int mainmemory.read_s24_le(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 24 bit value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_s24_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_s24_le(int addr, int value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 24 bit value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_s24_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int mainmemory.read_s24_be(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 24 bit value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_s24_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_s24_be(int addr, int value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 24 bit value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_u24_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint mainmemory.read_u24_le(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 24 bit value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_u24_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_u24_le(int addr, uint  value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 24 bit value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_u24_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint mainmemory.read_u24_be(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 24 bit value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_u24_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_u24_be(int addr, uint  value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 24 bit value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_s32_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int mainmemory.read_s32_le(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 4 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_s32_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_s32_le(int addr, int value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 4 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_s32_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int mainmemory.read_s32_be(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 4 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_s32_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_s32_be(int addr, int value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 4 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_u32_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint mainmemory.read_u32_le(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 4 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_u32_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_u32_le(int addr, uint  value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 4 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.read_u32_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint mainmemory.read_u32_be(int addr)
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 4 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"mainmemory.write_u32_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void mainmemory.write_u32_be(int addr, uint  value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 4 byte value, big endian
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-824 
			[p 
				"These functions behavior identically to the mainmemory functions but the user can set the memory domain to read and write from. The default domain is main memory. Use getcurrentmemorydomain(), and usememorydomain() to control which domain is used. Each core has its own set of valid memory domains. Use getmemorydomainlist() to get a list of memory domains for the current core loaded.
				$LF
			]p
			[p 
				[b 
					"memory.getmemorydomainlist
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable memory.getmemorydomainlist()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a string of the memory domains for the loaded platform core. List will be a single string delimited by line feeds
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.getmemorydomainsize
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.getmemorydomainsize([string name = ])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the number of bytes of the specified memory domain. If no domain is specified, or the specified domain doesn't exist, returns the current domain size
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.getcurrentmemorydomain
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string memory.getcurrentmemorydomain()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a string name of the current memory domain selected by Lua. The default is Main memory
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.getcurrentmemorydomainsize
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.getcurrentmemorydomainsize()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the number of bytes of the current memory domain selected by Lua. The default is Main memory
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.usememorydomain
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool memory.usememorydomain(string domain)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Attempts to set the current memory domain to the given domain. If the name does not match a valid memory domain, the function returns false, else it returns true
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.hash_region
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string memory.hash_region(int addr, int count, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a hash as a string of a region of memory, starting from addr, through count bytes. If the domain is unspecified, it uses the current region.
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.readbyte
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.readbyte(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" gets the value from the given address as an unsigned byte
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.writebyte
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.writebyte(int addr, uint  value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Writes the given value to the given address as an unsigned byte
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.readbyterange
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable memory.readbyterange(int addr, int length, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Reads the address range that starts from address, and is length long. Returns the result into a table of key value pairs (where the address is the key).
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.writebyterange
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.writebyterange(nluatable memoryblock, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Writes the given values to the given addresses as unsigned bytes
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.readfloat
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" single memory.readfloat(int addr, bool bigendian, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Reads the given address as a 32-bit float value from the main memory domain with th e given endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.writefloat
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.writefloat(int addr, double value, bool bigendian, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Writes the given 32-bit float value to the given address and endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_s8
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int memory.read_s8(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed byte
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_s8
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_s8(int addr, uint  value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed byte
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_u8
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.read_u8(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned byte
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_u8
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_u8(int addr, uint  value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned byte
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_s16_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int memory.read_s16_le(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 2 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_s16_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_s16_le(int addr, int value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 2 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_s16_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int memory.read_s16_be(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 2 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_s16_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_s16_be(int addr, int value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 2 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_u16_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.read_u16_le(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 2 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_u16_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_u16_le(int addr, uint  value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 2 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_u16_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.read_u16_be(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 2 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_u16_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_u16_be(int addr, uint  value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 2 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_s24_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int memory.read_s24_le(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 24 bit value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_s24_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_s24_le(int addr, int value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 24 bit value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_s24_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int memory.read_s24_be(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 24 bit value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_s24_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_s24_be(int addr, int value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 24 bit value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_u24_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.read_u24_le(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 24 bit value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_u24_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_u24_le(int addr, uint  value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 24 bit value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_u24_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.read_u24_be(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 24 bit value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_u24_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_u24_be(int addr, uint  value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 24 bit value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_s32_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int memory.read_s32_le(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 4 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_s32_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_s32_le(int addr, int value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 4 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_s32_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int memory.read_s32_be(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read signed 4 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_s32_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_s32_be(int addr, int value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write signed 4 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_u32_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.read_u32_le(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 4 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_u32_le
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_u32_le(int addr, uint  value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 4 byte value, little endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.read_u32_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" uint memory.read_u32_be(int addr, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" read unsigned 4 byte value, big endian
					$LF
				]li
			]ul
			[p 
				[b 
					"memory.write_u32_be
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memory.write_u32_be(int addr, uint  value, [string domain = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" write unsigned 4 byte value, big endian
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-825 
			[p 
				[b 
					"memorysavestate.savecorestate
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string memorysavestate.savecorestate()
					$LF
				]li
			]ul
			[ul 
				[li 
					" creates a core savestate and stores it in memory.  Note: a core savestate is only the raw data from the core, and not extras such as movie input logs, or framebuffers. Returns a unique identifer for the savestate
					$LF
				]li
			]ul
			[p 
				[b 
					"memorysavestate.loadcorestate
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memorysavestate.loadcorestate(string identifier)
					$LF
				]li
			]ul
			[ul 
				[li 
					" loads an in memory state with the given identifier
					$LF
				]li
			]ul
			[p 
				[b 
					"memorysavestate.removestate
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memorysavestate.removestate(string identifier)
					$LF
				]li
			]ul
			[ul 
				[li 
					" removes the savestate with the given identifier from memory
					$LF
				]li
			]ul
			[p 
				[b 
					"memorysavestate.clearstatesfrommemory
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void memorysavestate.clearstatesfrommemory()
					$LF
				]li
			]ul
			[ul 
				[li 
					" clears all savestates stored in memory
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-826 
			[p 
				[b 
					"movie.startsfromsavestate
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool movie.startsfromsavestate()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether or not the movie is a savestate-anchored movie
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.startsfromsaveram
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool movie.startsfromsaveram()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether or not the movie is a saveram-anchored movie
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.filename
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string movie.filename()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the file name including path of the currently loaded movie
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.getinput
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable movie.getinput(int frame)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a table of buttons pressed on a given frame of the loaded movie
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.getinputasmnemonic
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string movie.getinputasmnemonic(int frame)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the input of a given frame of the loaded movie in a raw inputlog string
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.getreadonly
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool movie.getreadonly()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns true if the movie is in read-only mode, false if in read+write
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.getrerecordcount
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" ulong movie.getrerecordcount()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the rerecord count of the current movie.
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.getrerecordcounting
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool movie.getrerecordcounting()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether or not the current movie is incrementing rerecords on loadstate
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.isloaded
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool movie.isloaded()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns true if a movie is loaded in memory (play, record, or finished modes), false if not (inactive mode)
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.length
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" double movie.length()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the total number of frames of the loaded movie
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.mode
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string movie.mode()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the mode of the current movie. Possible modes: "PLAY", "RECORD", "FINISHED", "INACTIVE"
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.save
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void movie.save([string filename = ])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Saves the current movie to the disc. If the filename is provided (no extension or path needed), the movie is saved under the specified name to the current movie directory. The filename may contain a subdirectory, it will be created if it doesn't exist. Existing files won't get overwritten.
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.setreadonly
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void movie.setreadonly(bool readonly)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the read-only state to the given value. true for read only, false for read+write
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.setrerecordcount
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void movie.setrerecordcount(double count)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the rerecord count of the current movie.
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.setrerecordcounting
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void movie.setrerecordcounting(bool counting)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether or not the current movie will increment the rerecord counter on loadstate
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.stop
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void movie.stop()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Stops the current movie
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.getfps
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" double movie.getfps()
					$LF
				]li
			]ul
			[ul 
				[li 
					" If a movie is loaded, gets the frames per second used by the movie to determine the movie length time
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.getheader
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable movie.getheader()
					$LF
				]li
			]ul
			[ul 
				[li 
					" If a movie is active, will return the movie header as a lua table
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.getcomments
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable movie.getcomments()
					$LF
				]li
			]ul
			[ul 
				[li 
					" If a movie is active, will return the movie comments as a lua table
					$LF
				]li
			]ul
			[p 
				[b 
					"movie.getsubtitles
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable movie.getsubtitles()
					$LF
				]li
			]ul
			[ul 
				[li 
					" If a movie is active, will return the movie subtitles as a lua table
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-827 
			[p 
				"Functions related specifically to Nes Cores
				$LF
			]p
			[p 
				[b 
					"nes.addgamegenie
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void nes.addgamegenie(string code)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Adds the specified game genie code. If an NES game is not currently loaded or the code is not a valid game genie code, this will have no effect
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.getallowmorethaneightsprites
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool nes.getallowmorethaneightsprites()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the NES setting 'Allow more than 8 sprites per scanline' value
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.getbottomscanline
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int nes.getbottomscanline([bool pal = False])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the current value for the bottom scanline value
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.getclipleftandright
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool nes.getclipleftandright()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the current value for the Clip Left and Right sides option
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.getdispbackground
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool nes.getdispbackground()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Indicates whether or not the bg layer is being displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.getdispsprites
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool nes.getdispsprites()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Indicates whether or not sprites are being displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.gettopscanline
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int nes.gettopscanline([bool pal = False])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the current value for the top scanline value
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.removegamegenie
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void nes.removegamegenie(string code)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Removes the specified game genie code. If an NES game is not currently loaded or the code is not a valid game genie code, this will have no effect
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.setallowmorethaneightsprites
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void nes.setallowmorethaneightsprites(bool allow)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the NES setting 'Allow more than 8 sprites per scanline'
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.setclipleftandright
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void nes.setclipleftandright(bool leftandright)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the Clip Left and Right sides option
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.setdispbackground
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void nes.setdispbackground(bool show)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether or not the background layer will be displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.setdispsprites
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void nes.setdispsprites(bool show)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether or not sprites will be displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"nes.setscanlines
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void nes.setscanlines(int top, int bottom, [bool pal = False])
					$LF
				]li
			]ul
			[ul 
				[li 
					" sets the top and bottom scanlines to be drawn (same values as in the graphics options dialog). Top must be in the range of 0 to 127, bottom must be between 128 and 239. Not supported in the Quick Nes core
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-828 
			[p 
				"Functions specific to SNESHawk (functions may not run when an SNES game is not loaded)
				$LF
			]p
			[p 
				[b 
					"snes.getlayer_bg_1
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool snes.getlayer_bg_1()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the bg 1 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.getlayer_bg_2
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool snes.getlayer_bg_2()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the bg 2 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.getlayer_bg_3
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool snes.getlayer_bg_3()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the bg 3 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.getlayer_bg_4
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool snes.getlayer_bg_4()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the bg 4 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.getlayer_obj_1
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool snes.getlayer_obj_1()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the obj 1 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.getlayer_obj_2
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool snes.getlayer_obj_2()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the obj 2 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.getlayer_obj_3
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool snes.getlayer_obj_3()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the obj 3 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.getlayer_obj_4
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool snes.getlayer_obj_4()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether the obj 4 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.setlayer_bg_1
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void snes.setlayer_bg_1(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the bg 1 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.setlayer_bg_2
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void snes.setlayer_bg_2(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the bg 2 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.setlayer_bg_3
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void snes.setlayer_bg_3(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the bg 3 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.setlayer_bg_4
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void snes.setlayer_bg_4(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the bg 4 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.setlayer_obj_1
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void snes.setlayer_obj_1(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the obj 1 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.setlayer_obj_2
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void snes.setlayer_obj_2(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the obj 2 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.setlayer_obj_3
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void snes.setlayer_obj_3(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the obj 3 layer is displayed
					$LF
				]li
			]ul
			[p 
				[b 
					"snes.setlayer_obj_4
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void snes.setlayer_obj_4(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether the obj 4 layer is displayed
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-829 
			[p 
				"A library for performing SQLite operations.
				$LF
			]p
			[p 
				[b 
					"SQL.createdatabase
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string SQL.createdatabase(string name)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a SQLite Database. Name should end with .db
					$LF
				]li
			]ul
			[p 
				[b 
					"SQL.opendatabase
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string SQL.opendatabase(string name)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Opens a SQLite database. Name should end with .db
					$LF
				]li
			]ul
			[p 
				[b 
					"SQL.writecommand
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string SQL.writecommand([string query = ])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Runs a SQLite write command which includes CREATE,INSERT, UPDATE. Ex: create TABLE rewards (ID integer  PRIMARY KEY, action VARCHAR(20)) 
					$LF
				]li
			]ul
			[p 
				[b 
					"SQL.readcommand
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" object SQL.readcommand([string query = ])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Run a SQLite read command which includes Select. Returns all rows into a LuaTable.Ex: select * from rewards
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-830 
			[p 
				"A library exposing standard .NET string methods
				$LF
			]p
			[p 
				[b 
					"bizstring.hex
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string bizstring.hex(long num)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Converts the number to a string representation of the hexadecimal value of the given number
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.binary
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string bizstring.binary(long num)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Converts the number to a string representation of the binary value of the given number
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.octal
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string bizstring.octal(long num)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Converts the number to a string representation of the octal value of the given number
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.trim
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string bizstring.trim(string str)
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns a string that trims whitespace on the left and right ends of the string
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.replace
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string bizstring.replace(string str, string str2, string replace)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a string that replaces all occurances of str2 in str1 with the value of replace
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.toupper
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string bizstring.toupper(string str)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns an uppercase version of the given string
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.tolower
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string bizstring.tolower(string str)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns an lowercase version of the given string
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.substring
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string bizstring.substring(string str, int position, int length)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a string that represents a substring of str starting at position for the specified length
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.remove
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string bizstring.remove(string str, int position, int count)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a string that represents str with the given position and count removed
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.contains
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool bizstring.contains(string str, string str2)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether or not str contains str2
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.startswith
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool bizstring.startswith(string str, string str2)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether str starts with str2
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.endswith
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool bizstring.endswith(string str, string str2)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether str ends wth str2
					$LF
				]li
			]ul
			[p 
				[b 
					"bizstring.split
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable bizstring.split(string str, string separator)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Splits str based on separator into a LuaTable. Separator must be one character!. Same functionality as .NET string.Split() using the RemoveEmptyEntries option
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-831 
			[p 
				"A library for manipulating the EmuHawk client UI
				$LF
			]p
			[p 
				[b 
					"client.exit
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.exit()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Closes the emulator
					$LF
				]li
			]ul
			[p 
				[b 
					"client.exitCode
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.exitCode(int exitcode)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Closes the emulator and returns the provided code
					$LF
				]li
			]ul
			[p 
				[b 
					"client.borderheight
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.borderheight()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the current height in pixels of the letter/pillarbox area (top side only) around the emu display surface, excluding the gameExtraPadding you've set. This function (the whole lot of them) should be renamed or refactored since the padding areas have got more complex.
					$LF
				]li
			]ul
			[p 
				[b 
					"client.borderwidth
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.borderwidth()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the current width in pixels of the letter/pillarbox area (left side only) around the emu display surface, excluding the gameExtraPadding you've set. This function (the whole lot of them) should be renamed or refactored since the padding areas have got more complex.
					$LF
				]li
			]ul
			[p 
				[b 
					"client.bufferheight
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.bufferheight()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the visible height of the emu display surface (the core video output). This excludes the gameExtraPadding you've set.
					$LF
				]li
			]ul
			[p 
				[b 
					"client.bufferwidth
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.bufferwidth()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the visible width of the emu display surface (the core video output). This excludes the gameExtraPadding you've set.
					$LF
				]li
			]ul
			[p 
				[b 
					"client.clearautohold
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.clearautohold()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Clears all autohold keys
					$LF
				]li
			]ul
			[p 
				[b 
					"client.closerom
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.closerom()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Closes the loaded Rom
					$LF
				]li
			]ul
			[p 
				[b 
					"client.enablerewind
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.enablerewind(bool enabled)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets whether or not the rewind feature is enabled
					$LF
				]li
			]ul
			[p 
				[b 
					"client.frameskip
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.frameskip(int numframes)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the frame skip value of the client UI
					$LF
				]li
			]ul
			[p 
				[b 
					"client.gettargetscanlineintensity
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.gettargetscanlineintensity()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the current scanline intensity setting, used for the scanline display filter
					$LF
				]li
			]ul
			[p 
				[b 
					"client.getwindowsize
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.getwindowsize()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the main window's size Possible values are 1, 2, 3, 4, 5, and 10
					$LF
				]li
			]ul
			[p 
				[b 
					"client.SetGameExtraPadding
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.SetGameExtraPadding(int left, int top, int right, int bottom)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the extra padding added to the 'emu' surface so that you can draw HUD elements in predictable placements
					$LF
				]li
			]ul
			[p 
				[b 
					"client.SetSoundOn
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.SetSoundOn(bool enable)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the state of the Sound On toggle
					$LF
				]li
			]ul
			[p 
				[b 
					"client.GetSoundOn
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool client.GetSoundOn()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the state of the Sound On toggle
					$LF
				]li
			]ul
			[p 
				[b 
					"client.SetClientExtraPadding
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.SetClientExtraPadding(int left, int top, int right, int bottom)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the extra padding added to the 'native' surface so that you can draw HUD elements in predictable placements
					$LF
				]li
			]ul
			[p 
				[b 
					"client.ispaused
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool client.ispaused()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns true if emulator is paused, otherwise, false
					$LF
				]li
			]ul
			[p 
				[b 
					"client.isturbo
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool client.isturbo()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns true if emulator is in turbo mode, otherwise, false
					$LF
				]li
			]ul
			[p 
				[b 
					"client.isseeking
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool client.isseeking()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns true if emulator is seeking, otherwise, false
					$LF
				]li
			]ul
			[p 
				[b 
					"client.opencheats
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.opencheats()
					$LF
				]li
			]ul
			[ul 
				[li 
					" opens the Cheats dialog
					$LF
				]li
			]ul
			[p 
				[b 
					"client.openhexeditor
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.openhexeditor()
					$LF
				]li
			]ul
			[ul 
				[li 
					" opens the Hex Editor dialog
					$LF
				]li
			]ul
			[p 
				[b 
					"client.openramwatch
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.openramwatch()
					$LF
				]li
			]ul
			[ul 
				[li 
					" opens the RAM Watch dialog
					$LF
				]li
			]ul
			[p 
				[b 
					"client.openramsearch
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.openramsearch()
					$LF
				]li
			]ul
			[ul 
				[li 
					" opens the RAM Search dialog
					$LF
				]li
			]ul
			[p 
				[b 
					"client.openrom
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.openrom(string path)
					$LF
				]li
			]ul
			[ul 
				[li 
					" opens the Open ROM dialog
					$LF
				]li
			]ul
			[p 
				[b 
					"client.opentasstudio
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.opentasstudio()
					$LF
				]li
			]ul
			[ul 
				[li 
					" opens the TAStudio dialog
					$LF
				]li
			]ul
			[p 
				[b 
					"client.opentoolbox
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.opentoolbox()
					$LF
				]li
			]ul
			[ul 
				[li 
					" opens the Toolbox Dialog
					$LF
				]li
			]ul
			[p 
				[b 
					"client.opentracelogger
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.opentracelogger()
					$LF
				]li
			]ul
			[ul 
				[li 
					" opens the tracelogger if it is available for the given core
					$LF
				]li
			]ul
			[p 
				[b 
					"client.pause
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.pause()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Pauses the emulator
					$LF
				]li
			]ul
			[p 
				[b 
					"client.pause_av
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.pause_av()
					$LF
				]li
			]ul
			[ul 
				[li 
					" If currently capturing Audio/Video, this will suspend the record. Frames will not be captured into the AV until client.unpause_av() is called
					$LF
				]li
			]ul
			[p 
				[b 
					"client.reboot_core
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.reboot_core()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Reboots the currently loaded core
					$LF
				]li
			]ul
			[p 
				[b 
					"client.screenheight
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.screenheight()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the current height in pixels of the emulator's drawing area
					$LF
				]li
			]ul
			[p 
				[b 
					"client.screenshot
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.screenshot([string path = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" if a parameter is passed it will function as the Screenshot As menu item of EmuHawk, else it will function as the Screenshot menu item
					$LF
				]li
			]ul
			[p 
				[b 
					"client.screenshottoclipboard
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.screenshottoclipboard()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Performs the same function as EmuHawk's Screenshot To Clipboard menu item
					$LF
				]li
			]ul
			[p 
				[b 
					"client.settargetscanlineintensity
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.settargetscanlineintensity(int val)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the current scanline intensity setting, used for the scanline display filter
					$LF
				]li
			]ul
			[p 
				[b 
					"client.setscreenshotosd
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.setscreenshotosd(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the screenshot Capture OSD property of the client
					$LF
				]li
			]ul
			[p 
				[b 
					"client.screenwidth
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.screenwidth()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the current width in pixels of the emulator's drawing area
					$LF
				]li
			]ul
			[p 
				[b 
					"client.setwindowsize
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.setwindowsize(int size)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the main window's size to the give value. Accepted values are 1, 2, 3, 4, 5, and 10
					$LF
				]li
			]ul
			[p 
				[b 
					"client.speedmode
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.speedmode(int percent)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the speed of the emulator (in terms of percent)
					$LF
				]li
			]ul
			[p 
				[b 
					"client.togglepause
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.togglepause()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Toggles the current pause state
					$LF
				]li
			]ul
			[p 
				[b 
					"client.transformPointX
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.transformPointX(int x)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Transforms an x-coordinate in emulator space to an x-coordinate in client space
					$LF
				]li
			]ul
			[p 
				[b 
					"client.transformPointY
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.transformPointY(int y)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Transforms an y-coordinate in emulator space to an y-coordinate in client space
					$LF
				]li
			]ul
			[p 
				[b 
					"client.unpause
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.unpause()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Unpauses the emulator
					$LF
				]li
			]ul
			[p 
				[b 
					"client.unpause_av
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.unpause_av()
					$LF
				]li
			]ul
			[ul 
				[li 
					" If currently capturing Audio/Video this resumes capturing
					$LF
				]li
			]ul
			[p 
				[b 
					"client.xpos
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.xpos()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the x value of the screen position where the client currently sits
					$LF
				]li
			]ul
			[p 
				[b 
					"client.ypos
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int client.ypos()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the y value of the screen position where the client currently sits
					$LF
				]li
			]ul
			[p 
				[b 
					"client.getavailabletools
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable client.getavailabletools()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a list of the tools currently open
					$LF
				]li
			]ul
			[p 
				[b 
					"client.gettool
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable client.gettool(string name)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns an object that represents a tool of the given name (not case sensitive). If the tool is not open, it will be loaded if available. Use gettools to get a list of names
					$LF
				]li
			]ul
			[p 
				[b 
					"client.createinstance
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable client.createinstance(string name)
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns a default instance of the given type of object if it exists (not case sensitive). Note: This will only work on objects which have a parameterless constructor.  If no suitable type is found, or the type does not have a parameterless constructor, then nil is returned
					$LF
				]li
			]ul
			[p 
				[b 
					"client.displaymessages
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.displaymessages(bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" sets whether or not on screen messages will display
					$LF
				]li
			]ul
			[p 
				[b 
					"client.saveram
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void client.saveram()
					$LF
				]li
			]ul
			[ul 
				[li 
					" flushes save ram to disk
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-832 
			[p 
				"A library for communicating with other programs
				$LF
			]p
			[p 
				[b 
					"comm.getluafunctionslist
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.getluafunctionslist()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns a list of implemented functions
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.socketServerScreenShot
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.socketServerScreenShot()
					$LF
				]li
			]ul
			[ul 
				[li 
					" sends a screenshot to the Socket server
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.socketServerScreenShotResponse
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.socketServerScreenShotResponse()
					$LF
				]li
			]ul
			[ul 
				[li 
					" sends a screenshot to the Socket server and retrieves the response
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.socketServerSend
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.socketServerSend(string sendstring )
					$LF
				]li
			]ul
			[ul 
				[li 
					" sends a string to the Socket server
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.socketServerResponse
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.socketServerResponse()
					$LF
				]li
			]ul
			[ul 
				[li 
					" receives a message from the Socket server
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.socketServerSuccessful
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool comm.socketServerSuccessful()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the status of the last Socket server action
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.socketServerSetTimeout
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void comm.socketServerSetTimeout(int timeout)
					$LF
				]li
			]ul
			[ul 
				[li 
					" sets the timeout in milliseconds for receiving messages
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.mmfSetFilename
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void comm.mmfSetFilename(string filename)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the filename for the screenshots
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.mmfGetFilename
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.mmfGetFilename()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the filename for the screenshots
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.mmfScreenshot
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int comm.mmfScreenshot()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Saves screenshot to memory mapped file
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.mmfWrite
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int comm.mmfWrite(string mmf_filename, string outputstring )
					$LF
				]li
			]ul
			[ul 
				[li 
					" Writes a string to a memory mapped file
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.mmfRead
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.mmfRead(string mmf_filename, int expectedsize)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Reads a string from a memory mapped file
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpTest
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.httpTest()
					$LF
				]li
			]ul
			[ul 
				[li 
					" tests HTTP connections
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpTestGet
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.httpTestGet()
					$LF
				]li
			]ul
			[ul 
				[li 
					" tests the HTTP GET connection
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpGet
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.httpGet(string url)
					$LF
				]li
			]ul
			[ul 
				[li 
					" makes a HTTP GET request
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpPost
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.httpPost(string url, string payload)
					$LF
				]li
			]ul
			[ul 
				[li 
					" makes a HTTP POST request
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpPostScreenshot
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.httpPostScreenshot()
					$LF
				]li
			]ul
			[ul 
				[li 
					" HTTP POST screenshot
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpSetTimeout
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void comm.httpSetTimeout(int timeout)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets HTTP timeout in milliseconds
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpSetPostUrl
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void comm.httpSetPostUrl(string url)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets HTTP POST URL
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpSetGetUrl
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void comm.httpSetGetUrl(string url)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets HTTP GET URL
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpGetPostUrl
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.httpGetPostUrl()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets HTTP POST URL
					$LF
				]li
			]ul
			[p 
				[b 
					"comm.httpGetGetUrl
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string comm.httpGetGetUrl()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets HTTP GET URL
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-833 
			[p 
				[b 
					"console.clear
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void console.clear()
					$LF
				]li
			]ul
			[ul 
				[li 
					" clears the output box of the Lua Console window
					$LF
				]li
			]ul
			[p 
				[b 
					"console.getluafunctionslist
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string console.getluafunctionslist()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns a list of implemented functions
					$LF
				]li
			]ul
			[p 
				[b 
					"console.log
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void console.log(object[] outputs)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Outputs the given object to the output box on the Lua Console dialog. Note: Can accept a LuaTable
					$LF
				]li
			]ul
			[p 
				[b 
					"console.writeline
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void console.writeline(object[] outputs)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Outputs the given object to the output box on the Lua Console dialog. Note: Can accept a LuaTable
					$LF
				]li
			]ul
			[p 
				[b 
					"console.write
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void console.write(object[] outputs)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Outputs the given object to the output box on the Lua Console dialog. Note: Can accept a LuaTable
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-834 
			[p 
				"A library for creating and managing custom dialogs
				$LF
			]p
			[p 
				[b 
					"forms.addclick
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.addclick(int handle, nluafunc clickevent)
					$LF
				]li
			]ul
			[ul 
				[li 
					" adds the given lua function as a click event to the given control
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.button
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int forms.button(int formhandle, string caption, nluafunc clickevent, [int? x = null], [int? y = null], [int? width = null], [int? height = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a button control on the given form. The caption property will be the text value on the button. clickEvent is the name of a Lua function that will be invoked when the button is clicked. x, and y are the optional location parameters for the position of the button within the given form. The function returns the handle of the created button. Width and Height are optional, if not specified they will be a default size
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.checkbox
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int forms.checkbox(int formhandle, string caption, [int? x = null], [int? y = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a checkbox control on the given form. The caption property will be the text of the checkbox. x and y are the optional location parameters for the position of the checkbox within the form
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.clearclicks
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.clearclicks(int handle)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Removes all click events from the given widget at the specified handle
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.destroy
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool forms.destroy(int handle)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Closes and removes a Lua created form with the specified handle. If a dialog was found and removed true is returned, else false
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.destroyall
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.destroyall()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Closes and removes all Lua created dialogs
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.dropdown
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int forms.dropdown(int formhandle, nluatable items, [int? x = null], [int? y = null], [int? width = null], [int? height = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a dropdown (with a ComboBoxStyle of DropDownList) control on the given form. Dropdown items are passed via a lua table. Only the values will be pulled for the dropdown items, the keys are irrelevant. Items will be sorted alphabetically. x and y are the optional location parameters, and width and height are the optional size parameters.
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.getproperty
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string forms.getproperty(int handle, string property)
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns a string representation of the value of a property of the widget at the given handle
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.gettext
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string forms.gettext(int handle)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the text property of a given form or control
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.ischecked
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool forms.ischecked(int handle)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns the given checkbox's checked property
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.label
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int forms.label(int formhandle, string caption, [int? x = null], [int? y = null], [int? width = null], [int? height = null], [bool fixedwidth = False])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a label control on the given form. The caption property is the text of the label. x, and y are the optional location parameters for the position of the label within the given form. The function returns the handle of the created label. Width and Height are optional, if not specified they will be a default size.
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.newform
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int forms.newform([int? width = null], [int? height = null], [string title = null], [nluafunc onclose = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" creates a new default dialog, if both width and height are specified it will create a dialog of the specified size. If title is specified it will be the caption of the dialog, else the dialog caption will be 'Lua Dialog'. The function will return an int representing the handle of the dialog created.
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.openfile
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string forms.openfile([string filename = null], [string initialdirectory = null], [string filter = All files (*.*)|*.*])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a standard openfile dialog with optional parameters for the filename, directory, and filter. The return value is the directory that the user picked. If they chose to cancel, it will return an empty string
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.pictureBox
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int forms.pictureBox(int formhandle, [int? x = null], [int? y = null], [int? width = null], [int? height = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a new drawing area in the form. Optionally the location in the form as well as the size of the drawing area can be specified. Returns the handle the component can be refered to with.
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.clear
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.clear(int componenthandle, color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Clears the canvas
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.refresh
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.refresh(int componenthandle)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Redraws the canvas
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.setDefaultForegroundColor
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.setDefaultForegroundColor(int componenthandle, color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default foreground color to use in drawing methods, white by default
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.setDefaultBackgroundColor
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.setDefaultBackgroundColor(int componenthandle, color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default background color to use in drawing methods, transparent by default
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.setDefaultTextBackground
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.setDefaultTextBackground(int componenthandle, color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default backgroiund color to use in text drawing methods, half-transparent black by default
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawBezier
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawBezier(int componenthandle, nluatable points, color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a Bezier curve using the table of coordinates provided in the given color
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawBox
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawBox(int componenthandle, int x, int y, int x2, int y2, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a rectangle on screen from x1/y1 to x2/y2. Same as drawRectangle except it receives two points intead of a point and width/height
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawEllipse
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawEllipse(int componenthandle, int x, int y, int width, int height, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws an ellipse at the given coordinates and the given width and height. Line is the color of the ellipse. Background is the optional fill color
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawIcon
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawIcon(int componenthandle, string path, int x, int y, [int? width = null], [int? height = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws an Icon (.ico) file from the given path at the given coordinate. width and height are optional. If specified, it will resize the image accordingly
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawImage
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawImage(int componenthandle, string path, int x, int y, [int? width = null], [int? height = null], [bool cache = True])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws an image file from the given path at the given coordinate. width and height are optional. If specified, it will resize the image accordingly
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.clearImageCache
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.clearImageCache(int componenthandle)
					$LF
				]li
			]ul
			[ul 
				[li 
					" clears the image cache that is built up by using gui.drawImage, also releases the file handle for cached images
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawImageRegion
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawImageRegion(int componenthandle, string path, int source_x, int source_y, int source_width, int source_height, int dest_x, int dest_y, [int? dest_width = null], [int? dest_height = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws a given region of an image file from the given path at the given coordinate, and optionally with the given size
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawLine
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawLine(int componenthandle, int x1, int y1, int x2, int y2, [color? color = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a line from the first coordinate pair to the 2nd. Color is optional (if not specified it will be drawn black)
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawAxis
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawAxis(int componenthandle, int x, int y, int size, [color? color = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws an axis of the specified size at the coordinate pair.)
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawArc
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawArc(int componenthandle, int x, int y, int width, int height, int startangle, int sweepangle, [color? line = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws a Arc shape at the given coordinates and the given width and height
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawPie
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawPie(int componenthandle, int x, int y, int width, int height, int startangle, int sweepangle, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws a Pie shape at the given coordinates and the given width and height
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawPixel
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawPixel(int componenthandle, int x, int y, [color? color = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a single pixel at the given coordinates in the given color. Color is optional (if not specified it will be drawn black)
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawPolygon
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawPolygon(int componenthandle, nluatable points, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a polygon using the table of coordinates specified in points. This should be a table of tables(each of size 2). Line is the color of the polygon. Background is the optional fill color
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawRectangle
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawRectangle(int componenthandle, int x, int y, int width, int height, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a rectangle at the given coordinate and the given width and height. Line is the color of the box. Background is the optional fill color
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawString
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawString(int componenthandle, int x, int y, string message, [color? forecolor = null], [color? backcolor = null], [int? fontsize = null], [string fontfamily = null], [string fontstyle = null], [string horizalign = null], [string vertalign = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Alias of DrawText()
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.drawText
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.drawText(int componenthandle, int x, int y, string message, [color? forecolor = null], [color? backcolor = null], [int? fontsize = null], [string fontfamily = null], [string fontstyle = null], [string horizalign = null], [string vertalign = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws the given message at the given x,y coordinates and the given color. The default color is white. A fontfamily can be specified and is monospace generic if none is specified (font family options are the same as the .NET FontFamily class). The fontsize default is 12. The default font style is regular. Font style options are regular, bold, italic, strikethrough, underline. Horizontal alignment options are left (default), center, or right. Vertical alignment options are bottom (default), middle, or top. Alignment options specify which ends of the text will be drawn at the x and y coordinates.
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.getMouseX
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int forms.getMouseX(int componenthandle)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns an integer representation of the mouse X coordinate relative to the PictureBox.
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.getMouseY
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int forms.getMouseY(int componenthandle)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns an integer representation of the mouse Y coordinate relative to the PictureBox.
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.setdropdownitems
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.setdropdownitems(int handle, nluatable items)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the items for a given dropdown box
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.setlocation
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.setlocation(int handle, int x, int y)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the location of a control or form by passing in the handle of the created object
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.setproperty
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.setproperty(int handle, string property, object value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Attempts to set the given property of the widget with the given value.  Note: not all properties will be able to be represented for the control to accept
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.createcolor
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" color forms.createcolor(int r, int g, int b, int a)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a color object useful with setproperty
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.setsize
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.setsize(int handle, int width, int height)
					$LF
				]li
			]ul
			[ul 
				[li 
					" TODO
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.settext
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void forms.settext(int handle, string caption)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the text property of a control or form by passing in the handle of the created object
					$LF
				]li
			]ul
			[p 
				[b 
					"forms.textbox
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int forms.textbox(int formhandle, [string caption = null], [int? width = null], [int? height = null], [string boxtype = null], [int? x = null], [int? y = null], [bool multiline = False], [bool fixedwidth = False], [string scrollbars = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a textbox control on the given form. The caption property will be the initial value of the textbox (default is empty). Width and Height are option, if not specified they will be a default size of 100, 20. Type is an optional property to restrict the textbox input. The available options are HEX, SIGNED, and UNSIGNED. Passing it null or any other value will set it to no restriction. x, and y are the optional location parameters for the position of the textbox within the given form. The function returns the handle of the created textbox. If true, the multiline will enable the standard winform multi-line property. If true, the fixedWidth options will create a fixed width font. Scrollbars is an optional property to specify which scrollbars to display. The available options are Vertical, Horizontal, Both, and None. Scrollbars are only shown on a multiline textbox
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-835 
			[p 
				[b 
					"gui.DrawNew
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.DrawNew(string name, [bool? clear = True])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Changes drawing target to the specified lua surface name. This may clobber any previous drawing to this surface (pass false if you don't want it to)
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.DrawFinish
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.DrawFinish()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Finishes drawing to the current lua surface and causes it to get displayed.
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.addmessage
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.addmessage(string message)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Adds a message to the OSD's message area
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.clearGraphics
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.clearGraphics()
					$LF
				]li
			]ul
			[ul 
				[li 
					" clears all lua drawn graphics from the screen
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.cleartext
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.cleartext()
					$LF
				]li
			]ul
			[ul 
				[li 
					" clears all text created by gui.text()
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.defaultForeground
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.defaultForeground(color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default foreground color to use in drawing methods, white by default
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.defaultBackground
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.defaultBackground(color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default background color to use in drawing methods, transparent by default
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.defaultTextBackground
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.defaultTextBackground(color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default backgroiund color to use in text drawing methods, half-transparent black by default
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.defaultPixelFont
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.defaultPixelFont(string fontfamily)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default font to use in gui.pixelText(). Two font families are available, "fceux" and "gens" (or  "0" and "1" respectively), "gens" is used by default
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawBezier
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawBezier(nluatable points, color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a Bezier curve using the table of coordinates provided in the given color
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawBox
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawBox(int x, int y, int x2, int y2, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a rectangle on screen from x1/y1 to x2/y2. Same as drawRectangle except it receives two points intead of a point and width/height
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawEllipse
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawEllipse(int x, int y, int width, int height, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws an ellipse at the given coordinates and the given width and height. Line is the color of the ellipse. Background is the optional fill color
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawIcon
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawIcon(string path, int x, int y, [int? width = null], [int? height = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws an Icon (.ico) file from the given path at the given coordinate. width and height are optional. If specified, it will resize the image accordingly
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawImage
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawImage(string path, int x, int y, [int? width = null], [int? height = null], [bool cache = True])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws an image file from the given path at the given coordinate. width and height are optional. If specified, it will resize the image accordingly
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.clearImageCache
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.clearImageCache()
					$LF
				]li
			]ul
			[ul 
				[li 
					" clears the image cache that is built up by using gui.drawImage, also releases the file handle for cached images
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawImageRegion
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawImageRegion(string path, int source_x, int source_y, int source_width, int source_height, int dest_x, int dest_y, [int? dest_width = null], [int? dest_height = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws a given region of an image file from the given path at the given coordinate, and optionally with the given size
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawLine
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawLine(int x1, int y1, int x2, int y2, [color? color = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a line from the first coordinate pair to the 2nd. Color is optional (if not specified it will be drawn black)
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawAxis
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawAxis(int x, int y, int size, [color? color = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws an axis of the specified size at the coordinate pair.)
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawPie
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawPie(int x, int y, int width, int height, int startangle, int sweepangle, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws a Pie shape at the given coordinates and the given width and height
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawPixel
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawPixel(int x, int y, [color? color = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a single pixel at the given coordinates in the given color. Color is optional (if not specified it will be drawn black)
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawPolygon
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawPolygon(nluatable points, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a polygon using the table of coordinates specified in points. This should be a table of tables(each of size 2). Line is the color of the polygon. Background is the optional fill color
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawRectangle
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawRectangle(int x, int y, int width, int height, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a rectangle at the given coordinate and the given width and height. Line is the color of the box. Background is the optional fill color
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawString
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawString(int x, int y, string message, [color? forecolor = null], [color? backcolor = null], [int? fontsize = null], [string fontfamily = null], [string fontstyle = null], [string horizalign = null], [string vertalign = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Alias of gui.drawText()
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.drawText
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.drawText(int x, int y, string message, [color? forecolor = null], [color? backcolor = null], [int? fontsize = null], [string fontfamily = null], [string fontstyle = null], [string horizalign = null], [string vertalign = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws the given message in the emulator screen space (like all draw functions) at the given x,y coordinates and the given color. The default color is white. A fontfamily can be specified and is monospace generic if none is specified (font family options are the same as the .NET FontFamily class). The fontsize default is 12. The default font style is regular. Font style options are regular, bold, italic, strikethrough, underline. Horizontal alignment options are left (default), center, or right. Vertical alignment options are bottom (default), middle, or top. Alignment options specify which ends of the text will be drawn at the x and y coordinates.
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.pixelText
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.pixelText(int x, int y, string message, [color? forecolor = null], [color? backcolor = null], [string fontfamily = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws the given message in the emulator screen space (like all draw functions) at the given x,y coordinates and the given color. The default color is white. Two font families are available, "fceux" and "gens" (or  "0" and "1" respectively), both are monospace and have the same size as in the emulaors they've been taken from. If no font family is specified, it uses "gens" font, unless that's overridden via gui.defaultPixelFont()
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.text
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void gui.text(int x, int y, string message, [color? forecolor = null], [string anchor = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Displays the given text on the screen at the given coordinates. Optional Foreground color. The optional anchor flag anchors the text to one of the four corners. Anchor flag parameters: topleft, topright, bottomleft, bottomright
					$LF
				]li
			]ul
			[p 
				[b 
					"gui.createcanvas
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable gui.createcanvas(int width, int height, [int? x = null], [int? y = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Creates a canvas of the given size and, if specified, the given coordinates.
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-836 
			[p 
				[b 
					"input.get
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable input.get()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a lua table of all the buttons the user is currently pressing on their keyboard and gamepads
					$LF
				]li
			]ul
			[p 
				"All buttons that are pressed have their key values set to true; all others remain nil.
				$LF
			]p
			[p 
				[b 
					"input.getmouse
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable input.getmouse()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a lua table of the mouse X/Y coordinates and button states. Table keys are X, Y, Left, Middle, Right, XButton1, XButton2, Wheel.
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-837 
			[p 
				[b 
					"savestate.load
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void savestate.load(string path)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Loads a savestate with the given path
					$LF
				]li
			]ul
			[p 
				[b 
					"savestate.loadslot
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void savestate.loadslot(int slotnum)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Loads the savestate at the given slot number (must be an integer between 0 and 9)
					$LF
				]li
			]ul
			[p 
				[b 
					"savestate.save
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void savestate.save(string path)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Saves a state at the given path
					$LF
				]li
			]ul
			[p 
				[b 
					"savestate.saveslot
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void savestate.saveslot(int slotnum)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Saves a state at the given save slot (must be an integer between 0 and 9)
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-838 
			[p 
				"A library for manipulating the Tastudio dialog of the EmuHawk client
				$LF
			]p
			[p 
				[b 
					"tastudio.engaged
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool tastudio.engaged()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns whether or not tastudio is currently engaged (active)
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.getrecording
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool tastudio.getrecording()
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns whether or not TAStudio is in recording mode
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.setrecording
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.setrecording(bool val)
					$LF
				]li
			]ul
			[ul 
				[li 
					" sets the recording mode on/off depending on the parameter
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.togglerecording
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.togglerecording()
					$LF
				]li
			]ul
			[ul 
				[li 
					" toggles tastudio recording mode on/off depending on its current state
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.setbranchtext
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.setbranchtext(string text, [int? index = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" adds the given message to the existing branch, or to the branch that will be created next if branch index is not specified
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.getmarker
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" string tastudio.getmarker(int frame)
					$LF
				]li
			]ul
			[ul 
				[li 
					" returns the marker text at the given frame, or an empty string if there is no marker for the given frame
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.removemarker
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.removemarker(int frame)
					$LF
				]li
			]ul
			[ul 
				[li 
					" if there is a marker for the given frame, it will be removed
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.setmarker
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.setmarker(int frame, [string message = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Adds or sets a marker at the given frame, with an optional message
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.islag
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool? tastudio.islag(int frame)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether or not the given frame was a lag frame, null if unknown
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.setlag
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.setlag(int frame, bool? value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the lag information for the given frame, if the frame does not exist in the lag log, it will be added. If the value is null, the lag information for that frame will be removed
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.hasstate
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" bool tastudio.hasstate(int frame)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns whether or not the given frame has a savestate associated with it
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.setplayback
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.setplayback(object frame)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Seeks the given frame (a number) or marker (a string)
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.onqueryitembg
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.onqueryitembg(nluafunc luaf)
					$LF
				]li
			]ul
			[ul 
				[li 
					" called during the background draw event of the tastudio listview. luaf must be a function that takes 2 params: index, column.  The first is the integer row index of the listview, and the 2nd is the string column name. luaf should return a value that can be parsed into a .NET Color object (string color name, or integer value)
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.onqueryitemtext
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.onqueryitemtext(nluafunc luaf)
					$LF
				]li
			]ul
			[ul 
				[li 
					" called during the text draw event of the tastudio listview. luaf must be a function that takes 2 params: index, column.  The first is the integer row index of the listview, and the 2nd is the string column name. luaf should return a value that can be parsed into a .NET Color object (string color name, or integer value)
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.onqueryitemicon
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.onqueryitemicon(nluafunc luaf)
					$LF
				]li
			]ul
			[ul 
				[li 
					" called during the icon draw event of the tastudio listview. luaf must be a function that takes 2 params: index, column.  The first is the integer row index of the listview, and the 2nd is the string column name. luaf should return a value that can be parsed into a .NET Color object (string color name, or integer value)
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.ongreenzoneinvalidated
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.ongreenzoneinvalidated(nluafunc luaf)
					$LF
				]li
			]ul
			[ul 
				[li 
					" called whenever the greenzone is invalidated and returns the first frame that was invalidated
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.onbranchload
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.onbranchload(nluafunc luaf)
					$LF
				]li
			]ul
			[ul 
				[li 
					" called whenever a branch is loaded. luaf must be a function that takes the integer branch index as a parameter
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.onbranchsave
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.onbranchsave(nluafunc luaf)
					$LF
				]li
			]ul
			[ul 
				[li 
					" called whenever a branch is created or updated. luaf must be a function that takes the integer branch index as a parameter
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.onbranchremove
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.onbranchremove(nluafunc luaf)
					$LF
				]li
			]ul
			[ul 
				[li 
					" called whenever a branch is removed. luaf must be a function that takes the integer branch index as a parameter
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.getselection
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable tastudio.getselection()
					$LF
				]li
			]ul
			[ul 
				[li 
					" gets the currently selected frames
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.getbranches
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable tastudio.getbranches()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns a list of the current tastudio branches.  Each entry will have the Id, Frame, and Text properties of the branch
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.getbranchinput
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" nluatable tastudio.getbranchinput(string branchid, int frame)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Gets the controller state of the given frame with the given branch identifier
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.submitinputchange
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.submitinputchange(int frame, string button, bool value)
					$LF
				]li
			]ul
			[ul 
				[li 
					" 
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.submitanalogchange
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.submitanalogchange(int frame, string button, singlevalue)
					$LF
				]li
			]ul
			[ul 
				[li 
					" 
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.submitinsertframes
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.submitinsertframes(int frame, int number)
					$LF
				]li
			]ul
			[ul 
				[li 
					" 
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.submitdeleteframes
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.submitdeleteframes(int frame, int number)
					$LF
				]li
			]ul
			[ul 
				[li 
					" 
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.applyinputchanges
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.applyinputchanges()
					$LF
				]li
			]ul
			[ul 
				[li 
					" 
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.clearinputchanges
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.clearinputchanges()
					$LF
				]li
			]ul
			[ul 
				[li 
					" 
					$LF
				]li
			]ul
			[p 
				[b 
					"tastudio.addcolumn
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void tastudio.addcolumn(string name, string text, int width)
					$LF
				]li
			]ul
			[ul 
				[li 
					" 
					$LF
				]li
			]ul
		]div
		[div class=tab-pane fade id=y-839 
			[p 
				"Represents a canvas object returned by the gui.createcanvas() method
				$LF
			]p
			[p 
				[b 
					"LuaCanvas.setTitle
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.setTitle(string title)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the canvas window title
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.setLocation
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.setLocation(int x, int y)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the location of the canvas window
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.clear
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.clear(color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Clears the canvas
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.refresh
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.refresh()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Redraws the canvas
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.setDefaultForegroundColor
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.setDefaultForegroundColor(color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default foreground color to use in drawing methods, white by default
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.setDefaultBackgroundColor
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.setDefaultBackgroundColor(color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default background color to use in drawing methods, transparent by default
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.setDefaultTextBackground
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.setDefaultTextBackground(color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Sets the default backgroiund color to use in text drawing methods, half-transparent black by default
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawBezier
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawBezier(nluatable points, color color)
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a Bezier curve using the table of coordinates provided in the given color
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawBox
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawBox(int x, int y, int x2, int y2, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a rectangle on screen from x1/y1 to x2/y2. Same as drawRectangle except it receives two points intead of a point and width/height
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawEllipse
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawEllipse(int x, int y, int width, int height, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws an ellipse at the given coordinates and the given width and height. Line is the color of the ellipse. Background is the optional fill color
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawIcon
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawIcon(string path, int x, int y, [int? width = null], [int? height = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws an Icon (.ico) file from the given path at the given coordinate. width and height are optional. If specified, it will resize the image accordingly
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawImage
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawImage(string path, int x, int y, [int? width = null], [int? height = null], [bool cache = True])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws an image file from the given path at the given coordinate. width and height are optional. If specified, it will resize the image accordingly
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.clearImageCache
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.clearImageCache()
					$LF
				]li
			]ul
			[ul 
				[li 
					" clears the image cache that is built up by using gui.drawImage, also releases the file handle for cached images
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawImageRegion
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawImageRegion(string path, int source_x, int source_y, int source_width, int source_height, int dest_x, int dest_y, [int? dest_width = null], [int? dest_height = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws a given region of an image file from the given path at the given coordinate, and optionally with the given size
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawLine
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawLine(int x1, int y1, int x2, int y2, [color? color = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a line from the first coordinate pair to the 2nd. Color is optional (if not specified it will be drawn black)
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawAxis
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawAxis(int x, int y, int size, [color? color = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws an axis of the specified size at the coordinate pair.)
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawArc
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawArc(int x, int y, int width, int height, int startangle, int sweepangle, [color? line = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws a Arc shape at the given coordinates and the given width and height
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawPie
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawPie(int x, int y, int width, int height, int startangle, int sweepangle, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" draws a Pie shape at the given coordinates and the given width and height
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawPixel
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawPixel(int x, int y, [color? color = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a single pixel at the given coordinates in the given color. Color is optional (if not specified it will be drawn black)
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawPolygon
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawPolygon(nluatable points, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a polygon using the table of coordinates specified in points. This should be a table of tables(each of size 2). Line is the color of the polygon. Background is the optional fill color
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawRectangle
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawRectangle(int x, int y, int width, int height, [color? line = null], [color? background = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws a rectangle at the given coordinate and the given width and height. Line is the color of the box. Background is the optional fill color
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawString
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawString(int x, int y, string message, [color? forecolor = null], [color? backcolor = null], [int? fontsize = null], [string fontfamily = null], [string fontstyle = null], [string horizalign = null], [string vertalign = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Alias of DrawText()
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.drawText
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" void LuaCanvas.drawText(int x, int y, string message, [color? forecolor = null], [color? backcolor = null], [int? fontsize = null], [string fontfamily = null], [string fontstyle = null], [string horizalign = null], [string vertalign = null])
					$LF
				]li
			]ul
			[ul 
				[li 
					" Draws the given message at the given x,y coordinates and the given color. The default color is white. A fontfamily can be specified and is monospace generic if none is specified (font family options are the same as the .NET FontFamily class). The fontsize default is 12. The default font style is regular. Font style options are regular, bold, italic, strikethrough, underline. Horizontal alignment options are left (default), center, or right. Vertical alignment options are bottom (default), middle, or top. Alignment options specify which ends of the text will be drawn at the x and y coordinates.
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.getMouseX
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int LuaCanvas.getMouseX()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns an integer representation of the mouse X coordinate relative to the canvas window.
					$LF
				]li
			]ul
			[p 
				[b 
					"LuaCanvas.getMouseY
				]b
				[br 
				]br
				$LF
			]p
			[ul 
				[li 
					" int LuaCanvas.getMouseY()
					$LF
				]li
			]ul
			[ul 
				[li 
					" Returns an integer representation of the mouse Y coordinate relative to the canvas window.
					$LF
				]li
			]ul
		]div
	]div
]div
