4
[div class=p 
	"Original sources: 
	[a href=https://github.com/TASEmulators/snes9x-rr/wiki/Lua-Functions rel=noopener external nofollow 
		"Github
	]a
	" and 
	[a href=https://code.google.com/archive/p/snes9x-rr/wikis/LuaScriptingFunctions.wiki rel=noopener external nofollow 
		"Google Code
	]a
	".
	$LF
]div
[div class=card mb-2 
	[div class=card-header 
		[strong 
			"Table of contents
		]strong
	]div
	[div class=card-body 
		[ul 
			[li 
				[a href=#Global 
					" Global
					$LF
				]a
				[ul 
					[li 
						[a href=#Print 
							" print
							$LF
						]a
					]li
					[li 
						[a href=#Tostring 
							" tostring
							$LF
						]a
					]li
					[li 
						[a href=#Addressof 
							" addressof
							$LF
						]a
					]li
					[li 
						[a href=#Copytable 
							" copytable
							$LF
						]a
					]li
					[li 
						[a href=#AndOrXorShiftBit 
							" AND,OR,XOR,SHIFT,BIT
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Emu 
					" emu
					$LF
				]a
				[ul 
					[li 
						[a href=#EmuSpeedmodeStringMode 
							" emu.speedmode(string mode)
							$LF
						]a
					]li
					[li 
						[a href=#EmuFrameadvance 
							" emu.frameadvance()
							$LF
						]a
					]li
					[li 
						[a href=#EmuPause 
							" emu.pause()
							$LF
						]a
					]li
					[li 
						[a href=#IntEmuFramecount 
							" int emu.framecount()
							$LF
						]a
					]li
					[li 
						[a href=#IntEmuLagcount 
							" int emu.lagcount()
							$LF
						]a
					]li
					[li 
						[a href=#BooleanEmuLagged 
							" boolean emu.lagged()
							$LF
						]a
					]li
					[li 
						[a href=#BooleanEmuEmulating 
							" boolean emu.emulating()
							$LF
						]a
					]li
					[li 
						[a href=#EmuRegisterbeforeFunctionFunc 
							" emu.registerbefore(function func)
							$LF
						]a
					]li
					[li 
						[a href=#EmuRegisterafterFunctionFunc 
							" emu.registerafter(function func)
							$LF
						]a
					]li
					[li 
						[a href=#EmuRegisterexitFunctionFunc 
							" emu.registerexit(function func)
							$LF
						]a
					]li
					[li 
						[a href=#EmuMessageStringMsg 
							" emu.message(string msg)
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Memory 
					" memory
					$LF
				]a
				[ul 
					[li 
						[a href=#IntMemoryReadbyteIntAddr 
							" int memory.readbyte(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#IntMemoryReadbytesignedIntAddr 
							" int memory.readbytesigned(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#IntMemoryReadwordIntAddr 
							" int memory.readword(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#IntMemoryReadwordsignedIntAddr 
							" int memory.readwordsigned(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#IntMemoryReaddwordIntAddr 
							" int memory.readdword(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#IntMemoryReaddwordsignedIntAddr 
							" int memory.readdwordsigned(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#StringMemoryReadbyterangeIntStartaddrIntLength 
							" string memory.readbyterange(int startaddr, int length)
							$LF
						]a
					]li
					[li 
						[a href=#MemoryWritebyteIntAddrIntValue 
							" memory.writebyte(int addr, int value)
							$LF
						]a
					]li
					[li 
						[a href=#MemoryWritewordIntAddrIntValue 
							" memory.writeword(int addr, int value)
							$LF
						]a
					]li
					[li 
						[a href=#MemoryWritedwordIntAddrIntValue 
							" memory.writedword(int addr, int value)
							$LF
						]a
					]li
					[li 
						[a href=#MemoryGetregisterStringCpuregistername 
							" memory.getregister(string cpuregistername)
							$LF
						]a
					]li
					[li 
						[a href=#MemorySetregisterStringCpuregisternameIntValue 
							" memory.setregister(string cpuregistername, int value)
							$LF
						]a
					]li
					[li 
						[a href=#MemoryRegisterwriteIntAddrIntSizeStringCpunameFunc 
							" memory.registerwrite (int addr, [int size,] [string cpuname,] func)
							$LF
						]a
					]li
					[li 
						[a href=#MemoryRegisterreadIntAddrIntSizeStringCpunameFunc 
							" memory.registerread (int addr, [int size,] [string cpuname,] func)
							$LF
						]a
					]li
					[li 
						[a href=#MemoryRegisterexecIntAddrIntSizeStringCpunameFunc 
							" memory.registerexec (int addr, [int size,] [string cpuname,] func)
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Apu 
					" apu
					$LF
				]a
				[ul 
					[li 
						[a href=#ApuReadbyteIntAddr 
							" apu.readbyte(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#ApuReadbytesignedIntAddr 
							" apu.readbytesigned(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#ApuReadwordIntAddr 
							" apu.readword(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#ApuReadwordsignedIntAddr 
							" apu.readwordsigned(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#ApuReaddwordIntAddr 
							" apu.readdword(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#ApuReaddwordsignedIntAddr 
							" apu.readdwordsigned(int addr)
							$LF
						]a
					]li
					[li 
						[a href=#ApuReadbyterangeIntStartaddrIntLength 
							" apu.readbyterange(int startaddr, int length)
							$LF
						]a
					]li
					[li 
						[a href=#ApuWritebyteIntAddrIntValue 
							" apu.writebyte(int addr, int value)
							$LF
						]a
					]li
					[li 
						[a href=#ApuWritewordIntAddrIntValue 
							" apu.writeword(int addr, int value)
							$LF
						]a
					]li
					[li 
						[a href=#ApuWritedwordIntAddrIntValue 
							" apu.writedword(int addr, int value)
							$LF
						]a
					]li
					[li 
						[a href=#ApuWritespcStringFilenameBoolAutosearchFalse 
							" apu.writespc(string filename, [bool autosearch = false])
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Joypad 
					" joypad
					$LF
				]a
				[ul 
					[li 
						[a href=#TableJoypadGetIntPort 
							" table joypad.get(int port)
							$LF
						]a
					]li
					[li 
						[a href=#TableJoypadGetdownIntPort 
							" table joypad.getdown(int port)
							$LF
						]a
					]li
					[li 
						[a href=#TableJoypadGetupIntPort 
							" table joypad.getup(int port)
							$LF
						]a
					]li
					[li 
						[a href=#JoypadSetIntPortTableButtons 
							" joypad.set(int port, table buttons)
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Savestate 
					" savestate
					$LF
				]a
				[ul 
					[li 
						[a href=#ObjectSavestateCreateIntSlotNil 
							" object savestate.create(int slot=nil)
							$LF
						]a
					]li
					[li 
						[a href=#SavestateSaveObjectSavestate 
							" savestate.save(object savestate)
							$LF
						]a
					]li
					[li 
						[a href=#SavestateLoadObjectSavestate 
							" savestate.load(object savestate)
							$LF
						]a
					]li
					[li 
						[a href=#FunctionSavestateRegistersaveFunctionFunc 
							" function savestate.registersave(function func)
							$LF
						]a
					]li
					[li 
						[a href=#FunctionSavestateRegisterloadFunctionFunc 
							" function savestate.registerload(function func)
							$LF
						]a
					]li
					[li 
						[a href=#SavestateLoadscriptdataLocation 
							" savestate.loadscriptdata(location)
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Movie 
					" movie
					$LF
				]a
				[ul 
					[li 
						[a href=#BooleanMovieActive 
							" boolean movie.active()
							$LF
						]a
					]li
					[li 
						[a href=#BooleanMovieRecording 
							" boolean movie.recording()
							$LF
						]a
					]li
					[li 
						[a href=#BooleanMoviePlaying 
							" boolean movie.playing()
							$LF
						]a
					]li
					[li 
						[a href=#StringMovieMode 
							" string movie.mode()
							$LF
						]a
					]li
					[li 
						[a href=#IntMovieLength 
							" int movie.length()
							$LF
						]a
					]li
					[li 
						[a href=#StringMovieName 
							" string movie.name()
							$LF
						]a
					]li
					[li 
						[a href=#IntMovieRerecordcount 
							" int movie.rerecordcount()
							$LF
						]a
					]li
					[li 
						[a href=#MovieSetrerecordcountIntNumber 
							" movie.setrerecordcount(int number)
							$LF
						]a
					]li
					[li 
						[a href=#MovieRerecordcountingBooleanSkipcounting 
							" movie.rerecordcounting(boolean skipcounting)
							$LF
						]a
					]li
					[li 
						[a href=#MovieStop 
							" movie.stop()
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Gui 
					" gui
					$LF
				]a
				[ul 
					[li 
						[a href=#FunctionGuiRegisterFunctionFunc 
							" function gui.register(function func)
							$LF
						]a
					]li
					[li 
						[a href=#GuiPixelIntXIntYColorColor0xffffffff 
							" gui.pixel(int x, int y, [color color = 0xffffffff])
							$LF
						]a
					]li
					[li 
						[a href=#GuiLineIntX1IntY1IntX2IntY2ColorColor0xffffffffSkipfirst 
							" gui.line(int x1, int y1, int x2, int y2, [color color = 0xffffffff], [skipfirst])
							$LF
						]a
					]li
					[li 
						[a href=#GuiBoxIntX1IntY1IntX2IntY2ColorFillcolorColorOutlinecolor0xffffffff 
							" gui.box(int x1, int y1, int x2, int y2, 
							"[color fillcolor, [color outlinecolor = 0xffffffff]]
							")
							$LF
						]a
					]li
					[li 
						[a href=#StringGuiGdscreenshot 
							" string gui.gdscreenshot()
							$LF
						]a
					]li
					[li 
						[a href=#GuiOpacityFloatAlpha 
							" gui.opacity(float alpha)
							$LF
						]a
					]li
					[li 
						[a href=#GuiTransparencyFloatStrength 
							" gui.transparency(float strength)
							$LF
						]a
					]li
					[li 
						[a href=#GuiTextIntXIntYStringMsgColorFillcolor0xffffffffColorOutlinecolor0x000000ff 
							" gui.text(int x, int y, string msg, 
							"[color fillcolor = 0xffffffff]
							", 
							"[color outlinecolor = 0x000000ff]
							")
							$LF
						]a
					]li
					[li 
						[a href=#GuiGetpixelIntXIntY 
							" gui.getpixel(int x, int y)
							$LF
						]a
					]li
					[li 
						[a href=#GuiParsecolorColorColor 
							" gui.parsecolor(color color)
							$LF
						]a
					]li
					[li 
						[a href=#GuiGdoverlayIntDx0IntDy0StringStrSx0Sy0SwShFloatAlphamul10 
							" gui.gdoverlay(
							"[int dx# 0, int dy=0,]
							" string str 
							"[, sx=0, sy=0, sw, sh]
							" 
							"[, float alphamul1.0]
							")
							$LF
						]a
					]li
					[li 
						[a href=#StringGuiPopupMsgStringTypeStringIcon 
							" string gui.popup (msg 
							"[, string type [, string icon]]
							")
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Input 
					" input
					$LF
				]a
				[ul 
					[li 
						[a href=#StringInputPopupMsgStringTypeStringIcon 
							" string input.popup(msg 
							"[, string type [, string icon]]
							")
							$LF
						]a
					]li
					[li 
						[a href=#TableInputGet 
							" table input.get()
							$LF
						]a
					]li
				]ul
			]li
		]ul
	]div
]div
[hr 
]hr
[h2 id=Global 
	" Global
	$LF
]h2
[h3 id=Print 
	" print
	$LF
]h3
[div class=p 
	"Prints any value or values, mainly to help you debug your script. Unlike the default implementation, this can even print the contents of tables. Also, the printed values will go to the script's output window instead of stdout. Note that if you want to print a memory address you should use print(string.format("0x%X",address)) instead of print(address).
	$LF
]div
[h3 id=Tostring 
	" tostring
	$LF
]h3
[div class=p 
	"Returns a string that represents the argument. You can use this if you want to get the same string that print would print, but use it for some purpose other than immediate printing. This function is actually what gives print its ability to print tables and other non-string values. Note that there is currently a limit of 65536 characters per result, after which only a "..." is appended, but in typical use you shouldn't ever run into this limit.
	$LF
]div
[h3 id=Addressof 
	" addressof
	$LF
]h3
[div class=p 
	"Returns the pointer address of a reference-type value. In particular, this can be used on tables and functions to see what their addresses are. There's not much worth doing with a pointer address besides printing it to look at it and see that it's different from the address of something else. Please do not store the address to use for hashing or logical comparison, that is completely unnecessary in Lua because you can simply use the actual object instead of its address for those purposes. If the argument is not a reference type then this function will return 0.
	$LF
]div
[h3 id=Copytable 
	" copytable
	$LF
]h3
[div class=p 
	"Returns a shallow copy of the given table. In other words, it gives you a different table that contains all of the same values as the original. This is unlike simple assignment of a table, which only copies a reference to the original table. You could write a Lua function that does what this function does, but it's such a common operation that it seems worth having a pre-defined function available to do it.
	$LF
]div
[h3 id=AndOrXorShiftBit 
	" AND,OR,XOR,SHIFT,BIT
	$LF
]h3
[div class=p 
	"Old bit operation functions, use 
	[a href=http://bitop.luajit.org/ rel=noopener external nofollow 
		"bit.*
	]a
	" functions instead.
	$LF
]div
[hr 
]hr
[h2 id=Emu 
	" emu
	$LF
]h2
[h3 id=EmuSpeedmodeStringMode 
	" emu.speedmode(string mode)
	$LF
]h3
[div class=p 
	"Changes the speed of emulation depending on mode. If "normal", emulator runs at normal speed. If "nothrottle", emulator runs at max speed without frameskip. If "turbo", emulator drops some frames. If "maximum", screen rendering is disabled.
	$LF
]div
[h3 id=EmuFrameadvance 
	" emu.frameadvance()
	$LF
]h3
[div class=p 
	"Pauses script until a frame is emulated. Cannot be called by a coroutine or registered function.
	$LF
]div
[h3 id=EmuPause 
	" emu.pause()
	$LF
]h3
[div class=p 
	"Pauses emulator when the current frame has finished emulating.
	$LF
]div
[h3 id=IntEmuFramecount 
	" int emu.framecount()
	$LF
]h3
[div class=p 
	"Returns the frame count for the movie, or the number of frames from last reset otherwise.
	$LF
]div
[h3 id=IntEmuLagcount 
	" int emu.lagcount()
	$LF
]h3
[div class=p 
	"Returns the lag count.
	$LF
]div
[h3 id=BooleanEmuLagged 
	" boolean emu.lagged()
	$LF
]h3
[div class=p 
	"Returns true if the last frame was a lag frame, false otherwise.
	$LF
]div
[h3 id=BooleanEmuEmulating 
	" boolean emu.emulating()
	$LF
]h3
[div class=p 
	"Returns true if emulation has started, or false otherwise.
	$LF
]div
[h3 id=EmuRegisterbeforeFunctionFunc 
	" emu.registerbefore(function func)
	$LF
]h3
[div class=p 
	"Registers a callback function to run immediately before each frame gets emulated. This runs after the next frame's input is known but before it's used, so this is your only chance to set the next frame's input using the next frame's would-be input. For example, if you want to make a script that filters or modifies ongoing user input, such as making the game think "left" is pressed whenever you press "right", you can do it easily with this.
	$LF
]div
[div class=p 
	"Note that this is not quite the same as code that's placed before a call to emu.frameadvance. This callback runs a little later than that. Also, you cannot safely assume that this will only be called once per frame. Depending on the emulator's options, every frame may be simulated multiple times and your callback will be called once per simulation. If for some reason you need to use this callback to keep track of a stateful linear progression of things across frames then you may need to key your calculations to the results of emu.framecount.
	$LF
]div
[div class=p 
	"Like other callback-registering functions provided by Snes9x, there is only one registered callback at a time per registering function per script. If you register two callbacks, the second one will replace the first, and the call to emu.registerbefore will return the old callback. You may register nil instead of a function to clear a previously-registered callback. If a script returns while it still has registered callbacks, Snes9x will keep it alive to call those callbacks when appropriate, until either the script is stopped by the user or all of the callbacks are de-registered.
	$LF
]div
[h3 id=EmuRegisterafterFunctionFunc 
	" emu.registerafter(function func)
	$LF
]h3
[div class=p 
	"Registers a callback function to run immediately after each frame gets emulated. It runs at a similar time as (and slightly before) gui.register callbacks, except unlike with gui.register it doesn't also get called again whenever the screen gets redrawn. Similar caveats as those mentioned in emu.registerbefore apply.
	$LF
]div
[h3 id=EmuRegisterexitFunctionFunc 
	" emu.registerexit(function func)
	$LF
]h3
[div class=p 
	"Registers a callback function that runs when the script stops. Whether the script stops on its own or the user tells it to stop, or even if the script crashes or the user tries to close the emulator, Snes9x will try to run whatever Lua code you put in here first. So if you want to make sure some code runs that cleans up some external resources or saves your progress to a file or just says some last words, you could put it here. (Of course, a forceful termination of the application or a crash from inside the registered exit function will still prevent the code from running.)
	$LF
]div
[div class=p 
	"Suppose you write a script that registers an exit function and then enters an infinite loop. If the user clicks "Stop" your script will be forcefully stopped, but then it will start running its exit function. If your exit function enters an infinite loop too, then the user will have to click "Stop" a second time to really stop your script. That would be annoying. So try to avoid doing too much inside the exit function.
	$LF
]div
[div class=p 
	"Note that restarting a script counts as stopping it and then starting it again, so doing so (either by clicking "Restart" or by editing the script while it is running) will trigger the callback. Note also that returning from a script generally does NOT count as stopping (because your script is still running or waiting to run its callback functions and thus does not stop... see here for more information), even if the exit callback is the only one you have registered.
	$LF
]div
[h3 id=EmuMessageStringMsg 
	" emu.message(string msg)
	$LF
]h3
[div class=p 
	"Displays the message on the screen.
	$LF
]div
[hr 
]hr
[h2 id=Memory 
	" memory
	$LF
]h2
[h3 id=IntMemoryReadbyteIntAddr 
	" int memory.readbyte(int addr)
	$LF
]h3
[h3 id=IntMemoryReadbytesignedIntAddr 
	" int memory.readbytesigned(int addr)
	$LF
]h3
[h3 id=IntMemoryReadwordIntAddr 
	" int memory.readword(int addr)
	$LF
]h3
[h3 id=IntMemoryReadwordsignedIntAddr 
	" int memory.readwordsigned(int addr)
	$LF
]h3
[h3 id=IntMemoryReaddwordIntAddr 
	" int memory.readdword(int addr)
	$LF
]h3
[h3 id=IntMemoryReaddwordsignedIntAddr 
	" int memory.readdwordsigned(int addr)
	$LF
]h3
[div class=p 
	"Reads value from memory address. RAM addresses are 0x7e0000-0x7fffff. Word = 2 bytes, Dword = 4 bytes.
	$LF
]div
[div class=p 
	"Note: Do not access to chip registers, or you might experience a desync.
	$LF
]div
[h3 id=StringMemoryReadbyterangeIntStartaddrIntLength 
	" string memory.readbyterange(int startaddr, int length)
	$LF
]h3
[div class=p 
	"Returns a chunk of memory from the given address with the given length as a string. To access, use _string.byte(str,offset)_.
	$LF
]div
[h3 id=MemoryWritebyteIntAddrIntValue 
	" memory.writebyte(int addr, int value)
	$LF
]h3
[h3 id=MemoryWritewordIntAddrIntValue 
	" memory.writeword(int addr, int value)
	$LF
]h3
[h3 id=MemoryWritedwordIntAddrIntValue 
	" memory.writedword(int addr, int value)
	$LF
]h3
[div class=p 
	"Writes value to memory address. RAM addresses are 0x7e0000-0x7fffff.
	$LF
]div
[h3 id=MemoryGetregisterStringCpuregistername 
	" memory.getregister(string cpuregistername)
	$LF
]h3
[div class=p 
	"Returns the current value of the given hardware register.
	$LF
	"For example, memory.getregister("pc") will return the main CPU's current Program Counter.
	$LF
]div
[div class=p 
	"Valid registers are: "db", "p", "e", "a", "d", "s", "x", "y", "pb", "pc", and "pbpc".
	$LF
]div
[div class=p 
	"You can prefix the string with "sa1." to retrieve registers from SA1 instead of the 65C816, or you can explicitly use "main." or "65c816." if you want. For example, memory.getregister("sa1.a") will return the value stored in the SA1's A Register.
	$LF
]div
[h3 id=MemorySetregisterStringCpuregisternameIntValue 
	" memory.setregister(string cpuregistername, int value)
	$LF
]h3
[div class=p 
	"Sets the current value of the given hardware register.
	$LF
	"For example, memory.setregister("pc",0x200) will change the main CPU's current Program Counter to 0x200.
	$LF
]div
[div class=p 
	"Valid registers are: "db", "p", "e", "a", "d", "s", "x", "y", "pb", "pc", and "pbpc".
	$LF
]div
[div class=p 
	"You can prefix the string with "sa1." to set registers on SA1 instead of the 65C816, or you can explicitly use "main." or "65c816." if you want.
	$LF
]div
[div class=p 
	"You had better know exactly what you're doing or you're probably just going to crash the game if you try to use this function. That applies to the other memory.write functions as well, but to a lesser extent.
	$LF
]div
[h3 id=MemoryRegisterwriteIntAddrIntSizeStringCpunameFunc 
	" memory.registerwrite (int addr, [int size,] [string cpuname,] func)
	$LF
]h3
[div class=p 
	"Calls the function whenever the given address is written to. Function can be nil.
	$LF
]div
[h3 id=MemoryRegisterreadIntAddrIntSizeStringCpunameFunc 
	" memory.registerread (int addr, [int size,] [string cpuname,] func)
	$LF
]h3
[div class=p 
	"Calls the function whenever the given address is read. Function can be nil.
	$LF
]div
[h3 id=MemoryRegisterexecIntAddrIntSizeStringCpunameFunc 
	" memory.registerexec (int addr, [int size,] [string cpuname,] func)
	$LF
]h3
[div class=p 
	"Calls the function whenever the given address is executed. Function can be nil.
	$LF
]div
[hr 
]hr
[h2 id=Apu 
	" apu
	$LF
]h2
[div class=p 
	"It's not very useful for TASing, but it might be useful for automatic SPC dumping.
	$LF
]div
[h3 id=ApuReadbyteIntAddr 
	" apu.readbyte(int addr)
	$LF
]h3
[h3 id=ApuReadbytesignedIntAddr 
	" apu.readbytesigned(int addr)
	$LF
]h3
[h3 id=ApuReadwordIntAddr 
	" apu.readword(int addr)
	$LF
]h3
[h3 id=ApuReadwordsignedIntAddr 
	" apu.readwordsigned(int addr)
	$LF
]h3
[h3 id=ApuReaddwordIntAddr 
	" apu.readdword(int addr)
	$LF
]h3
[h3 id=ApuReaddwordsignedIntAddr 
	" apu.readdwordsigned(int addr)
	$LF
]h3
[h3 id=ApuReadbyterangeIntStartaddrIntLength 
	" apu.readbyterange(int startaddr, int length)
	$LF
]h3
[h3 id=ApuWritebyteIntAddrIntValue 
	" apu.writebyte(int addr, int value)
	$LF
]h3
[h3 id=ApuWritewordIntAddrIntValue 
	" apu.writeword(int addr, int value)
	$LF
]h3
[h3 id=ApuWritedwordIntAddrIntValue 
	" apu.writedword(int addr, int value)
	$LF
]h3
[div class=p 
	"Read/Write value from/to APU RAM. Besides that, most of the information about the same functions in the 
	[code 
		"memory
	]code
	" library applies to these functions as well. 
	$LF
]div
[h3 id=ApuWritespcStringFilenameBoolAutosearchFalse 
	" apu.writespc(string filename, [bool autosearch = false])
	$LF
]h3
[div class=p 
	"Dumps SPC to file.
	$LF
]div
[hr 
]hr
[h2 id=Joypad 
	" joypad
	$LF
]h2
[div class=p 
	"Before the next frame is emulated, one may set keys to be pressed. The buffer is cleared each frame.
	$LF
]div
[h3 id=TableJoypadGetIntPort 
	" table joypad.get(int port)
	$LF
]h3
[div class=p 
	"Returns a table of every game button, where each entry is true if that button is currently held (as of the last time the emulation checked), or false if it is not held. If a movie is playing, this will read the input actually being received from the movie instead of what the user is pressing. By default this only checks controller 1's input, but the optional whichcontroller argument lets you choose.
	$LF
]div
[div class=p 
	"Keys for joypad table: (R, L, X, A, right, left, down, up, start, select, Y, B). Keys are case-sensitive.
	$LF
]div
[h3 id=TableJoypadGetdownIntPort 
	" table joypad.getdown(int port)
	$LF
]h3
[div class=p 
	"Returns a table of only the game buttons that are currently held. Each entry is true if that button is currently held (as of the last time the emulation checked), or nil if it is not held. If a movie is playing, this will read the input actually being received from the movie instead of what the user is pressing. By default this only checks controller 1's input, but the optional whichcontroller argument lets you choose.
	$LF
]div
[div class=p 
	"Keys for joypad table: (R, L, X, A, right, left, down, up, start, select, Y, B). Keys are case-sensitive.
	$LF
]div
[h3 id=TableJoypadGetupIntPort 
	" table joypad.getup(int port)
	$LF
]h3
[div class=p 
	"Returns a table of only the game buttons that are not currently held. Each entry is nil if that button is currently held (as of the last time the emulation checked), or false if it is not held. If a movie is playing, this will read the input actually being received from the movie instead of what the user is pressing. By default this only checks controller 1's input, but the optional whichcontroller argument lets you choose.
	$LF
]div
[div class=p 
	"Keys for joypad table: (R, L, X, A, right, left, down, up, start, select, Y, B). Keys are case-sensitive.
	$LF
]div
[h3 id=JoypadSetIntPortTableButtons 
	" joypad.set(int port, table buttons)
	$LF
]h3
[div class=p 
	"Sets the buttons to be pressed next frame. true for pressed, nil or false for not pressed.
	$LF
]div
[hr 
]hr
[h2 id=Savestate 
	" savestate
	$LF
]h2
[h3 id=ObjectSavestateCreateIntSlotNil 
	" object savestate.create(int slot=nil)
	$LF
]h3
[div class=p 
	"Creates a savestate object. If any argument is given, it must be from 1 to 12, and it corresponds with the numbered savestate slots. If no argument is given, the savestate can only be accessed by Lua.
	$LF
]div
[h3 id=SavestateSaveObjectSavestate 
	" savestate.save(object savestate)
	$LF
]h3
[div class=p 
	"Saves the current state to the savestate object.
	$LF
]div
[h3 id=SavestateLoadObjectSavestate 
	" savestate.load(object savestate)
	$LF
]h3
[div class=p 
	"Loads the state of the savestate object as the current state.
	$LF
]div
[h3 id=FunctionSavestateRegistersaveFunctionFunc 
	" function savestate.registersave(function func)
	$LF
]h3
[div class=p 
	"Registers a function to be called when a state is saved. Function can be nil. The previous function is returned, possibly nil. The function is allowed to return values.
	$LF
]div
[h3 id=FunctionSavestateRegisterloadFunctionFunc 
	" function savestate.registerload(function func)
	$LF
]h3
[div class=p 
	"Registers a function to be called when a state is loaded. Function can be nil. The previous function is returned, possibly nil. The function is passed parameters, if any, returned from a function registered from registersave.
	$LF
]div
[h3 id=SavestateLoadscriptdataLocation 
	" savestate.loadscriptdata(location)
	$LF
]h3
[div class=p 
	"Returns the data associated with the given savestate (data that was earlier returned by a registered save callback) without actually loading the rest of that savestate or calling any callbacks. location should be a save slot number. 
	$LF
]div
[hr 
]hr
[h2 id=Movie 
	" movie
	$LF
]h2
[h3 id=BooleanMovieActive 
	" boolean movie.active()
	$LF
]h3
[div class=p 
	"Returns true if any movie file is open, or false otherwise.
	$LF
]div
[h3 id=BooleanMovieRecording 
	" boolean movie.recording()
	$LF
]h3
[div class=p 
	"Returns true if a movie file is currently recording, or false otherwise.
	$LF
]div
[h3 id=BooleanMoviePlaying 
	" boolean movie.playing()
	$LF
]h3
[div class=p 
	"Returns true if a movie file is currently playing, or false otherwise. 
	$LF
]div
[h3 id=StringMovieMode 
	" string movie.mode()
	$LF
]h3
[div class=p 
	"Returns "record" if movie is recording, "playback" if movie is replaying input, or nil if there is no movie.
	$LF
]div
[h3 id=IntMovieLength 
	" int movie.length()
	$LF
]h3
[div class=p 
	"Returns the total number of frames in the current movie.
	$LF
]div
[h3 id=StringMovieName 
	" string movie.name()
	$LF
]h3
[div class=p 
	"Returns a string containing the full filename (path) of the current movie file.
	$LF
]div
[h3 id=IntMovieRerecordcount 
	" int movie.rerecordcount()
	$LF
]h3
[div class=p 
	"Returns the count of re-records that is stored in the current movie file.
	$LF
]div
[h3 id=MovieSetrerecordcountIntNumber 
	" movie.setrerecordcount(int number)
	$LF
]h3
[div class=p 
	"Sets the re-record count of the current movie file to the given number.
	$LF
]div
[h3 id=MovieRerecordcountingBooleanSkipcounting 
	" movie.rerecordcounting(boolean skipcounting)
	$LF
]h3
[div class=p 
	"If set to true, no rerecords done by Lua are counted in the rerecord total. If set to false, rerecords done by Lua count. By default, rerecords count.
	$LF
]div
[h3 id=MovieStop 
	" movie.stop()
	$LF
]h3
[div class=p 
	"Stops the movie. Cannot be used if there is no movie.
	$LF
]div
[hr 
]hr
[h2 id=Gui 
	" gui
	$LF
]h2
[div class=p 
	"All functions assume that the height of the image is 256 and the width is 239.
	$LF
]div
[div class=p 
	"Color can be given as "0xrrggbbaa" or as a name (e.g. "red").
	$LF
]div
[h3 id=FunctionGuiRegisterFunctionFunc 
	" function gui.register(function func)
	$LF
]h3
[div class=p 
	"Registers a function to be called when the screen is updated. Function can be nil. The previous function is returned, possibly nil.
	$LF
]div
[div class=p 
	"All drawing process should be done in the callback of this function.
	$LF
]div
[h3 id=GuiPixelIntXIntYColorColor0xffffffff 
	" gui.pixel(int x, int y, [color color = 0xffffffff])
	$LF
]h3
[div class=p 
	"Draws a pixel at (x,y) with the given color.
	$LF
]div
[h3 id=GuiLineIntX1IntY1IntX2IntY2ColorColor0xffffffffSkipfirst 
	" gui.line(int x1, int y1, int x2, int y2, [color color = 0xffffffff], [skipfirst])
	$LF
]h3
[div class=p 
	"Draws a line from (x1,y1) to (x2,y2) with the given color.
	$LF
]div
[h3 id=GuiBoxIntX1IntY1IntX2IntY2ColorFillcolorColorOutlinecolor0xffffffff 
	" gui.box(int x1, int y1, int x2, int y2, 
	"[color fillcolor, [color outlinecolor = 0xffffffff]]
	")
	$LF
]h3
[div class=p 
	"Draws a box with (x1,y1) and (x2,y2) as opposite corners with the given color.
	$LF
]div
[h3 id=StringGuiGdscreenshot 
	" string gui.gdscreenshot()
	$LF
]h3
[div class=p 
	"Takes a screenshot and returns it as a string that can be used by the 
	[a href=https://www.ittner.com.br/lua-gd/ rel=noopener external nofollow 
		"GD library
	]a
	".
	$LF
]div
[div class=p 
	"For direct access, use 
	[code 
		"string.byte(str,offset)
	]code
	". The gd image consists of a 11-byte header and each pixel is alpha,red,green,blue (1 byte each, alpha is 0 in this case) left to right then top to bottom.
	$LF
]div
[h3 id=GuiOpacityFloatAlpha 
	" gui.opacity(float alpha)
	$LF
]h3
[div class=p 
	"Sets the opacity of drawings depending on alpha. 0.0 is invisible, 1.0 is drawn over. Values less than 0.0 or greater than 1.0 work by extrapolation.
	$LF
]div
[h3 id=GuiTransparencyFloatStrength 
	" gui.transparency(float strength)
	$LF
]h3
[div class=p 
	"4.0 is invisible, 0.0 is drawn over. Values less than 0.0 or greater than 4.0 work by extrapolation.
	$LF
]div
[h3 id=GuiTextIntXIntYStringMsgColorFillcolor0xffffffffColorOutlinecolor0x000000ff 
	" gui.text(int x, int y, string msg, 
	"[color fillcolor = 0xffffffff]
	", 
	"[color outlinecolor = 0x000000ff]
	")
	$LF
]h3
[div class=p 
	"Draws the given text at (x,y) with the given color. Not to be confused with 
	[code 
		"emu.message(string msg)
	]code
	".
	$LF
]div
[h3 id=GuiGetpixelIntXIntY 
	" gui.getpixel(int x, int y)
	$LF
]h3
[div class=p 
	"Returns the RGB color at the given onscreen pixel location. You can say 
	[code 
		"local r,g,b = gui.getpixel(x,y)
	]code
	". r,g,b are the red/green/blue color components of that pixel, each ranging from 0 to 255. If the coordinate you give is offscreen, you will receive the color values of the nearest onscreen pixel instead.
	$LF
]div
[div class=p 
	"Note that this function can return colors that have already been written to the screen by 
	[code 
		"GUI
	]code
	" drawing functions. If for some reason you want to make sure that you only get the clean untampered-with colors the emulation drew onscreen, then you'll have to call this function before any 
	[code 
		"GUI
	]code
	" drawing functions have written to the screen for the current frame. Probably the most reliable way to do that is to call 
	[code 
		"gui.getpixel
	]code
	" inside of a callback function that you register with emu.registerafter.
	$LF
]div
[h3 id=GuiParsecolorColorColor 
	" gui.parsecolor(color color)
	$LF
]h3
[div class=p 
	"Returns the separate RGBA components of the given color.
	$LF
]div
[div class=p 
	"For example, you can say local 
	[code 
		"r,g,b,a = gui.parsecolor('orange')
	]code
	" to retrieve the red/green/blue values of the preset color orange. (You could also omit the a in cases like this.) This uses the same conversion method that Gens uses internally to support the different representations of colors that the 
	[code 
		"GUI
	]code
	" library uses. Overriding this function will not change how Gens interprets color values, however. 
	$LF
]div
[h3 id=GuiGdoverlayIntDx0IntDy0StringStrSx0Sy0SwShFloatAlphamul10 
	" gui.gdoverlay(
	"[int dx# 0, int dy=0,]
	" string str 
	"[, sx=0, sy=0, sw, sh]
	" 
	"[, float alphamul1.0]
	")
	$LF
]h3
[div class=p 
	"Overlays the given gd image with top-left corner at (dx,dy) and given opacity.
	$LF
]div
[h3 id=StringGuiPopupMsgStringTypeStringIcon 
	" string gui.popup (msg 
	"[, string type [, string icon]]
	")
	$LF
]h3
[div class=p 
	"Brings up a modal popup dialog box (everything stops until the user dismisses it). The box displays the message tostring(msg). This function returns the name of the button the user clicked on (as a string).
	$LF
]div
[div class=p 
	"type determines which buttons are on the dialog box, and it can be one of the following: 'ok', 'yesno', 'yesnocancel', 'okcancel', 'abortretryignore'.
	$LF
	"type defaults to 'ok' for gui.popup, or to 'yesno' for input.popup.
	$LF
]div
[div class=p 
	"icon indicates the purpose of the dialog box (or more specifically it dictates which title and icon is displayed in the box), and it can be one of the following: 'message', 'question', 'warning', 'error'.
	$LF
	"icon defaults to 'message' for gui.popup, or to 'question' for input.popup.
	$LF
]div
[div class=p 
	"Try to avoid using this function much if at all, because modal dialog boxes can be irritating.
	$LF
]div
[hr 
]hr
[h2 id=Input 
	" input
	$LF
]h2
[h3 id=StringInputPopupMsgStringTypeStringIcon 
	" string input.popup(msg 
	"[, string type [, string icon]]
	")
	$LF
]h3
[div class=p 
	"See 
	[code 
		"gui.popup
	]code
	$LF
]div
[h3 id=TableInputGet 
	" table input.get()
	$LF
]h3
[div class=p 
	"Returns a table of which keyboard buttons are pressed as well as mouse status. (note: this is not related to the SNES mouse peripheral, it's simply your PC mouse cursor.) Key values for keyboard buttons and mouse clicks are true for pressed, nil for not pressed. Mouse position is returned in terms of game screen pixel coordinates. Coordinates assume that the game screen is 256 by 224. Keys for mouse are (xmouse, ymouse, leftclick, rightclick, middleclick). Keys for keyboard buttons:
	$LF
	"(backspace, tab, enter, shift, control, alt, pause, capslock, escape, space, pageup, pagedown, end, home, left, up, right, down, insert, delete,
	$LF
	"0, 1, ..., 9, A, B, ..., Z, numpad0, numpad1, ..., numpad9, numpad*, numpad+, numpad-, numpad., numpad/, F1, F2, ..., F24,
	$LF
	"numlock, scrolllock, semicolon, plus, comma, minus, period, slash, tilde, leftbracket, backslash, rightbracket, quote)
	$LF
]div
[div class=p 
	"Keys are case-sensitive. Keys for keyboard buttons are for buttons, *not* ASCII characters, so there is no need to hold down shift. Key names may differ depending on keyboard layout. On US keyboard layouts, "slash" is /?, "tilde" is ```~, "leftbracket" is `
	"[``{`, "backslash" is \|, "rightbracket" is `]
	"``}`, "quote" is '".
]div
