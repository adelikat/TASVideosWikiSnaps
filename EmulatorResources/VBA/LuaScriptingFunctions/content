2
[div class=card mb-2 
	[div class=card-header 
		[strong 
			"Table of contents
		]strong
	]div
	[div class=card-body 
		[ul 
			[li 
				[a href=#LuaSyntax 
					" Lua Syntax
					$LF
				]a
				[ul 
					[li 
						[ul 
							[li 
								[a href=#SeeAlso 
									" See also
									$LF
								]a
							]li
							[li 
								[a href=#Important 
									" Important
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#EmuVba 
							" emu/vba
							$LF
						]a
						[ul 
							[li 
								[a href=#VbaFrameadvance 
									" vba.frameadvance()
									$LF
								]a
							]li
							[li 
								[a href=#VbaPause 
									" vba.pause()
									$LF
								]a
							]li
							[li 
								[a href=#IntVbaFramecount 
									" int vba.framecount()
									$LF
								]a
							]li
							[li 
								[a href=#IntVbaLagcount 
									" int vba.lagcount()
									$LF
								]a
							]li
							[li 
								[a href=#BooleanVbaLagged 
									" boolean vba.lagged()
									$LF
								]a
							]li
							[li 
								[a href=#BooleanVbaEmulating 
									" boolean vba.emulating()
									$LF
								]a
							]li
							[li 
								[a href=#VbaRegisterbeforeFunction 
									" vba.registerbefore(function)
									$LF
								]a
							]li
							[li 
								[a href=#VbaRegisterafterFunction 
									" vba.registerafter(function)
									$LF
								]a
							]li
							[li 
								[a href=#VbaRegisterexitFunction 
									" vba.registerexit(function)
									$LF
								]a
							]li
							[li 
								[a href=#VbaMessageString 
									" vba.message(string)
									$LF
								]a
							]li
							[li 
								[a href=#VbaPrintString 
									" vba.print(string)
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#Memory 
							" memory
							$LF
						]a
						[ul 
							[li 
								[a href=#IntMemoryReadbyteIntReadbyteunsigned 
									" int memory.readbyte(int) / readbyteunsigned
									$LF
								]a
							]li
							[li 
								[a href=#IntMemoryReadwordIntReadwordunsignedReadshortReadshortunsigned 
									" int memory.readword(int) / readwordunsigned / readshort / readshortunsigned
									$LF
								]a
							]li
							[li 
								[a href=#IntMemoryReaddwordIntReaddwordunsignedReadlongReadlongunsigned 
									" int memory.readdword(int) / readdwordunsigned / readlong / readlongunsigned
									$LF
								]a
							]li
							[li 
								[a href=#IntMemoryReadbytesignedInt 
									" int memory.readbytesigned(int)
									$LF
								]a
							]li
							[li 
								[a href=#IntMemoryReadwordsignedIntReadshortsigned 
									" int memory.readwordsigned(int) / readshortsigned
									$LF
								]a
							]li
							[li 
								[a href=#IntMemoryReaddwordsignedIntReadlongsigned 
									" int memory.readdwordsigned(int) / readlongsigned
									$LF
								]a
							]li
							[li 
								[a href=#StringMemoryReadbyterangeIntAddrIntLength 
									" string memory.readbyterange(int addr, int length)
									$LF
								]a
							]li
							[li 
								[a href=#MemoryWritebyteIntAddrIntVal 
									" memory.writebyte(int addr, int val)
									$LF
								]a
							]li
							[li 
								[a href=#MemoryWritewordIntAddrIntValWriteshort 
									" memory.writeword(int addr, int val) / writeshort
									$LF
								]a
							]li
							[li 
								[a href=#MemoryWritedwordIntAddrIntValWritelong 
									" memory.writedword(int addr, int val) / writelong
									$LF
								]a
							]li
							[li 
								[a href=#IntMemoryGetregisterString 
									" int memory.getregister(string)
									$LF
								]a
							]li
							[li 
								[a href=#MemorySetregisterStringInt 
									" memory.setregister(string, int)
									$LF
								]a
							]li
							[li 
								[a href=#MemoryRegisterwriteIntAddrFunctionFuncRegister 
									" memory.registerwrite(int addr, function func) / register
									$LF
								]a
							]li
							[li 
								[a href=#MemoryRegisterexecIntAddrFunctionFuncRegisterrunRegisterexecute 
									" memory.registerexec(int addr, function func) / registerrun / registerexecute
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#Joypad 
							" joypad
							$LF
						]a
						[ul 
							[li 
								[a href=#TableJoypadGetIntPortRead 
									" table joypad.get(int port) / read
									$LF
								]a
							]li
							[li 
								[a href=#TableJoypadGetdownIntPortReaddown 
									" table joypad.getdown(int port) / readdown
									$LF
								]a
							]li
							[li 
								[a href=#TableJoypadGetupIntPortReadup 
									" table joypad.getup(int port) / readup
									$LF
								]a
							]li
							[li 
								[a href=#JoypadSetIntPortTableButtonsWrite 
									" joypad.set(int port, table buttons) / write
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#Savestate 
							" savestate
							$LF
						]a
						[ul 
							[li 
								[a href=#ObjectSavestateCreateIntSlotNil 
									" object savestate.create(int slot=nil)
									$LF
								]a
							]li
							[li 
								[a href=#SavestateSaveObjectSavestate 
									"savestate.save(object savestate)
									$LF
								]a
							]li
							[li 
								[a href=#SavestateLoadObjectSavestate 
									"savestate.load(object savestate)
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#Movie 
							" movie
							$LF
						]a
						[ul 
							[li 
								[a href=#BooleanMovieActive 
									" boolean movie.active()
									$LF
								]a
							]li
							[li 
								[a href=#BooleanMovieRecording 
									" boolean movie.recording()
									$LF
								]a
							]li
							[li 
								[a href=#BooleanMoviePlaying 
									" boolean movie.playing()
									$LF
								]a
							]li
							[li 
								[a href=#StringMovieMode 
									" string movie.mode()
									$LF
								]a
							]li
							[li 
								[a href=#IntMovieLength 
									" int movie.length()
									$LF
								]a
							]li
							[li 
								[a href=#StringMovieAuthorGetauthor 
									" string movie.author() / getauthor
									$LF
								]a
							]li
							[li 
								[a href=#StringMovieNameGetname 
									" string movie.name() / getname
									$LF
								]a
							]li
							[li 
								[a href=#IntMovieRerecordcount 
									" int movie.rerecordcount()
									$LF
								]a
							]li
							[li 
								[a href=#MovieSetrerecordcountInt 
									" movie.setrerecordcount(int)
									$LF
								]a
							]li
							[li 
								[a href=#MovieRerecordcountingBoolean 
									" movie.rerecordcounting(boolean)
									$LF
								]a
							]li
							[li 
								[a href=#MovieStopClose 
									" movie.stop() / close
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#Gui 
							" gui
							$LF
						]a
						[ul 
							[li 
								[a href=#FunctionGuiRegisterFunctionFunc 
									" function gui.register(function func)
									$LF
								]a
							]li
							[li 
								[a href=#GuiTextIntXIntYStringMsgTypeFillcolorTypeBordercolorDrawtext 
									" gui.text(int x, int y, string msg, type fillcolor, type bordercolor) / drawtext
									$LF
								]a
							]li
							[li 
								[a href=#GuiBoxIntX1IntY1IntX2IntY2TypeFillcolorTypeBordercolorDrawboxRectDrawrect 
									" gui.box(int x1, int y1, int x2, int y2, type fillcolor, type bordercolor) / drawbox / rect / drawrect
									$LF
								]a
							]li
							[li 
								[a href=#GuiLineIntX1IntY1IntX2IntY2TypeColorBooleanSkipfirstDrawline 
									" gui.line(int x1, int y1, int x2, int y2, type color, boolean skipfirst) / drawline
									$LF
								]a
							]li
							[li 
								[a href=#GuiPixelIntXIntYTypeColorDrawpixelSetpixelWritepixel 
									" gui.pixel(int x, int y, type color) / drawpixel / setpixel / writepixel
									$LF
								]a
							]li
							[li 
								[a href=#GuiOpacityFloatAlpha 
									" gui.opacity(float alpha)
									$LF
								]a
							]li
							[li 
								[a href=#GuiTransparencyFloatStrength 
									" gui.transparency(float strength)
									$LF
								]a
							]li
							[li 
								[a href=#StringGuiPopupStringMsgStringTypeOk 
									" string gui.popup(string msg, string type = "ok")
									$LF
								]a
							]li
							[li 
								[a href=#IntIntIntIntGuiParsecolorTypeColour 
									" int int int int gui.parsecolor(type colour)
									$LF
								]a
							]li
							[li 
								[a href=#StringGuiGdscreenshot 
									" string gui.gdscreenshot()
									$LF
								]a
							]li
							[li 
								[a href=#GuiGdoverlayIntDestx0IntDesty0StringGdimageSrcxIntSrcyIntWidthIntHeightFloatAlpha10DrawimageImage 
									" gui.gdoverlay(int destX=0, int destY=0, string gdimage, srcX, int srcY, int width, int height, float alpha=1.0) / drawimage / image
									$LF
								]a
							]li
							[li 
								[a href=#IntIntIntGuiGetpixelIntXIntYReadpixel 
									" int int int gui.getpixel(int x, int y) / readpixel
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#Input 
							" input
							$LF
						]a
						[ul 
							[li 
								[a href=#TableInputGetRead 
									" table input.get() / read
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#Bit 
							" bit
							$LF
						]a
					]li
					[li 
						[a href=#Avi 
							" avi
							$LF
						]a
						[ul 
							[li 
								[a href=#IntAviFramcount 
									" int avi.framcount()
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#Other 
							" other
							$LF
						]a
						[ul 
							[li 
								[a href=#PrintString 
									" print(string)
									$LF
								]a
							]li
							[li 
								[a href=#StringTostringType 
									" string tostring(type)
									$LF
								]a
							]li
							[li 
								[a href=#IntAddressofPointer 
									" int addressof(pointer)
									$LF
								]a
							]li
							[li 
								[a href=#TableCopytableTable 
									" table copytable(table)
									$LF
								]a
							]li
							[li 
								[a href=#IntAndInt 
									" int AND(int, ...)
									$LF
								]a
							]li
							[li 
								[a href=#IntOrInt 
									" int OR(int, ...)
									$LF
								]a
							]li
							[li 
								[a href=#IntXorInt 
									" int XOR(int, ...)
									$LF
								]a
							]li
							[li 
								[a href=#IntShiftIntInt 
									" int SHIFT(int, int)
									$LF
								]a
							]li
							[li 
								[a href=#IntBitInt 
									" int BIT(int, ...)
									$LF
								]a
							]li
						]ul
					]li
				]ul
			]li
		]ul
	]div
]div
[h2 id=LuaSyntax 
	" Lua Syntax
	$LF
]h2
[h4 id=SeeAlso 
	" See also
	$LF
]h4
[div class=p 
	"The 
	[a href=http://www.lua.org/manual/5.1/ rel=noopener external nofollow 
		"Lua manual
	]a
	".
	$LF
]div
[h4 id=Important 
	" Important
	$LF
]h4
[div class=p 
	"nil is not 0. nil and 0 are two different entities.
	$LF
]div
[h3 id=EmuVba 
	" emu/vba
	$LF
]h3
[h4 id=VbaFrameadvance 
	" vba.frameadvance()
	$LF
]h4
[div class=p 
	"Pauses script until the current frame has been emulated. Cannot be called by a coroutine or registered function.
	$LF
]div
[h4 id=VbaPause 
	" vba.pause()
	$LF
]h4
[div class=p 
	"Pauses emulator when the current frame has finished emulating.
	$LF
]div
[h4 id=IntVbaFramecount 
	" int vba.framecount()
	$LF
]h4
[div class=p 
	"Returns the frame count for the movie, or the number of frames from last reset otherwise.
	$LF
]div
[h4 id=IntVbaLagcount 
	" int vba.lagcount()
	$LF
]h4
[div class=p 
	"Returns the lag count.
	$LF
]div
[h4 id=BooleanVbaLagged 
	" boolean vba.lagged()
	$LF
]h4
[div class=p 
	"Returns true if the current frame is a lag frame, false otherwise.
	$LF
]div
[h4 id=BooleanVbaEmulating 
	" boolean vba.emulating()
	$LF
]h4
[div class=p 
	"Returns true if a ROM is being emulated (regardless of being paused).
	$LF
]div
[h4 id=VbaRegisterbeforeFunction 
	" vba.registerbefore(function)
	$LF
]h4
[div class=p 
	"The function passed will be executed just after the GBA input has updated at the start of the next frame.
	$LF
]div
[h4 id=VbaRegisterafterFunction 
	" vba.registerafter(function)
	$LF
]h4
[div class=p 
	"The function passed will be executed just after the frame has finished, but before any emulation of the next frame.
	$LF
]div
[h4 id=VbaRegisterexitFunction 
	" vba.registerexit(function)
	$LF
]h4
[div class=p 
	"The function passed will be executed when the Lua script has been ended.
	$LF
]div
[h4 id=VbaMessageString 
	" vba.message(string)
	$LF
]h4
[div class=p 
	"Displays the message on the screen.
	$LF
]div
[h4 id=VbaPrintString 
	" vba.print(string)
	$LF
]h4
[div class=p 
	"Prints the message to the Lua console.
	$LF
]div
[h3 id=Memory 
	" memory
	$LF
]h3
[h4 id=IntMemoryReadbyteIntReadbyteunsigned 
	" int memory.readbyte(int) / readbyteunsigned
	$LF
]h4
[h4 id=IntMemoryReadwordIntReadwordunsignedReadshortReadshortunsigned 
	" int memory.readword(int) / readwordunsigned / readshort / readshortunsigned
	$LF
]h4
[h4 id=IntMemoryReaddwordIntReaddwordunsignedReadlongReadlongunsigned 
	" int memory.readdword(int) / readdwordunsigned / readlong / readlongunsigned
	$LF
]h4
[h4 id=IntMemoryReadbytesignedInt 
	" int memory.readbytesigned(int)
	$LF
]h4
[h4 id=IntMemoryReadwordsignedIntReadshortsigned 
	" int memory.readwordsigned(int) / readshortsigned
	$LF
]h4
[h4 id=IntMemoryReaddwordsignedIntReadlongsigned 
	" int memory.readdwordsigned(int) / readlongsigned
	$LF
]h4
[div class=p 
	"Returns the value read from the passed memory address. GB addresses at 01:Cxxx are should be passed as Dxxx. Byte = 1 byte, word/short = 2 bytes, dword/long = 4 bytes.
	$LF
]div
[h4 id=StringMemoryReadbyterangeIntAddrIntLength 
	" string memory.readbyterange(int addr, int length)
	$LF
]h4
[div class=p 
	"Returns a string containing the chunk of memory from addr to addr+length. Length can be negative, data is still returned in ascending order. To access, use string.byte(str,offset).
	$LF
]div
[h4 id=MemoryWritebyteIntAddrIntVal 
	" memory.writebyte(int addr, int val)
	$LF
]h4
[h4 id=MemoryWritewordIntAddrIntValWriteshort 
	" memory.writeword(int addr, int val) / writeshort
	$LF
]h4
[h4 id=MemoryWritedwordIntAddrIntValWritelong 
	" memory.writedword(int addr, int val) / writelong
	$LF
]h4
[div class=p 
	"Writes the passed value to the passed memory address addr. GB addresses at 01:Cxxx are should be passed as Dxxx. Byte = 1 byte, word/short = 2 bytes, dword/long = 4 bytes.
	$LF
]div
[h4 id=IntMemoryGetregisterString 
	" int memory.getregister(string)
	$LF
]h4
[div class=p 
	"Returns the value of the hardware register passed. Hardware registers are: GB - a f b c d e h l af bc de hl sp pc; GBA - r0 .. r15, cpsr, spsr.
	$LF
]div
[h4 id=MemorySetregisterStringInt 
	" memory.setregister(string, int)
	$LF
]h4
[div class=p 
	"Sets the hardware register passed with the value passed.
	$LF
]div
[h4 id=MemoryRegisterwriteIntAddrFunctionFuncRegister 
	" memory.registerwrite(int addr, function func) / register
	$LF
]h4
[h4 id=MemoryRegisterexecIntAddrFunctionFuncRegisterrunRegisterexecute 
	" memory.registerexec(int addr, function func) / registerrun / registerexecute
	$LF
]h4
[div class=p 
	"Registers the passed function to be called whenever the given address is written to / executed.
	$LF
]div
[h3 id=Joypad 
	" joypad
	$LF
]h3
[div class=p 
	"Before the next frame is emulated, one may set keys to be pressed. The buffer is cleared each frame.
	$LF
]div
[h4 id=TableJoypadGetIntPortRead 
	" table joypad.get(int port) / read
	$LF
]h4
[div class=p 
	"Returns a table of all buttons. Does not read movie input. Key values are 1 for pressed, nil for not pressed. Keys for joypad table: (A, B, select, start, right, left, up, down, R, L). Keys are case-sensitive. When passed 0, the default joypad is read
	$LF
]div
[h4 id=TableJoypadGetdownIntPortReaddown 
	" table joypad.getdown(int port) / readdown
	$LF
]h4
[div class=p 
	"Returns a table of only the buttons that are being pressed.
	$LF
]div
[h4 id=TableJoypadGetupIntPortReadup 
	" table joypad.getup(int port) / readup
	$LF
]h4
[div class=p 
	"Returns a table of only the buttons that are not being pressed.
	$LF
]div
[h4 id=JoypadSetIntPortTableButtonsWrite 
	" joypad.set(int port, table buttons) / write
	$LF
]h4
[div class=p 
	"Sets the buttons to be pressed next frame. Cannot clear buttons.
	$LF
]div
[h3 id=Savestate 
	" savestate
	$LF
]h3
[h4 id=ObjectSavestateCreateIntSlotNil 
	" object savestate.create(int slot=nil)
	$LF
]h4
[div class=p 
	"Creates a savestate object. If any argument is given, it must be from 1 to 12, and it corresponds with the numbered savestate slots. If no argument is given, the savestate can only be accessed by Lua.
	$LF
]div
[h4 id=SavestateSaveObjectSavestate 
	"savestate.save(object savestate)
	$LF
]h4
[div class=p 
	"Saves the current state to the savestate object.
	$LF
]div
[h4 id=SavestateLoadObjectSavestate 
	"savestate.load(object savestate)
	$LF
]h4
[div class=p 
	"Loads the state of the savestate object as the current state.
	$LF
]div
[h3 id=Movie 
	" movie
	$LF
]h3
[h4 id=BooleanMovieActive 
	" boolean movie.active()
	$LF
]h4
[div class=p 
	"Returns true if a movie is active.
	$LF
]div
[h4 id=BooleanMovieRecording 
	" boolean movie.recording()
	$LF
]h4
[div class=p 
	"Returns true if a movie is recording.
	$LF
]div
[h4 id=BooleanMoviePlaying 
	" boolean movie.playing()
	$LF
]h4
[div class=p 
	"Returns true if a movie is playing.
	$LF
]div
[h4 id=StringMovieMode 
	" string movie.mode()
	$LF
]h4
[div class=p 
	"Returns "record" if movie is recording, "playback" if movie is replaying input, or nil if there is no movie.
	$LF
]div
[h4 id=IntMovieLength 
	" int movie.length()
	$LF
]h4
[div class=p 
	"Returns the length of the active movie, or otherwise 0.
	$LF
]div
[h4 id=StringMovieAuthorGetauthor 
	" string movie.author() / getauthor
	$LF
]h4
[div class=p 
	"Returns the author info field of the movie file, or nil if there is no movie.
	$LF
]div
[h4 id=StringMovieNameGetname 
	" string movie.name() / getname
	$LF
]h4
[div class=p 
	"Returns the name of the movie file, or nil if there is no movie.
	$LF
]div
[h4 id=IntMovieRerecordcount 
	" int movie.rerecordcount()
	$LF
]h4
[div class=p 
	"Returns the rerecord count of the active movie, or otherwise 0.
	$LF
]div
[h4 id=MovieSetrerecordcountInt 
	" movie.setrerecordcount(int)
	$LF
]h4
[div class=p 
	"Sets the rerecord count to the passed value.
	$LF
]div
[h4 id=MovieRerecordcountingBoolean 
	" movie.rerecordcounting(boolean)
	$LF
]h4
[div class=p 
	"If set to true, no rerecords done by Lua are counted in the rerecord total. If set to false, rerecords done by Lua count. By default, rerecords count.
	$LF
]div
[h4 id=MovieStopClose 
	" movie.stop() / close
	$LF
]h4
[div class=p 
	"Stops the movie. Cannot be used if there is no movie.
	$LF
]div
[h3 id=Gui 
	" gui
	$LF
]h3
[div class=p 
	"Before the next frame is drawn, one may draw to the buffer. The buffer is cleared each frame.
	$LF
]div
[div class=p 
	"All functions assume that the width is 256 and the height of the image is 239, regardless of the type of game. GB(C) resolution = 160x144, SGB = 256x224, GBA = 240x160
	$LF
]div
[div class=p 
	"Color can be given as 0xRRGGBBAA; like HTML ("#RRGGBBAA"); as a string (white, black, clear, gray, grey, red, orange, yellow, chatreuse, green, teal, cyan, blue, purple, magenta); a random colour ("rand"); or as a table, where the keys are 'r', 'g', 'b', and 'a' repsectively. For alpha, 00 is transparent, FF is opaque.
	$LF
]div
[h4 id=FunctionGuiRegisterFunctionFunc 
	" function gui.register(function func)
	$LF
]h4
[div class=p 
	"The passed function will be called just before the screen is updated each frame. The passed function will be registered in place of the previous, and the previous returned. Functions can be unregistered by passing nil.
	$LF
]div
[h4 id=GuiTextIntXIntYStringMsgTypeFillcolorTypeBordercolorDrawtext 
	" gui.text(int x, int y, string msg, type fillcolor, type bordercolor) / drawtext
	$LF
]h4
[div class=p 
	"Draws the given text at (x,y). Not to be confused with vba.message(string msg).
	$LF
]div
[h4 id=GuiBoxIntX1IntY1IntX2IntY2TypeFillcolorTypeBordercolorDrawboxRectDrawrect 
	" gui.box(int x1, int y1, int x2, int y2, type fillcolor, type bordercolor) / drawbox / rect / drawrect
	$LF
]h4
[div class=p 
	"Draws a box with (x1,y1) and (x2,y2) as opposite corners with the given colors.
	$LF
]div
[h4 id=GuiLineIntX1IntY1IntX2IntY2TypeColorBooleanSkipfirstDrawline 
	" gui.line(int x1, int y1, int x2, int y2, type color, boolean skipfirst) / drawline
	$LF
]h4
[div class=p 
	"Draws a line from (x1,y1) to (x2,y2) with the given color. The first pixel of the line is only drawn when skipfirst is false.
	$LF
]div
[h4 id=GuiPixelIntXIntYTypeColorDrawpixelSetpixelWritepixel 
	" gui.pixel(int x, int y, type color) / drawpixel / setpixel / writepixel
	$LF
]h4
[div class=p 
	"Draws a pixel at (x,y) with the given color.
	$LF
]div
[h4 id=GuiOpacityFloatAlpha 
	" gui.opacity(float alpha)
	$LF
]h4
[div class=p 
	"Sets the opacity of drawings depending on alpha. 0.0 is transparent, 1.0 is opaque. Values less than 0.0 or greater than 1.0 work by extrapolation.
	$LF
]div
[h4 id=GuiTransparencyFloatStrength 
	" gui.transparency(float strength)
	$LF
]h4
[div class=p 
	"4.0 is transparent, 0.0 is opaque. Values less than 0.0 or greater than 4.0 work by extrapolation.
	$LF
]div
[h4 id=StringGuiPopupStringMsgStringTypeOk 
	" string gui.popup(string msg, string type = "ok")
	$LF
]h4
[div class=p 
	"Creates a pop-up dialog box with the given text and some dialog buttons. There are three types: "ok", "yesno", and "yesnocancel". If "yesno" or "yesnocancel", it returns either "yes", "no", or "cancel", depending on the button pressed. If "ok", it returns nil.
	$LF
]div
[h4 id=IntIntIntIntGuiParsecolorTypeColour 
	" int int int int gui.parsecolor(type colour)
	$LF
]h4
[div class=p 
	"Returns the red, green, blue and alpha values for the passed colour.
	$LF
]div
[h4 id=StringGuiGdscreenshot 
	" string gui.gdscreenshot()
	$LF
]h4
[div class=p 
	"Takes a screenshot and returns it as a string that can be used by the gd library.
	$LF
	"For direct access, use string.byte(str,offset). The gd image consists of a 11-byte header and each pixel is alpha,red,green,blue (1 byte each, alpha is 0 in this case) left to right then top to bottom.
	$LF
]div
[h4 id=GuiGdoverlayIntDestx0IntDesty0StringGdimageSrcxIntSrcyIntWidthIntHeightFloatAlpha10DrawimageImage 
	" gui.gdoverlay(int destX=0, int destY=0, string gdimage, srcX, int srcY, int width, int height, float alpha=1.0) / drawimage / image
	$LF
]h4
[div class=p 
	"Overlays (a section of) the passed gd image with top-left corner at (destX,destY) with the passed opacity. If giving the source parameters, all four must be given.
	$LF
]div
[h4 id=IntIntIntGuiGetpixelIntXIntYReadpixel 
	" int int int gui.getpixel(int x, int y) / readpixel
	$LF
]h4
[div class=p 
	"Returns the red, green and blue values for the pixel at the passed (x,y).
	$LF
]div
[h3 id=Input 
	" input
	$LF
]h3
[h4 id=TableInputGetRead 
	" table input.get() / read
	$LF
]h4
[div class=p 
	"Returns a table of which keyboard buttons are pressed as well as mouse status. Key values for keyboard buttons and mouse clicks are true for pressed, nil for not pressed. Mouse position is returned in terms of game screen pixel coordinates. Keys for mouse are (xmouse, ymouse, leftclick, rightclick, middleclick).
	$LF
]div
[div class=p 
	"Keys for keyboard buttons: backspace, tab, enter, shift, control, alt, pause, capslock, escape, space, pageup, pagedown, end, home, left, up, right, down, insert, delete, 0 .. 9, A .. Z, numpad0 .. numpad9, numpad*, numpad+, numpad-, numpad., numpad/, F1 .. F24, numlock, scrolllock, semicolon, plus, comma, minus, period, slash, tilde, leftbracket, backslash, rightbracket, quote.
	$LF
]div
[div class=p 
	"Keys are case-sensitive. Keys for keyboard buttons are for buttons, not ASCII characters, so there is no need to hold down shift. Key names may differ depending on keyboard layout. On US keyboard layouts, "slash" is /?, "tilde" is `~, "leftbracket" is 
	"[{, "backslash" is \|, "rightbracket" is ]
	"}, "quote" is '".
	$LF
]div
[h3 id=Bit 
	" bit
	$LF
]h3
[div class=p 
	"All the functions from the bitop module are included, see 
	[a href=http://bitop.luajit.org/ rel=noopener external nofollow 
		"http://bitop.luajit.org
	]a
	$LF
]div
[h3 id=Avi 
	" avi
	$LF
]h3
[h4 id=IntAviFramcount 
	" int avi.framcount()
	$LF
]h4
[div class=p 
	"Returns the number of frames recorded to AVI if an AVI is being recorded, else 0 is returned.
	$LF
]div
[h3 id=Other 
	" other
	$LF
]h3
[h4 id=PrintString 
	" print(string)
	$LF
]h4
[div class=p 
	"Prints the message to the Lua console.
	$LF
]div
[h4 id=StringTostringType 
	" string tostring(type)
	$LF
]h4
[div class=p 
	"Returns a string representation of the passed data.
	$LF
]div
[h4 id=IntAddressofPointer 
	" int addressof(pointer)
	$LF
]h4
[div class=p 
	"Returns the value of the passed pointer, because the print function returns the content of the pointer.
	$LF
]div
[h4 id=TableCopytableTable 
	" table copytable(table)
	$LF
]h4
[div class=p 
	"Returns a shallow copy of the passed table.
	$LF
]div
[h4 id=IntAndInt 
	" int AND(int, ...)
	$LF
]h4
[h4 id=IntOrInt 
	" int OR(int, ...)
	$LF
]h4
[h4 id=IntXorInt 
	" int XOR(int, ...)
	$LF
]h4
[div class=p 
	"Aliases for the same functions in the bitop module.
	$LF
]div
[h4 id=IntShiftIntInt 
	" int SHIFT(int, int)
	$LF
]h4
[div class=p 
	"Shifts right when positive, shifts the inverse left when negative.
	$LF
]div
[h4 id=IntBitInt 
	" int BIT(int, ...)
	$LF
]h4
[div class=p 
	"Returns an integer with the passed bits set.
]div
