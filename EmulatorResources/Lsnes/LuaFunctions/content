21
[div class=p 
	"This page documents various lua functions in lsnes.
	$LF
]div
[div class=p 
	"Unless otherwise noted, functions are in rr1 version and work anywhere.
	$LF
]div
[div class=card mb-2 
	[div class=card-header 
		[strong 
			"Table of contents
		]strong
	]div
	[div class=card-body 
		[ul 
			[li 
				[a href=#BitManipulationFunctions 
					"Bit manipulation functions
					$LF
				]a
				[ul 
					[li 
						[a href=#GenericRemarks 
							"(Generic remarks)
							$LF
						]a
					]li
					[li 
						[a href=#BitNoneBitBnot 
							"bit.none / bit.bnot
							$LF
						]a
					]li
					[li 
						[a href=#BitAnyBitBor 
							"bit.any / bit.bor
							$LF
						]a
					]li
					[li 
						[a href=#BitAllBitBand 
							"bit.all / bit.band
							$LF
						]a
					]li
					[li 
						[a href=#BitParity 
							"bit.parity
							$LF
						]a
					]li
					[li 
						[a href=#BitLrotate 
							"bit.lrotate
							$LF
						]a
					]li
					[li 
						[a href=#BitRrotate 
							"bit.rrotate
							$LF
						]a
					]li
					[li 
						[a href=#BitLshift 
							"bit.lshift
							$LF
						]a
					]li
					[li 
						[a href=#BitLrshift 
							"bit.lrshift
							$LF
						]a
					]li
					[li 
						[a href=#BitArshift 
							"bit.arshift
							$LF
						]a
					]li
					[li 
						[a href=#BitExtract 
							"bit.extract
							$LF
						]a
					]li
					[li 
						[a href=#BitValue 
							"bit.value
							$LF
						]a
					]li
					[li 
						[a href=#BitTestAny 
							"bit.test_any
							$LF
						]a
					]li
					[li 
						[a href=#BitTestAll 
							"bit.test_all
							$LF
						]a
					]li
					[li 
						[a href=#BitPopcount 
							"bit.popcount
							$LF
						]a
					]li
					[li 
						[a href=#BitClshift 
							"bit.clshift
							$LF
						]a
					]li
					[li 
						[a href=#BitCrshift 
							"bit.crshift
							$LF
						]a
					]li
					[li 
						[a href=#BitFlagdecode 
							"bit.flagdecode
							$LF
						]a
					]li
					[li 
						[a href=#BitRflagdecode 
							"bit.rflagdecode
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#GuiFunctions 
					"GUI functions
					$LF
				]a
				[ul 
					[li 
						[a href=#ColorNotation 
							"(Color notation)
							$LF
						]a
					]li
					[li 
						[a href=#CoordinateSystem 
							"(Coordinate system)
							$LF
						]a
					]li
					[li 
						[a href=#DrawOrder 
							"(Draw order)
							$LF
						]a
					]li
					[li 
						[a href=#ValidIn 
							"(Valid in)
							$LF
						]a
					]li
					[li 
						[a href=#GuiScreenshot 
							"gui.screenshot
							$LF
						]a
					]li
					[li 
						[a href=#GuiCircle 
							"gui.circle
							$LF
						]a
					]li
					[li 
						[a href=#GuiResolution 
							"gui.resolution
							$LF
						]a
					]li
					[li 
						[a href=#GuiLeftGapGuiTopGapGuiRightGapGuiBottomGap 
							"gui.left_gap / gui.top_gap / gui.right_gap / gui.bottom_gap
							$LF
						]a
					]li
					[li 
						[a href=#GuiRepaint 
							"gui.repaint
							$LF
						]a
					]li
					[li 
						[a href=#GuiSubframeUpdate 
							"gui.subframe_update
							$LF
						]a
					]li
					[li 
						[a href=#GuiColor 
							"gui.color
							$LF
						]a
					]li
					[li 
						[a href=#GuiStatus 
							"gui.status
							$LF
						]a
					]li
					[li 
						[a href=#GuiCrosshair 
							"gui.crosshair
							$LF
						]a
					]li
					[li 
						[a href=#GuiLine 
							"gui.line
							$LF
						]a
					]li
					[li 
						[a href=#GuiPixel 
							"gui.pixel
							$LF
						]a
					]li
					[li 
						[a href=#GuiRectangle 
							"gui.rectangle
							$LF
						]a
					]li
					[li 
						[a href=#GuiBox 
							"gui.box
							$LF
						]a
					]li
					[li 
						[a href=#GuiTextGuiTexthGuiTextvGuiTexthv 
							"gui.text / gui.textH / gui.textV / gui.textHV
							$LF
						]a
					]li
					[li 
						[a href=#GuiBitmapDraw 
							"gui.bitmap_draw
							$LF
						]a
					]li
					[li 
						[a href=#GuiPaletteNew 
							"gui.palette_new
							$LF
						]a
					]li
					[li 
						[a href=#GuiPaletteSet 
							"gui.palette_set
							$LF
						]a
					]li
					[li 
						[a href=#GuiBitmapNew 
							"gui.bitmap_new
							$LF
						]a
					]li
					[li 
						[a href=#GuiBitmapPset 
							"gui.bitmap_pset
							$LF
						]a
					]li
					[li 
						[a href=#GuiBitmapSize 
							"gui.bitmap_size
							$LF
						]a
					]li
					[li 
						[a href=#GuiBitmapBlit 
							"gui.bitmap_blit
							$LF
						]a
					]li
					[li 
						[a href=#GuiBitmapLoad 
							"gui.bitmap_load
							$LF
						]a
					]li
					[li 
						[a href=#GuiRainbow 
							"gui.rainbow
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#HostmemoryFunctions 
					"Hostmemory functions
					$LF
				]a
				[ul 
					[li 
						[a href=#Generic 
							"(Generic)
							$LF
						]a
					]li
					[li 
						[a href=#HostmemoryReadHostmemoryReadbyteHostmemoryReadwordHostmemoryReaddwordHostmemoryReadqword 
							"hostmemory.read / hostmemory.readbyte / hostmemory.readword / hostmemory.readdword / hostmemory.readqword
							$LF
						]a
					]li
					[li 
						[a href=#HostmemoryReadsbyteHostmemoryReadswordHostmemoryReadsdwordHostmemoryReadsqword 
							"hostmemory.readsbyte / hostmemory.readsword / hostmemory.readsdword / hostmemory.readsqword
							$LF
						]a
					]li
					[li 
						[a href=#HostmemoryWriteHostmemoryWritebyteHostmemoryWritewordHostmemoryWritedwordHostmemoryWriteqword 
							"hostmemory.write / hostmemory.writebyte / hostmemory.writeword / hostmemory.writedword / hostmemory.writeqword
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#InputFunctions 
					"Input functions
					$LF
				]a
				[ul 
					[li 
						[a href=#Generic_2 
							"(Generic)
							$LF
						]a
					]li
					[li 
						[a href=#InputSet 
							"input.set
							$LF
						]a
					]li
					[li 
						[a href=#InputGet 
							"input.get
							$LF
						]a
					]li
					[li 
						[a href=#InputReset 
							"input.reset
							$LF
						]a
					]li
					[li 
						[a href=#InputRaw 
							"input.raw
							$LF
						]a
					]li
					[li 
						[a href=#InputKeyhook 
							"input.keyhook
							$LF
						]a
					]li
					[li 
						[a href=#InputGeta 
							"input.geta
							$LF
						]a
					]li
					[li 
						[a href=#InputSeta 
							"input.seta
							$LF
						]a
					]li
					[li 
						[a href=#InputJoyget 
							"input.joyget
							$LF
						]a
					]li
					[li 
						[a href=#InputJoyset 
							"input.joyset
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#MemoryFunctions 
					"Memory functions
					$LF
				]a
				[ul 
					[li 
						[a href=#Generic_3 
							"(Generic)
							$LF
						]a
					]li
					[li 
						[a href=#MemoryReadMemoryReadbyteMemoryReadwordMemoryReaddwordMemoryReadqword 
							"memory.read / memory.readbyte / memory.readword / memory.readdword / memory.readqword
							$LF
						]a
					]li
					[li 
						[a href=#MemoryReadsbyteMemoryReadswordMemoryReadsdwordMemoryReadsqword 
							"memory.readsbyte / memory.readsword / memory.readsdword / memory.readsqword
							$LF
						]a
					]li
					[li 
						[a href=#MemoryWriteMemoryWritebyteMemoryWritewordMemoryWritedwordMemoryWriteqword 
							"memory.write / memory.writebyte / memory.writeword / memory.writedword / memory.writeqword
							$LF
						]a
					]li
					[li 
						[a href=#MemoryMapbyteMemoryMapsbyteMemoryMapwordMemoryMapswordMemoryMapdwordMemoryMapsdwordMemoryMapqwordMemoryMapsqword 
							"memory.mapbyte / memory.mapsbyte / memory.mapword / memory.mapsword / memory.mapdword / memory.mapsdword / memory.mapqword / memory.mapsqword
							$LF
						]a
					]li
					[li 
						[a href=#MemoryMapStructure 
							"memory.map_structure()
							$LF
						]a
					]li
					[li 
						[a href=#MemoryVmaCount 
							"memory.vma_count
							$LF
						]a
					]li
					[li 
						[a href=#MemoryReadVma 
							"memory.read_vma
							$LF
						]a
					]li
					[li 
						[a href=#MemoryFindVma 
							"memory.find_vma
							$LF
						]a
					]li
					[li 
						[a href=#MemoryHashState 
							"memory.hash_state
							$LF
						]a
					]li
					[li 
						[a href=#MemoryHashRegion 
							"memory.hash_region
							$LF
						]a
					]li
					[li 
						[a href=#MemoryReadregion 
							"memory.readregion
							$LF
						]a
					]li
					[li 
						[a href=#MemoryWriteregion 
							"memory.writeregion
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#MovieFunctions 
					"Movie functions
					$LF
				]a
				[ul 
					[li 
						[a href=#MovieCurrentframe 
							"movie.currentframe
							$LF
						]a
					]li
					[li 
						[a href=#MovieFramecount 
							"movie.framecount
							$LF
						]a
					]li
					[li 
						[a href=#MovieReadonly 
							"movie.readonly
							$LF
						]a
					]li
					[li 
						[a href=#MovieReadwrite 
							"movie.readwrite
							$LF
						]a
					]li
					[li 
						[a href=#MovieFrameSubframes 
							"movie.frame_subframes
							$LF
						]a
					]li
					[li 
						[a href=#MovieReadSubframes 
							"movie.read_subframes
							$LF
						]a
					]li
					[li 
						[a href=#MovieReadRtc 
							"movie.read_rtc
							$LF
						]a
					]li
					[li 
						[a href=#MovieUnsafeRewind 
							"movie.unsafe_rewind
							$LF
						]a
					]li
					[li 
						[a href=#MovieRerecords 
							"movie.rerecords
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#SettingsFunctions 
					"Settings functions
					$LF
				]a
				[ul 
					[li 
						[a href=#Generic_4 
							"(Generic)
							$LF
						]a
					]li
					[li 
						[a href=#SettingsSet 
							"settings.set
							$LF
						]a
					]li
					[li 
						[a href=#SettingGet 
							"setting.get
							$LF
						]a
					]li
					[li 
						[a href=#SettingBlank 
							"setting.blank
							$LF
						]a
					]li
					[li 
						[a href=#SettingIsSet 
							"setting.is_set
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#MiscFunctions 
					"Misc. functions
					$LF
				]a
				[ul 
					[li 
						[a href=#Exec 
							"exec
							$LF
						]a
					]li
					[li 
						[a href=#Print 
							"print
							$LF
						]a
					]li
					[li 
						[a href=#Utime 
							"utime
							$LF
						]a
					]li
					[li 
						[a href=#EmulatorReady 
							"emulator_ready
							$LF
						]a
					]li
					[li 
						[a href=#SetIdleTimeout 
							"set_idle_timeout
							$LF
						]a
					]li
					[li 
						[a href=#SetTimerTimeout 
							"set_timer_timeout
							$LF
						]a
					]li
					[li 
						[a href=#BusAddress 
							"bus_address
							$LF
						]a
					]li
					[li 
						[a href=#Loopwrapper 
							"loopwrapper(
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Callbacks 
					"Callbacks
					$LF
				]a
				[ul 
					[li 
						[a href=#Generic_5 
							"(Generic)
							$LF
						]a
					]li
					[li 
						[a href=#OnPaint 
							"on_paint
							$LF
						]a
					]li
					[li 
						[a href=#OnVideo 
							"on_video
							$LF
						]a
					]li
					[li 
						[a href=#OnInput 
							"on_input
							$LF
						]a
					]li
					[li 
						[a href=#OnReset 
							"on_reset
							$LF
						]a
					]li
					[li 
						[a href=#OnFrame 
							"on_frame
							$LF
						]a
					]li
					[li 
						[a href=#OnReadwrite 
							"on_readwrite
							$LF
						]a
					]li
					[li 
						[a href=#OnStartup 
							"on_startup
							$LF
						]a
					]li
					[li 
						[a href=#OnPreLoad 
							"on_pre_load
							$LF
						]a
					]li
					[li 
						[a href=#OnErrLoad 
							"on_err_load
							$LF
						]a
					]li
					[li 
						[a href=#OnPostLoad 
							"on_post_load
							$LF
						]a
					]li
					[li 
						[a href=#OnPreSave 
							"on_pre_save
							$LF
						]a
					]li
					[li 
						[a href=#OnErrSave 
							"on_err_save
							$LF
						]a
					]li
					[li 
						[a href=#OnPostSave 
							"on_post_save
							$LF
						]a
					]li
					[li 
						[a href=#OnSnoop 
							"on_snoop
							$LF
						]a
					]li
					[li 
						[a href=#OnQuit 
							"on_quit
							$LF
						]a
					]li
					[li 
						[a href=#OnKeyhook 
							"on_keyhook
							$LF
						]a
					]li
					[li 
						[a href=#OnSetRewind 
							"on_set_rewind
							$LF
						]a
					]li
					[li 
						[a href=#OnPreRewind 
							"on_pre_rewind
							$LF
						]a
					]li
					[li 
						[a href=#OnPostRewind 
							"on_post_rewind
							$LF
						]a
					]li
					[li 
						[a href=#OnFrameEmulated 
							"on_frame_emulated
							$LF
						]a
					]li
					[li 
						[a href=#OnIdle 
							"on_idle
							$LF
						]a
					]li
					[li 
						[a href=#OnTimer 
							"on_timer
							$LF
						]a
					]li
				]ul
			]li
		]ul
	]div
]div
[h2 id=BitManipulationFunctions 
	"Bit manipulation functions
	$LF
]h2
[h3 id=GenericRemarks 
	"(Generic remarks)
	$LF
]h3
[div class=p 
	"Bit manipulation functions work on 48-bit numbers and return 48-bit results. Negative numbers are interpreted as two's complement.
	$LF
]div
[h3 id=BitNoneBitBnot 
	"bit.none / bit.bnot
	$LF
]h3
[blockquote 
	"Syntax: Number bit.none(Number n...)
	[br 
	]br
	$LF
	"Syntax: Number bit.bnot(Number n...)
	$LF
]blockquote
[div class=p 
	"Returns number that has bit i set exactly when none of the arguments has the bit i set.
	$LF
]div
[div class=p 
	"When called with one argument, this is the same as the bitwise NOT.
	$LF
]div
[h3 id=BitAnyBitBor 
	"bit.any / bit.bor
	$LF
]h3
[blockquote 
	"Syntax: Number bit.any(Number n...)
	[br 
	]br
	$LF
	"Syntax: Number bit.bor(Number n...)
	$LF
]blockquote
[div class=p 
	"Returns number that has bit i set exactly when any of the arguments has the bit i set.
	$LF
]div
[div class=p 
	"If called with two arguments, this is the same as bitwise OR.
	$LF
]div
[h3 id=BitAllBitBand 
	"bit.all / bit.band
	$LF
]h3
[blockquote 
	"Syntax: Number bit.all(Number n...)
	[br 
	]br
	$LF
	"Syntax: Number bit.band(Number n...)
	$LF
]blockquote
[div class=p 
	"Returns number that has bit i set exactly when all of the arguments have the bit i set.
	$LF
]div
[div class=p 
	"If called with two arguments, this is the same as bitwise AND.
	$LF
]div
[h3 id=BitParity 
	"bit.parity
	$LF
]h3
[blockquote 
	"Syntax: Number bit.parity(Number n...)
	[br 
	]br
	$LF
	"Syntax: Number bit.bxor(Number n...)
	$LF
]blockquote
[div class=p 
	"Returns number that has bit i set exactly when odd number of the arguments has the bit i set.
	$LF
]div
[div class=p 
	"If called with two arguments, this is the same as bitwise XOR.
	$LF
]div
[h3 id=BitLrotate 
	"bit.lrotate
	$LF
]h3
[blockquote 
	"Syntax: Number bit.lrotate(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[div class=p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, rotated left by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]div
[div class=p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]div
[h3 id=BitRrotate 
	"bit.rrotate
	$LF
]h3
[blockquote 
	"Syntax: Number bit.rrotate(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[div class=p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, rotated right by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]div
[div class=p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]div
[h3 id=BitLshift 
	"bit.lshift
	$LF
]h3
[blockquote 
	"Syntax: Number bit.lshift(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[div class=p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, shifted left by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]div
[div class=p 
	"The bits that leave 
	[b 
		"nbits
	]b
	" least significant bits are discarded. The shifted in bits are zeroes.
	$LF
]div
[div class=p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]div
[h3 id=BitLrshift 
	"bit.lrshift
	$LF
]h3
[blockquote 
	"Syntax: Number bit.lrshift(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[div class=p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, shifted logically right by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]div
[div class=p 
	"The bits that drop off the right end are discarded. The shifted in bits are zeroes.
	$LF
]div
[div class=p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]div
[h3 id=BitArshift 
	"bit.arshift
	$LF
]h3
[blockquote 
	"Syntax: Number bit.arshift(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[div class=p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, shifted arithmetically right by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]div
[div class=p 
	"The bits that drop off the right end are discarded. The shifted in bits are copies of the most significant bit.
	$LF
]div
[div class=p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]div
[h3 id=BitExtract 
	"bit.extract
	$LF
]h3
[blockquote 
	"Syntax: Number bit.extract(Number base, Number/Boolean place...)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ5
		$LF
	]li
]ul
[div class=p 
	"Returns a number where ith bit is taken from the ith 
	[b 
		"place
	]b
	"th bit of 
	[b 
		"base
	]b
	".
	$LF
]div
[div class=p 
	"As special case, if ith 
	[b 
		"place
	]b
	" is boolean, the ith returned bit is that value (1 if argument was true, 0 if false).
	$LF
]div
[h3 id=BitValue 
	"bit.value
	$LF
]h3
[blockquote 
	"Syntax: Number bit.value(Number/nil place...)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ5
		$LF
	]li
]ul
[div class=p 
	"Returns number that has all 
	[b 
		"place
	]b
	"th bits set.
	$LF
]div
[div class=p 
	"As special case, any nil arguments are ignored.
	$LF
]div
[h3 id=BitTestAny 
	"bit.test_any
	$LF
]h3
[blockquote 
	"Syntax: Boolean bit.test_any(Number a, Number b)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[div class=p 
	"Returns true if a and b have common set bit or bits.
	$LF
]div
[h3 id=BitTestAll 
	"bit.test_all
	$LF
]h3
[blockquote 
	"Syntax: Boolean bit.test_all(Number a, Number b)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[div class=p 
	"Returns true if a has all the bits set in b set.
	$LF
]div
[h3 id=BitPopcount 
	"bit.popcount
	$LF
]h3
[blockquote 
	"Syntax: Number bit.popcount(Number a)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[div class=p 
	"Returns population count (number of set bits) of a.
	$LF
]div
[h3 id=BitClshift 
	"bit.clshift
	$LF
]h3
[blockquote 
	"Syntax: Number,Number bit.clshift(Number a, Number b, [Number places], [Number bits])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[div class=p 
	"Chained shift of a and b left by specified number of places (default 1). The numbers are treated as having specified number of bits (default 48).
	$LF
]div
[h3 id=BitCrshift 
	"bit.crshift
	$LF
]h3
[blockquote 
	"Syntax: Number,Number bit.crshift(Number a, Number b, [Number places], [Number bits])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[div class=p 
	"Chained shift of a and b right by specified number of places (default 1). The numbers are treated as having specified number of bits (default 48).
	$LF
]div
[h3 id=BitFlagdecode 
	"bit.flagdecode
	$LF
]h3
[blockquote 
	"Syntax: String bit.flagdecode(Number a, Number bits, [String set], [String clear])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[div class=p 
	"Returns string where ith character is ith character (only character or '*') of set if corresponding bit is set, otherwise corresponding character of clear.
	$LF
]div
[h3 id=BitRflagdecode 
	"bit.rflagdecode
	$LF
]h3
[blockquote 
	"Syntax: String bit.rflagdecode(Number a, Number bits, [String set], [String clear])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[div class=p 
	"Same as bit.flagdecode, but reverses the output string.
	$LF
]div
[h2 id=GuiFunctions 
	"GUI functions
	$LF
]h2
[h3 id=ColorNotation 
	"(Color notation)
	$LF
]h3
[ul 
	[li 
		" -1 is fully transparent.
		$LF
	]li
	[li 
		" 16777216 * a + 65536 * r + 256 * g + b for other colors, where a is transparency.
		$LF
	]li
	[li 
		" * The range of r, g and b and a is 0-255.
		$LF
	]li
	[li 
		" * Alpha 0 is fully opaque, alpha 256 is fully transparent.
		$LF
	]li
	[li 
		" * The a of this notation only goes to 255, despite there being alpha 256.
		$LF
	]li
]ul
[h3 id=CoordinateSystem 
	"(Coordinate system)
	$LF
]h3
[ul 
	[li 
		" Origin is at top left of the game area.
		$LF
	]li
	[li 
		" Positive directions are right and down.
		$LF
	]li
	[li 
		" Left gap and top gap have negative coordinates.
		$LF
	]li
]ul
[h3 id=DrawOrder 
	"(Draw order)
	$LF
]h3
[ul 
	[li 
		" The primitives are drawn in order they are specified.
		$LF
	]li
	[li 
		" Gap settings always overtake everything else.
		$LF
	]li
]ul
[h3 id=ValidIn 
	"(Valid in)
	$LF
]h3
[ul 
	[li 
		" These primitives (unless otherwise noted) are only valid in callbacks 
		[b 
			"on_paint
		]b
		" and 
		[b 
			"on_video
		]b
		".
		$LF
	]li
	[li 
		" If called in 
		[b 
			"on_paint
		]b
		", the screen is affected.
		$LF
	]li
	[li 
		" If called in 
		[b 
			"on_video
		]b
		", the dumped video is affected.
		$LF
	]li
]ul
[h3 id=GuiScreenshot 
	"gui.screenshot
	$LF
]h3
[blockquote 
	"Syntax: none gui.screenshot(string filename)
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere.
		$LF
	]li
]ul
[div class=p 
	"Take a screenshot in PNG format and save it to 
	[b 
		"filename
	]b
	$LF
]div
[h3 id=GuiCircle 
	"gui.circle
	$LF
]h3
[blockquote 
	"Syntax: none gui.circle(Number x, Number y, Number r, [Number thickness], [Number outline_color], [Number fill_color])
	$LF
]blockquote
[ul 
	[li 
		" thickness defaults to 1
		$LF
	]li
	[li 
		" outline_color defaults to white
		$LF
	]li
	[li 
		" fill_color defaults to transparent
		$LF
	]li
]ul
[div class=p 
	"Draws a circle centered at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	") with radius 
	[b 
		"r
	]b
	".
	$LF
]div
[div class=p 
	"The outline is of thickness 
	[b 
		"thickness
	]b
	" and is drawn using color specified by 
	[b 
		"outline_color
	]b
	$LF
]div
[div class=p 
	"The interior region is filled with color 
	[b 
		"fill_color
	]b
	".
	$LF
]div
[h3 id=GuiResolution 
	"gui.resolution
	$LF
]h3
[blockquote 
	" Syntax (number width, number height) gui.resolution()
	$LF
]blockquote
[div class=p 
	"Returns the width (
	[b 
		"width
	]b
	") and height (
	[b 
		"height
	]b
	") of game area.
	$LF
]div
[h3 id=GuiLeftGapGuiTopGapGuiRightGapGuiBottomGap 
	"gui.left_gap / gui.top_gap / gui.right_gap / gui.bottom_gap
	$LF
]h3
[blockquote 
	" Syntax none gui.left_gap(number pixels)
	[br 
	]br
	$LF
	" Syntax none gui.top_gap(number pixels)
	[br 
	]br
	$LF
	" Syntax none gui.right_gap(number pixels)
	[br 
	]br
	$LF
	" Syntax none gui.bottom_gap(number pixels)
	$LF
]blockquote
[div class=p 
	"Sets the width of drawable blank area to the left/top/right/bottom of the game area to 
	[b 
		"pixels
	]b
	".
	$LF
]div
[h3 id=GuiRepaint 
	"gui.repaint
	$LF
]h3
[blockquote 
	" Syntax: none gui.repaint()
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere.
		$LF
	]li
]ul
[div class=p 
	"Arranges 
	[b 
		"on_paint
	]b
	" hook to be called as soon as possible.
	$LF
]div
[h3 id=GuiSubframeUpdate 
	"gui.subframe_update
	$LF
]h3
[blockquote 
	" Syntax: none gui.subframe_update(boolean enabled)
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere
		$LF
	]li
]ul
[div class=p 
	"Enables (
	[b 
		"enabled
	]b
	"=true)/Disables (
	[b 
		"enabled
	]b
	"=false) calling of 
	[b 
		"on_paint
	]b
	" on every subframe (as opposed to just when new frame is available).
	$LF
]div
[h3 id=GuiColor 
	"gui.color
	$LF
]h3
[blockquote 
	" Syntax: Number gui.color(Number r, Number g, Number b, [Number a])
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere.
		$LF
	]li
	[li 
		" 
		[b 
			"a
		]b
		" defaults to 0 if not specified.
		$LF
	]li
]ul
[div class=p 
	"Returns the color code for color (
	[b 
		"r
	]b
	",
	[b 
		"g
	]b
	",
	[b 
		"b
	]b
	") (0-255 each channel) with alpha of 
	[b 
		"a
	]b
	" (0-256).
	$LF
]div
[h3 id=GuiStatus 
	"gui.status
	$LF
]h3
[blockquote 
	" Syntax: none gui.status(String name, String value)
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere
		$LF
	]li
]ul
[div class=p 
	"Set status 
	[b 
		"name
	]b
	" to value 
	[b 
		"value
	]b
	".
	$LF
]div
[div class=p 
	"If 
	[b 
		"value
	]b
	" is "", the status 
	[b 
		"name
	]b
	" is erased.
	$LF
]div
[h3 id=GuiCrosshair 
	"gui.crosshair
	$LF
]h3
[blockquote 
	" Syntax: none gui.crosshair(Number x, Number y, Number size, [Number color])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"color
		]b
		" defaults to white.
		$LF
	]li
]ul
[div class=p 
	"Draws a crosshair of size 
	[b 
		"size
	]b
	" at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	") using color 
	[b 
		"color
	]b
	".
	$LF
]div
[h3 id=GuiLine 
	"gui.line
	$LF
]h3
[blockquote 
	" Syntax: none gui.color(Number x1, Number y1, Number x2, Number y2, [Number color])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"color
		]b
		" defaults to white.
		$LF
	]li
]ul
[div class=p 
	"Draws a line from (
	[b 
		"x1
	]b
	",
	[b 
		"y1
	]b
	") to (
	[b 
		"x2
	]b
	",
	[b 
		"y2
	]b
	") using color 
	[b 
		"color
	]b
	".
	$LF
]div
[h3 id=GuiPixel 
	"gui.pixel
	$LF
]h3
[blockquote 
	" Syntax: none gui.pixel(Number x, Number y, [Number color])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"color
		]b
		" defaults to white.
		$LF
	]li
]ul
[div class=p 
	"Draws pixel at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	") using color 
	[b 
		"color
	]b
	".
	$LF
]div
[div class=p 
	"Be careful with this function. Even if it is the lightest of all draw functions, lots of draw functions don't do any good to performance.
	$LF
]div
[h3 id=GuiRectangle 
	"gui.rectangle
	$LF
]h3
[blockquote 
	" Syntax: none gui.rectangle(Number x, Number y, Number w, Number h, [Number thickness], [Number outline_color], [Number fill_color])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"tickness
		]b
		" defaults to 1.
		$LF
	]li
	[li 
		" 
		[b 
			"outline_color
		]b
		" defaults to white.
		$LF
	]li
	[li 
		" 
		[b 
			"fill_color
		]b
		" defaults to transparent.
		$LF
	]li
]ul
[div class=p 
	"Draws rectangle of size (
	[b 
		"w
	]b
	",
	[b 
		"h
	]b
	") with top-left corner at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	"). Outline is of thickness 
	[b 
		"thickness
	]b
	" and is colored with color 
	[b 
		"outline_color
	]b
	".
	$LF
]div
[div class=p 
	"The interior is filled with color 
	[b 
		"fill_color
	]b
	".
	$LF
]div
[h3 id=GuiBox 
	"gui.box
	$LF
]h3
[blockquote 
	" Syntax: none gui.box(Number x, Number y, Number w, Number h, [Number thickness], [Number hilight_color], [Number shadow_color], [Number fill_color])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ6
		$LF
	]li
	[li 
		" 
		[b 
			"thickness
		]b
		" defaults to 1.
		$LF
	]li
	[li 
		" 
		[b 
			"hilight_color
		]b
		" defaults to white.
		$LF
	]li
	[li 
		" 
		[b 
			"shadow_color
		]b
		" defaults to dark gray.
		$LF
	]li
	[li 
		" 
		[b 
			"fill_color
		]b
		" defaults to gray.
		$LF
	]li
]ul
[div class=p 
	"Draws rectangle of size (
	[b 
		"w
	]b
	",
	[b 
		"h
	]b
	") with top-left corner at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	").
	$LF
]div
[div class=p 
	"The outline is of thickness 
	[b 
		"thickness
	]b
	" and is colored with 
	[b 
		"hilight_color
	]b
	"/
	[b 
		"shadow_color
	]b
	" to create a 3D effect.
	$LF
]div
[div class=p 
	"The interior is filled with fill_color.
	$LF
]div
[h3 id=GuiTextGuiTexthGuiTextvGuiTexthv 
	"gui.text / gui.textH / gui.textV / gui.textHV
	$LF
]h3
[blockquote 
	" Syntax: none gui.text(Number x, Number y, String text, [Number fgcolor], [Number bgcolor])
	[br 
	]br
	$LF
	" Syntax: none gui.textH(Number x, Number y, String text, [Number fgcolor], [Number bgcolor])
	[br 
	]br
	$LF
	" Syntax: none gui.textV(Number x, Number y, String text, [Number fgcolor], [Number bgcolor])
	[br 
	]br
	$LF
	" Syntax: none gui.textHV(Number x, Number y, String text, [Number fgcolor], [Number bgcolor])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"fgcolor
		]b
		" defaults to white.
		$LF
	]li
	[li 
		" 
		[b 
			"bgcolor
		]b
		" defaults to transparent.
		$LF
	]li
]ul
[div class=p 
	"Draws text string 
	[b 
		"text
	]b
	" starting from (
	[b 
		"x
	]b
	", 
	[b 
		"y
	]b
	").
	$LF
]div
[div class=p 
	"The text will be colored using color 
	[b 
		"fgcolor
	]b
	" and the text background is colored using 
	[b 
		"bgcolor
	]b
	".
	$LF
]div
[div class=p 
	"The 
	[code 
		"H
	]code
	" variants will draw the text using double width, and the 
	[code 
		"V
	]code
	" variants will draw the text using double height.
	$LF
]div
[h3 id=GuiBitmapDraw 
	"gui.bitmap_draw
	$LF
]h3
[blockquote 
	" Syntax: none gui.bitmap_draw(Number x, Number y, BITMAP bmp, PALETTE pal)
	[br 
	]br
	$LF
	" Syntax: none gui.bitmap_draw(Number x, Number y, DBITMAP bmp)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
]ul
[div class=p 
	"Render bitmap 
	[b 
		"bmp
	]b
	" with upper-left corner at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	").
	$LF
]div
[div class=p 
	"If the bitmap is indexed, it will be rendered using palette 
	[b 
		"pal
	]b
	".
	$LF
]div
[h3 id=GuiPaletteNew 
	"gui.palette_new
	$LF
]h3
[blockquote 
	" Syntax: PALETTE gui.palette_new()
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[div class=p 
	"Returns a new PALETTE object. All colors are initialized to transparent.
	$LF
]div
[h3 id=GuiPaletteSet 
	"gui.palette_set
	$LF
]h3
[blockquote 
	" Syntax: none gui.palette_set(PALETTE pal, number idx, number color)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[div class=p 
	"Sets the color index 
	[b 
		"idx
	]b
	" in palette 
	[b 
		"pal
	]b
	" to color 
	[b 
		"color
	]b
	".
	$LF
]div
[h3 id=GuiBitmapNew 
	"gui.bitmap_new
	$LF
]h3
[blockquote 
	" Syntax: BITMAP gui.bitmap_new(number width, number height, 
	[b 
		"false
	]b
	")
	[br 
	]br
	$LF
	" Syntax: DBITMAP gui.bitmap_new(number width, number height, 
	[b 
		"true
	]b
	")
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[div class=p 
	"Returns a new bitmap of size 
	[b 
		"width
	]b
	" by 
	[b 
		"height
	]b
	".
	$LF
]div
[div class=p 
	"The third argument determines if the bitmap is indexed (false) or not (true).
	$LF
]div
[h3 id=GuiBitmapPset 
	"gui.bitmap_pset
	$LF
]h3
[blockquote 
	" Syntax: none gui.bitmap_pset(BITMAP/DBITMAP bmp, number x, number y, number c)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[div class=p 
	"Sets the pixel at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	") in bitmap 
	[b 
		"bmp
	]b
	" to color 
	[b 
		"c
	]b
	".
	$LF
]div
[div class=p 
	"The 
	[b 
		"c
	]b
	" is color index for indexed bitmaps and color for non-indexed ones.
	$LF
]div
[h3 id=GuiBitmapSize 
	"gui.bitmap_size
	$LF
]h3
[blockquote 
	" Syntax: (Number w, Number h) gui.bitmap_size(BITMAP/DBITMAP bmp)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[div class=p 
	"Returns the width (
	[b 
		"w
	]b
	") and height (
	[b 
		"h
	]b
	") of bitmap 
	[b 
		"bmp
	]b
	".
	$LF
]div
[h3 id=GuiBitmapBlit 
	"gui.bitmap_blit
	$LF
]h3
[blockquote 
	" Syntax: none gui.bitmap_blit(BITMAP target, number dx, number dy, BITMAP source, number sx, number sy, number w, number h, [number colorkey])
	[br 
	]br
	$LF
	" Syntax: none gui.bitmap_blit(DBITMAP target, number dx, number dy, DBITMAP source, number sx, number sy, number w, number h, [number colorkey])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
	[li 
		" 
		[b 
			"colorkey
		]b
		" defaults to NONE.
		$LF
	]li
]ul
[div class=p 
	"Blits region of size 
	[b 
		"w
	]b
	" by 
	[b 
		"h
	]b
	" starting from (
	[b 
		"sx
	]b
	",
	[b 
		"sy
	]b
	") from 
	[b 
		"source
	]b
	" to region starting from (
	[b 
		"dx
	]b
	",
	[b 
		"dy
	]b
	") in 
	[b 
		"target
	]b
	".
	$LF
]div
[div class=p 
	"If 
	[b 
		"colorkey
	]b
	" is specified, the pixels with that color are not blitted.
	$LF
]div
[div class=p 
	"Note that this copies pixels, not composites those. This matters when copying (partially) transparent regions.
	$LF
]div
[h3 id=GuiBitmapLoad 
	"gui.bitmap_load
	$LF
]h3
[blockquote 
	" Syntax: BITMAP/DBITMAP gui.bitmap_load(string filename)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere
		$LF
	]li
]ul
[div class=p 
	"Loads BITMAP or DBITMAP from file 
	[b 
		"filename
	]b
	" and returns the result.
	$LF
]div
[div class=p 
	"If the result is indexed or not depends on the file.
	$LF
]div
[h3 id=GuiRainbow 
	"gui.rainbow
	$LF
]h3
[blockquote 
	" Syntax: Number gui.rainbow(Number step, Number steps, Number base)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ6.
		$LF
	]li
	[li 
		" Can be used anywhere
		$LF
	]li
]ul
[div class=p 
	"Performs hue rotation on color 
	[b 
		"base
	]b
	".
	$LF
]div
[div class=p 
	"The rotation is 
	[b 
		"step
	]b
	"/
	[b 
		"steps
	]b
	" of full hue circle. The positive direction is red->yellow->green->cyan->blue->magenta->red.
	$LF
]div
[div class=p 
	"The rotation will preserve saturation, value and opacity.
	$LF
]div
[h2 id=HostmemoryFunctions 
	"Hostmemory functions
	$LF
]h2
[h3 id=Generic 
	"(Generic)
	$LF
]h3
[div class=p 
	"These read/write memory space that is preserved over saves and loads.
	$LF
]div
[div class=p 
	"All functions use little-endian byte order.
	$LF
]div
[div class=p 
	"The data types are:
	$LF
]div
[ul 
	[li 
		" byte (unspecified is byte) is 8 bits.
		$LF
	]li
	[li 
		" word is 16 bits.
		$LF
	]li
	[li 
		" dword is 32 bits.
		$LF
	]li
	[li 
		" qword is 64 bits.
		$LF
	]li
]ul
[h3 id=HostmemoryReadHostmemoryReadbyteHostmemoryReadwordHostmemoryReaddwordHostmemoryReadqword 
	"hostmemory.read / hostmemory.readbyte / hostmemory.readword / hostmemory.readdword / hostmemory.readqword
	$LF
]h3
[blockquote 
	" Syntax: Number hostmemory.read(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readbyte(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readdword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readqword(Number address)
	$LF
]blockquote
[div class=p 
	"Returns the unsigned value read from address 
	[b 
		"address
	]b
	" (or false if out of bounds). 
	$LF
]div
[h3 id=HostmemoryReadsbyteHostmemoryReadswordHostmemoryReadsdwordHostmemoryReadsqword 
	"hostmemory.readsbyte / hostmemory.readsword / hostmemory.readsdword / hostmemory.readsqword
	$LF
]h3
[blockquote 
	" Syntax: Number hostmemory.readsbyte(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readsword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readsdword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readsqword(Number address)
	$LF
]blockquote
[div class=p 
	"Returns the signed (two's complement) value read from address 
	[b 
		"address
	]b
	" (or false if out of bounds).
	$LF
]div
[h3 id=HostmemoryWriteHostmemoryWritebyteHostmemoryWritewordHostmemoryWritedwordHostmemoryWriteqword 
	"hostmemory.write / hostmemory.writebyte / hostmemory.writeword / hostmemory.writedword / hostmemory.writeqword
	$LF
]h3
[blockquote 
	" Syntax: Number hostmemory.write(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.writebyte(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.writeword(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.writedword(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.writeqword(Number address, Number value)
	$LF
]blockquote
[div class=p 
	"Writes the value 
	[b 
		"value
	]b
	" (two's complement if negative) to address 
	[b 
		"address
	]b
	" (extending memory if out of bounds).
	$LF
]div
[h2 id=InputFunctions 
	"Input functions
	$LF
]h2
[h3 id=Generic_2 
	"(Generic)
	$LF
]h3
[div class=p 
	"Unless otherwise noted, these are only valid in 
	[b 
		"on_input
	]b
	" callback.
	$LF
]div
[div class=p 
	"Physical controllers 0-3 are on port #1 and controllers 4-7 are on port #2.
	$LF
]div
[div class=p 
	"The control indices are:
	$LF
]div
[table 
	[tbody 
		[tr 
			[td 
				"Index
			]td
			[td 
				"SNES gamepad
			]td
			[td 
				"GB(C) gamepad
			]td
			[td 
				"mouse
			]td
			[td 
				"justifier
			]td
			[td 
				"superscope
			]td
		]tr
		[tr 
			[td 
				"0
			]td
			[td 
				"B
			]td
			[td 
				"A
			]td
			[td 
				"xaxis
			]td
			[td 
				"xaxis
			]td
			[td 
				"xaxis
			]td
		]tr
		[tr 
			[td 
				"1
			]td
			[td 
				"Y
			]td
			[td 
				"B
			]td
			[td 
				"yaxis
			]td
			[td 
				"yaxis
			]td
			[td 
				"yaxis
			]td
		]tr
		[tr 
			[td 
				"2
			]td
			[td 
				"select
			]td
			[td 
				"select
			]td
			[td 
				"L
			]td
			[td 
				"trigger
			]td
			[td 
				"trigger
			]td
		]tr
		[tr 
			[td 
				"3
			]td
			[td 
				"start
			]td
			[td 
				"start
			]td
			[td 
				"R
			]td
			[td 
				"start
			]td
			[td 
				"cursor
			]td
		]tr
		[tr 
			[td 
				"4
			]td
			[td 
				"up
			]td
			[td 
				"right
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"turbo
			]td
		]tr
		[tr 
			[td 
				"5
			]td
			[td 
				"down
			]td
			[td 
				"left
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"pause
			]td
		]tr
		[tr 
			[td 
				"6
			]td
			[td 
				"left
			]td
			[td 
				"up
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"7
			]td
			[td 
				"right
			]td
			[td 
				"down
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"8
			]td
			[td 
				"A
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"9
			]td
			[td 
				"X
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"10
			]td
			[td 
				"L
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"11
			]td
			[td 
				"R
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
	]tbody
]table
[h3 id=InputSet 
	"input.set
	$LF
]h3
[blockquote 
	" Syntax: none input.set(number controller, number index, number value)
	$LF
]blockquote
[ul 
	[li 
		" This function does nothing in read-only mode.
		$LF
	]li
]ul
[div class=p 
	"Set input on physical controller 
	[b 
		"controller
	]b
	" control index 
	[b 
		"index
	]b
	" to value 
	[b 
		"value
	]b
	".
	$LF
]div
[div class=p 
	"In case of buttons, zero is released, anything else is pressed.
	$LF
]div
[h3 id=InputGet 
	"input.get
	$LF
]h3
[blockquote 
	" Syntax: number input.get(number controller, number index)
	$LF
]blockquote
[div class=p 
	"Returns the value of physical controller 
	[b 
		"controller
	]b
	" input index 
	[b 
		"index
	]b
	".
	$LF
]div
[h3 id=InputReset 
	"input.reset
	$LF
]h3
[blockquote 
	" Syntax: none input.reset([number delay])
	$LF
]blockquote
[ul 
	[li 
		" Only valid in 
		[b 
			"on_input
		]b
		" callback with subframe flag clear.
		$LF
	]li
	[li 
		" 
		[b 
			"delay
		]b
		" defaults to 0.
		$LF
	]li
	[li 
		" Nonzero 
		[b 
			"delay
		]b
		" since rr1-Δ8.
		$LF
	]li
	[li 
		" This function does nothing in read-only mode.
		$LF
	]li
]ul
[div class=p 
	"Resets console. If 
	[b 
		"delay
	]b
	" is specified and delayed reset is supported, the reset will be delayed by that amount (but still at most one frame).
	$LF
]div
[h3 id=InputRaw 
	"input.raw
	$LF
]h3
[blockquote 
	" Syntax: table input.raw()
	$LF
]blockquote
[ul 
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[div class=p 
	"Returns a table of tables. The outer table is indexed by key name.
	$LF
]div
[div class=p 
	"The inner table has the following fields:
	$LF
]div
[ul 
	[li 
		" last_value: Raw value of input.
		$LF
	]li
]ul
[pre 
	" * For keys, this is 0 for released, 1 for pressed.
	$LF
	" * For mouse, this is coordinate relative to top left of draw area (note that this may be negative!).
	$LF
	" * For axis types, this is raw value of axis.
	$LF
	" * For hats, 1 is up, 2 is right, 4 is down, 8 is left. Diagonals are OR of primary directions.
	$LF
]pre
[ul 
	[li 
		" cal_left: Left/Top calibration limit.
		$LF
	]li
	[li 
		" cal_center: Center calibration value.
		$LF
	]li
	[li 
		" cal_right: Right/Bottom calibration limit.
		$LF
	]li
	[li 
		" cal_tolerance: Tolerance of button (the width of dead zone, 0<x<1).
		$LF
	]li
	[li 
		" ktype: The type of the key.
		$LF
	]li
]ul
[pre 
	" * disabled: Disabled axis.
	$LF
	" * key: Key
	$LF
	" * axis: Axis
	$LF
	" * axis-inverse: Axis (inverted).
	$LF
	" * hat: Hat
	$LF
	" * mouse: Mouse axis.
	$LF
	" * pressure-mp: Pressure-sensitive button, reads cal_left when released, cal_right when pressed.
	$LF
	" * pressure-m0: Pressure-sensitive button, reads cal_left when released, cal_center when pressed.
	$LF
	" * pressure-0m: Pressure-sensitive button, reads cal_center when released, cal_left when pressed.
	$LF
	" * pressure-0p: Pressure-sensitive button, reads cal_center when released, cal_right when pressed.
	$LF
	" * pressure-pm: Pressure-sensitive button, reads cal_right when released, cal_left when pressed.
	$LF
	" * pressure-p0: Pressure-sensitive button, reads cal_right when released, cal_center when pressed.
	$LF
]pre
[div class=p 
	"For mouse axes, cal_left is top/left edge of draw area, cal_center is top/left edge of game area, and cal_right is bottom/right edge of draw area.
	$LF
]div
[h3 id=InputKeyhook 
	"input.keyhook
	$LF
]h3
[blockquote 
	" Syntax: none input.keyhook(string key, boolean enabled)
	$LF
]blockquote
[ul 
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[div class=p 
	"If 
	[b 
		"enabled
	]b
	"=true, requests 
	[b 
		"on_keyhook
	]b
	" callback to happen when key 
	[b 
		"key
	]b
	" changes state.
	$LF
]div
[div class=p 
	"If 
	[b 
		"enabled
	]b
	"=false, requests that state changes on key 
	[b 
		"key
	]b
	" do not cause callbacks to 
	[b 
		"on_keyhook
	]b
	".
	$LF
]div
[h3 id=InputGeta 
	"input.geta
	$LF
]h3
[blockquote 
	" Syntax: Tuple input.geta(Number controller)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ5
		$LF
	]li
]ul
[div class=p 
	"Get all input indices of physical controller 
	[b 
		"controller
	]b
	" at once. The returned tuple is in control index order.
	$LF
]div
[h3 id=InputSeta 
	"input.seta
	$LF
]h3
[blockquote 
	" Syntax: none input.seta(Number controller, Number values...)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ5
		$LF
	]li
]ul
[div class=p 
	"Set all input indices of physical controller 
	[b 
		"controller
	]b
	" at once. The 
	[b 
		"value
	]b
	"s are in control index order.
	$LF
]div
[h3 id=InputJoyget 
	"input.joyget
	$LF
]h3
[blockquote 
	" Syntax: table input.joyget(Number controller)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ15
		$LF
	]li
]ul
[div class=p 
	"Returns a table, indexes by control name containing state of logical controller 
	[b 
		"controller
	]b
	".
	$LF
]div
[h3 id=InputJoyset 
	"input.joyset
	$LF
]h3
[blockquote 
	" Syntax: none input.joyset(Number controller, table state)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ14ε1
		$LF
	]li
]ul
[div class=p 
	"Set state of logical controller 
	[b 
		"controller
	]b
	" to 
	[b 
		"state
	]b
	". The 
	[b 
		"state
	]b
	" is indexed by control name.
	$LF
]div
[div class=p 
	"For buttons, nil/false is released, anything else is pressed (normal lua boolean rules).
	$LF
]div
[h2 id=MemoryFunctions 
	"Memory functions
	$LF
]h2
[h3 id=Generic_3 
	"(Generic)
	$LF
]h3
[div class=p 
	"These functions read/write console memory space.
	$LF
]div
[div class=p 
	"The byte order used depends on the target address. Normally it is little-endian, but DSP memory is host-endian.
	$LF
]div
[div class=p 
	"The data types are:
	$LF
]div
[ul 
	[li 
		" byte (unspecified is byte) is 8 bits.
		$LF
	]li
	[li 
		" word is 16 bits.
		$LF
	]li
	[li 
		" dword is 32 bits.
		$LF
	]li
	[li 
		" qword is 64 bits.
		$LF
	]li
]ul
[h3 id=MemoryReadMemoryReadbyteMemoryReadwordMemoryReaddwordMemoryReadqword 
	"memory.read / memory.readbyte / memory.readword / memory.readdword / memory.readqword
	$LF
]h3
[blockquote 
	" Syntax: Number memory.read(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readbyte(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readdword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readqword(Number address)
	$LF
]blockquote
[div class=p 
	"Returns the unsigned value read from address 
	[b 
		"address
	]b
	" (out of bounds bytes read as zeroes).
	$LF
]div
[h3 id=MemoryReadsbyteMemoryReadswordMemoryReadsdwordMemoryReadsqword 
	"memory.readsbyte / memory.readsword / memory.readsdword / memory.readsqword
	$LF
]h3
[blockquote 
	" Syntax: Number memory.readsbyte(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readsword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readsdword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readsqword(Number address)
	$LF
]blockquote
[div class=p 
	"Returns the signed (two's complement) value read from address 
	[b 
		"address
	]b
	" (out of bounds bytes read as zeroes).
	$LF
]div
[h3 id=MemoryWriteMemoryWritebyteMemoryWritewordMemoryWritedwordMemoryWriteqword 
	"memory.write / memory.writebyte / memory.writeword / memory.writedword / memory.writeqword
	$LF
]h3
[blockquote 
	" Syntax: None memory.write(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: None memory.writebyte(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: None memory.writeword(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: None memory.writedword(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: None memory.writeqword(Number address, Number value)
	$LF
]blockquote
[div class=p 
	"Writes the value 
	[b 
		"value
	]b
	" (two's complement if negative) to address 
	[b 
		"address
	]b
	" (writes out of bounds are ignored).
	$LF
]div
[h3 id=MemoryMapbyteMemoryMapsbyteMemoryMapwordMemoryMapswordMemoryMapdwordMemoryMapsdwordMemoryMapqwordMemoryMapsqword 
	"memory.mapbyte / memory.mapsbyte / memory.mapword / memory.mapsword / memory.mapdword / memory.mapsdword / memory.mapqword / memory.mapsqword
	$LF
]h3
[blockquote 
	" Syntax: Table memory.map<type>()
	[br 
	]br
	$LF
	" Syntax: Table memory.map<type>(Number base, Number aperturesize)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ15ε2
		$LF
	]li
]ul
[div class=p 
	"Map area of size 
	[b 
		"aperturesize
	]b
	" starting from 
	[b 
		"base
	]b
	" (the entire map space if not specified) with specified type.
	$LF
]div
[div class=p 
	"The returned table can be read/written to read/write console memory space.
	$LF
]div
[div class=p 
	"The index values to this table are measured in bytes.
	$LF
]div
[h3 id=MemoryMapStructure 
	"memory.map_structure()
	$LF
]h3
[blockquote 
	" Syntax: MAP_STRUCTURE memory.map_structure()
	[br 
	]br
	$LF
	" Syntax: none MAP_STRUCTURE(String field, Number address, String type)
	[br 
	]br
	$LF
	" Syntax: MAP_STRUCTURE:<field>
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ15ε2
		$LF
	]li
]ul
[div class=p 
	"Returns an object that works like a structure that maps console memory variables as fields.
	$LF
]div
[div class=p 
	"On call to object, the field 
	[b 
		"field
	]b
	" is mapped to memory address 
	[b 
		"address
	]b
	" (with type 
	[b 
		"type
	]b
	", which can be "byte", "sbyte", "word", "sword", "dword", "sdword", "qword" or "sqword").
	$LF
]div
[h3 id=MemoryVmaCount 
	"memory.vma_count
	$LF
]h3
[blockquote 
	" Syntax: number memory.vma_count()
	$LF
]blockquote
[div class=p 
	"Returns the number of VMAs active.
	$LF
]div
[h3 id=MemoryReadVma 
	"memory.read_vma
	$LF
]h3
[blockquote 
	" Syntax: Table/Nil memory.read_vma(Number vma)
	$LF
]blockquote
[div class=p 
	"Returns a table (Nil if index is out of range) about 
	[b 
		"vma
	]b
	"th VMA (zero-based).
	$LF
]div
[div class=p 
	"The returned table has the following fields:
	$LF
]div
[ul 
	[li 
		" region_name: Readable name of region
		$LF
	]li
	[li 
		" baseaddr: Starting address of region.
		$LF
	]li
	[li 
		" size: Size of region in bytes.
		$LF
	]li
	[li 
		" lastaddr: Last address belonging to the region.
		$LF
	]li
	[li 
		" readonly: True if VMA is read-only, false if VMA is writable.
		$LF
	]li
	[li 
		" native_endian: True if VMA is native-endian, false if little-endian.
		$LF
	]li
]ul
[div class=p 
	"Invalid VMA index causes nil to be returned.
	$LF
]div
[h3 id=MemoryFindVma 
	"memory.find_vma
	$LF
]h3
[blockquote 
	" Syntax: Table/Nil memory.find_vma(Number address)
	$LF
]blockquote
[div class=p 
	"Return the information (the same table as returned by memory.read_vma) about the VMA where address 
	[b 
		"address
	]b
	" belongs to.
	$LF
]div
[div class=p 
	"If the address 
	[b 
		"address
	]b
	" is not covered by any VMA, returns nil.
	$LF
]div
[h3 id=MemoryHashState 
	"memory.hash_state
	$LF
]h3
[blockquote 
	" Syntax: String memory.hash_state()
	$LF
]blockquote
[div class=p 
	"Return hash (hexadecimal) of state of the entire system. Mainly useful for debugging core savestate code.
	$LF
]div
[h3 id=MemoryHashRegion 
	"memory.hash_region
	$LF
]h3
[blockquote 
	" Syntax: String memory.hash_region(Number base, Number size)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ8
		$LF
	]li
]ul
[div class=p 
	"Returns the SHA-256 hash (hexadecimal) of the contents of memory in region of size 
	[b 
		"size
	]b
	" starting from 
	[b 
		"base
	]b
	".
	$LF
]div
[h3 id=MemoryReadregion 
	"memory.readregion
	$LF
]h3
[blockquote 
	" Syntax: Table memory.readregion(Number base, Number size)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ15ε2
		$LF
	]li
]ul
[div class=p 
	"Returns a table (zero-based) containing the byte values of memory region of size 
	[b 
		"size
	]b
	" starting from 
	[b 
		"base
	]b
	".
	$LF
]div
[div class=p 
	"Note that behavior is undefined if the specified range crosses a VMA boundary.
	$LF
]div
[h3 id=MemoryWriteregion 
	"memory.writeregion
	$LF
]h3
[blockquote 
	" Syntax: None memory.writeregion(Number base, Number size, Table data)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ15ε2
		$LF
	]li
]ul
[div class=p 
	"Writes contents of tabe 
	[b 
		"data
	]b
	" (zero-based) as byte values to memory region of size 
	[b 
		"size
	]b
	" starting from 
	[b 
		"base
	]b
	".
	$LF
]div
[div class=p 
	"Note that behavior is undefined if the specified range crosses a VMA boundary.
	$LF
]div
[h2 id=MovieFunctions 
	"Movie functions
	$LF
]h2
[h3 id=MovieCurrentframe 
	"movie.currentframe
	$LF
]h3
[blockquote 
	" Syntax: Number movie.currentframe()
	$LF
]blockquote
[div class=p 
	"Returns the current frame number. 
	$LF
]div
[h3 id=MovieFramecount 
	"movie.framecount
	$LF
]h3
[blockquote 
	" Syntax: Number movie.framecount()
	$LF
]blockquote
[div class=p 
	"Returns the number of frames in movie.
	$LF
]div
[h3 id=MovieReadonly 
	"movie.readonly
	$LF
]h3
[blockquote 
	" Syntax: Boolean movie.readonly()
	$LF
]blockquote
[div class=p 
	"Returns true in readonly mode, otherwise false.
	$LF
]div
[h3 id=MovieReadwrite 
	"movie.readwrite
	$LF
]h3
[blockquote 
	" Syntax: none movie.readwrite()
	$LF
]blockquote
[div class=p 
	"Set readwrite mode.
	$LF
]div
[div class=p 
	"Note: Does not trigger callback to 
	[b 
		"on_readwrite
	]b
	".
	$LF
]div
[h3 id=MovieFrameSubframes 
	"movie.frame_subframes
	$LF
]h3
[blockquote 
	" Syntax: Number movie.frame_subframes(Number frame)
	$LF
]blockquote
[div class=p 
	"Returns the number of subframes in frame 
	[b 
		"frame
	]b
	".
	$LF
]div
[h3 id=MovieReadSubframes 
	"movie.read_subframes
	$LF
]h3
[blockquote 
	" Syntax: Table movie.read_subframes(Number frame, Number subframe)
	$LF
]blockquote
[div class=p 
	"Reads subframe 
	[b 
		"subframe
	]b
	" (0-based) of frame 
	[b 
		"frame
	]b
	".
	$LF
]div
[div class=p 
	"Return value is a table with numeric indices:
	$LF
]div
[ul 
	[li 
		" 0: Frame sync flag.
		$LF
	]li
	[li 
		" 1: Reset flag.
		$LF
	]li
	[li 
		" 2: Delay field low (units of 0).
		$LF
	]li
	[li 
		" 3: Delay field high (units of 10000)
		$LF
	]li
	[li 
		" 4-99: Controller buttons/axes.
		$LF
	]li
]ul
[div class=p 
	"The index i of controller c is at table index 12 * c + i + 4.
	$LF
]div
[div class=p 
	"Buttons/flags read as 0 (released, not set) or 1 (pressed, set).
	$LF
]div
[h3 id=MovieReadRtc 
	"movie.read_rtc
	$LF
]h3
[blockquote 
	" Syntax: (Number seconds, Number sseconds) movie.read_rtc()
	$LF
]blockquote
[div class=p 
	"Returns the current RTC time. 
	[b 
		"seconds
	]b
	" is in whole seconds (since 19700101T000000Z) and 
	[b 
		"sseconds
	]b
	" is  subsecond ticks (32040.5*768 per second for SNES, 32768*64 per second for second for GB(C)) in second.
	$LF
]div
[h3 id=MovieUnsafeRewind 
	"movie.unsafe_rewind
	$LF
]h3
[blockquote 
	" Syntax: none movie.unsafe_rewind()
	$LF
	" Syntax: none movie.unsafe_rewind(UNSAFEREWIND r)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ9.
		$LF
	]li
]ul
[div class=p 
	"If called without parameters, triggers call to 
	[b 
		"on_set_rewind
	]b
	" with state.
	$LF
]div
[div class=p 
	"If called with parameter 
	[b 
		"r
	]b
	", rewinds to that state.
	$LF
]div
[div class=p 
	"The state rewinded must be in past or the results are undefined.
	$LF
]div
[h3 id=MovieRerecords 
	"movie.rerecords
	$LF
]h3
[blockquote 
	" Syntax: Number movie.rerecords()
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ14.
		$LF
	]li
]ul
[div class=p 
	"Returns the current rerecord count.
	$LF
]div
[h2 id=SettingsFunctions 
	"Settings functions
	$LF
]h2
[h3 id=Generic_4 
	"(Generic)
	$LF
]h3
[div class=p 
	"On failure, the first return value is nil and the second is error message.
	$LF
]div
[h3 id=SettingsSet 
	"settings.set
	$LF
]h3
[blockquote 
	" Syntax: true settings.set(String name, String value)
	$LF
]blockquote
[div class=p 
	"Sets setting 
	[b 
		"name
	]b
	" to value 
	[b 
		"value
	]b
	". 
	$LF
]div
[h3 id=SettingGet 
	"setting.get
	$LF
]h3
[blockquote 
	" Syntax: String/false settings.get(String name)
	$LF
]blockquote
[div class=p 
	"Reads setting 
	[b 
		"name
	]b
	". Returns value or false if setting is not set.
	$LF
]div
[h3 id=SettingBlank 
	"setting.blank
	$LF
]h3
[blockquote 
	" Syntax: true setting.blank(String name)
	$LF
]blockquote
[div class=p 
	"Blanks setting 
	[b 
		"name
	]b
	". Returns true on success.
	$LF
]div
[h3 id=SettingIsSet 
	"setting.is_set
	$LF
]h3
[blockquote 
	" Syntax: boolean setting.is_set(String name)
	$LF
]blockquote
[div class=p 
	"Checks if setting 
	[b 
		"name
	]b
	" is set. Returns true if it is, false if it isn't.
	$LF
]div
[h2 id=MiscFunctions 
	"Misc. functions
	$LF
]h2
[h3 id=Exec 
	"exec
	$LF
]h3
[blockquote 
	" Syntax: none exec(String cmd)
	$LF
]blockquote
[div class=p 
	"Invokes emulator command 
	[b 
		"cmd
	]b
	".
	$LF
]div
[h3 id=Print 
	"print
	$LF
]h3
[blockquote 
	" Syntax: none print(...)
	$LF
]blockquote
[div class=p 
	"Print value(s)
	$LF
]div
[div class=p 
	"Prints values of all arguments (note: Table, function, thread, light userdata and userdata values can't be printed). The arguments are printed separated by tabs.
	$LF
]div
[h3 id=Utime 
	"utime
	$LF
]h3
[blockquote 
	" Syntax: (Number secs, Number usecs) utime()
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[div class=p 
	"Return the current time. 
	[b 
		"secs
	]b
	" is the number of seconds since 19700101T000000Z. 
	[b 
		"usecs
	]b
	" is the number of microseconds within second.
	$LF
]div
[h3 id=EmulatorReady 
	"emulator_ready
	$LF
]h3
[blockquote 
	" Syntax: boolean emulator_ready()
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[div class=p 
	"Returns true if on_startup has already been called, false otherwise.
	$LF
]div
[h3 id=SetIdleTimeout 
	"set_idle_timeout
	$LF
]h3
[blockquote 
	" Syntax: none set_idle_timeout(Number microsecs)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[div class=p 
	"After 
	[b 
		"microsecs
	]b
	" microseconds have passed and the emulator is idle, call the on_idle callback.
	$LF
]div
[h3 id=SetTimerTimeout 
	"set_timer_timeout
	$LF
]h3
[blockquote 
	" Syntax: none set_timer_timeout(Number microsecs)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[div class=p 
	"After 
	[b 
		"microsecs
	]b
	" microseconds have passed, call the on_timer callback.
	$LF
]div
[h3 id=BusAddress 
	"bus_address
	$LF
]h3
[blockquote 
	" Syntax: Number bus_address(Number address)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ10.
		$LF
	]li
]ul
[div class=p 
	"Returns the map address corresponding to address 
	[b 
		"address
	]b
	" on physical console bus.
	$LF
]div
[div class=p 
	"Currently only supported for SNES & co.
	$LF
]div
[h3 id=Loopwrapper 
	"loopwrapper(
	$LF
]h3
[blockquote 
	" Syntax: Function loopwrapper(Function fn, ...)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ14ε1
		$LF
	]li
]ul
[div class=p 
	"First calls function 
	[b 
		"fn
	]b
	" with function suspending the execution of the function when called and any remaining arguments.
	$LF
]div
[div class=p 
	"When the function calls the suspend function, loopwrapper returns function that will resume 
	[b 
		"fn
	]b
	" when called.
	$LF
]div
[div class=p 
	"The suspend function returns the values passed to resume function as parameters.
	$LF
]div
[div class=p 
	"This is handy for using functions that have internal loops, that need to run over a long time, as callbacks.
	$LF
]div
[h2 id=Callbacks 
	"Callbacks
	$LF
]h2
[h3 id=Generic_5 
	"(Generic)
	$LF
]h3
[div class=p 
	"These all are defined by Lua scripts.
	$LF
]div
[div class=p 
	"Return fast from these hooks or the performance suffers. Not returning at all locks up the emulator.
	$LF
]div
[h3 id=OnPaint 
	"on_paint
	$LF
]h3
[div class=p 
	"Called when screen is rerendered. Any draw primitives here affect the drawn screen.
	$LF
]div
[div class=p 
	"Parameter: boolean non_synthetic
	$LF
]div
[div class=p 
	[b 
		"non_synthetic
	]b
	" is true if 
	[b 
		"on_paint
	]b
	" is triggered by actual frame from console or by a subframe (if requested). It is false for calls triggered by gui.request_paint().
	$LF
]div
[h3 id=OnVideo 
	"on_video
	$LF
]h3
[div class=p 
	"Called when video frame is rendered. Any draw primitives here affect dumped video frame.
	$LF
]div
[ul 
	[li 
		" May be called multiple times per frame if multiple dumpers are active.
		$LF
	]li
	[li 
		" SDMP dumper does not call this.
		$LF
	]li
]ul
[h3 id=OnInput 
	"on_input
	$LF
]h3
[div class=p 
	"Called when input for frame is decided. May change the input in readwrite mode.
	$LF
]div
[div class=p 
	"Parameter: boolean subframe
	$LF
]div
[div class=p 
	[b 
		"subframe
	]b
	" is true if this is in response to subframe. Otherwise false.
	$LF
]div
[h3 id=OnReset 
	"on_reset
	$LF
]h3
[div class=p 
	"Called when console resets.
	$LF
]div
[h3 id=OnFrame 
	"on_frame
	$LF
]h3
[div class=p 
	"Called after frame has completed (after 
	[b 
		"on_paint
	]b
	")
	$LF
]div
[h3 id=OnReadwrite 
	"on_readwrite
	$LF
]h3
[div class=p 
	"Called when entering readwrite mode.
	$LF
]div
[h3 id=OnStartup 
	"on_startup
	$LF
]h3
[div class=p 
	"Called when the emulator starts up.
	$LF
]div
[h3 id=OnPreLoad 
	"on_pre_load
	$LF
]h3
[ul 
	[li 
		" Parameter #1: String savename
		$LF
	]li
]ul
[div class=p 
	"Called before loading a savestate or movie.
	$LF
]div
[div class=p 
	"Parameter: String 
	[b 
		"name
	]b
	$LF
]div
[div class=p 
	"The name of savestate or movie to load is passed as 
	[b 
		"name
	]b
	".
	$LF
]div
[h3 id=OnErrLoad 
	"on_err_load
	$LF
]h3
[div class=p 
	"Called if loading savestate or movie failed.
	$LF
]div
[div class=p 
	"Parameter: String 
	[b 
		"name
	]b
	$LF
]div
[div class=p 
	"The name of savestate or movie attempted to load is passed as 
	[b 
		"name
	]b
	".
	$LF
]div
[h3 id=OnPostLoad 
	"on_post_load
	$LF
]h3
[div class=p 
	"Called if loading savestate or movie succeeded.
	$LF
]div
[ul 
	[li 
		" Parameter: String name
		$LF
	]li
	[li 
		" Parameter: boolean is_state.
		$LF
	]li
]ul
[div class=p 
	"The name of savestate/movie is 
	[b 
		"name
	]b
	". 
	[b 
		"is_state
	]b
	" is true if savestate, false for movies.
	$LF
]div
[h3 id=OnPreSave 
	"on_pre_save
	$LF
]h3
[div class=p 
	"Called before saving savestate or movie (except if movie save was requested from Lua).
	$LF
]div
[ul 
	[li 
		" Parameter: String name
		$LF
	]li
	[li 
		" Parameter: boolean is_state.
		$LF
	]li
]ul
[div class=p 
	[b 
		"name
	]b
	" is the name of savestate or movie. 
	[b 
		"is_state
	]b
	" is true if this is savestate, false if movie.
	$LF
]div
[h3 id=OnErrSave 
	"on_err_save
	$LF
]h3
[div class=p 
	"Called if saving savestate or movie failed (except if movie save was requested from Lua).
	$LF
]div
[ul 
	[li 
		" Parameter: String name
		$LF
	]li
]ul
[div class=p 
	[b 
		"name
	]b
	" is the name of savestate or movie that failed to save.
	$LF
]div
[h3 id=OnPostSave 
	"on_post_save
	$LF
]h3
[div class=p 
	"Called if saving savestate or movie succeeded (except if movie save was requested from Lua).
	$LF
]div
[ul 
	[li 
		" Parameter: String name
		$LF
	]li
	[li 
		" Parameter: boolean is_state.
		$LF
	]li
]ul
[div class=p 
	[b 
		"name
	]b
	" is the name of savestate or movie. 
	[b 
		"is_state
	]b
	" is true if this is savestate, false if movie.
	$LF
]div
[h3 id=OnSnoop 
	"on_snoop
	$LF
]h3
[div class=p 
	"Called just before answering a poll from emulator core. Can't alter the result.
	$LF
]div
[ul 
	[li 
		" Parameter: number port
		$LF
	]li
	[li 
		" Parameter: number controller
		$LF
	]li
	[li 
		" Parameter: number index
		$LF
	]li
	[li 
		" Parameter: number value.
		$LF
	]li
]ul
[div class=p 
	"The poll is for port 
	[b 
		"port
	]b
	", controller 
	[b 
		"controller
	]b
	", control index 
	[b 
		"index
	]b
	" and the value to be returned is 
	[b 
		"value
	]b
	".
	$LF
]div
[h3 id=OnQuit 
	"on_quit
	$LF
]h3
[div class=p 
	"Called just before the emulator quits.
	$LF
]div
[h3 id=OnKeyhook 
	"on_keyhook
	$LF
]h3
[div class=p 
	"Called if status of key has changed (and callbacks have been requested for that key).
	$LF
]div
[ul 
	[li 
		" Parameter: String key
		$LF
	]li
	[li 
		" Parameter: Table state
		$LF
	]li
]ul
[div class=p 
	"The key state change is for is 
	[b 
		"key
	]b
	". 
	[b 
		"state
	]b
	" is state table, in the same format  as the inner tables of input.raw.
	$LF
]div
[h3 id=OnSetRewind 
	"on_set_rewind
	$LF
]h3
[div class=p 
	"Called when unsafe rewind point has been set up.
	$LF
]div
[ul 
	[li 
		" Parameter: UNSAFEREWIND state
		$LF
	]li
]ul
[div class=p 
	"The state object is passed as 
	[b 
		"state
	]b
	".
	$LF
]div
[h3 id=OnPreRewind 
	"on_pre_rewind
	$LF
]h3
[div class=p 
	"Called just before unsafe rewind occurs.
	$LF
]div
[h3 id=OnPostRewind 
	"on_post_rewind
	$LF
]h3
[div class=p 
	"Called just after unsafe rewind has occured.
	$LF
]div
[h3 id=OnFrameEmulated 
	"on_frame_emulated
	$LF
]h3
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[div class=p 
	"Called just after frame emulation finishes, but before 
	[b 
		"on_paint
	]b
	".
	$LF
]div
[h3 id=OnIdle 
	"on_idle
	$LF
]h3
[div class=p 
	"Called when the specified idle timeout expires and the emulator is idle.
	$LF
]div
[h3 id=OnTimer 
	"on_timer
	$LF
]h3
[div class=p 
	"Called when the specified timer timeout expires.
	$LF
]div
