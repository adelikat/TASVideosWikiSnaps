4
[div class=toc 
	[ul 
		[li 
			[ul 
				[li 
					[a href=#heading-6669 
						" Main Window
						$LF
					]a
				]li
				[li 
					[ul 
						[li 
							[a href=#heading-6670 
								" Frames per second
								$LF
							]a
						]li
						[li 
							[a href=#heading-6671 
								" System Time
								$LF
							]a
						]li
					]ul
				]li
				[li 
					[a href=#heading-6672 
						" File
						$LF
					]a
				]li
				[li 
					[ul 
						[li 
							[a href=#heading-6673 
								" Executable Options
								$LF
							]a
						]li
					]ul
				]li
				[li 
					[a href=#heading-6674 
						" Movie
						$LF
					]a
				]li
				[li 
					[ul 
						[li 
							[a href=#heading-6675 
								" Annotations
								$LF
							]a
						]li
						[li 
							[a href=#heading-6676 
								" Autosave
								$LF
							]a
						]li
						[li 
							[a href=#heading-6677 
								" Auto-restart game (since v1.3.3)
								$LF
							]a
						]li
						[li 
							[a href=#heading-6678 
								" Input Editor
								$LF
							]a
						]li
					]ul
				]li
				[li 
					[a href=#heading-6679 
						" Video
						$LF
					]a
				]li
				[li 
					[ul 
						[li 
							[a href=#heading-6680 
								" Virtual screen resolution
								$LF
							]a
						]li
						[li 
							[a href=#heading-6681 
								" Force software rendering
								$LF
							]a
						]li
						[li 
							[a href=#heading-6682 
								" Add performance flags to software rendering
								$LF
							]a
						]li
						[li 
							[a href=#heading-6683 
								" On-screen Display (OSD)
								$LF
							]a
						]li
					]ul
				]li
				[li 
					[a href=#heading-6684 
						" Runtime
						$LF
					]a
				]li
				[li 
					[ul 
						[li 
							[a href=#heading-6685 
								" Time tracking
								$LF
							]a
						]li
						[li 
							[a href=#heading-6686 
								" Savestates
								$LF
							]a
						]li
						[li 
							[a href=#heading-6687 
								" Save screen
								$LF
							]a
						]li
						[li 
							[a href=#heading-6688 
								" Backup savefiles in memory
								$LF
							]a
						]li
						[li 
							[a href=#heading-6689 
								" Recycle threads
								$LF
							]a
						]li
						[li 
							[a href=#heading-6690 
								" Virtual Steam client
								$LF
							]a
						]li
						[li 
							[a href=#heading-6691 
								" Debug
								$LF
							]a
						]li
					]ul
				]li
				[li 
					[a href=#heading-6692 
						" Tools
						$LF
					]a
				]li
				[li 
					[ul 
						[li 
							[a href=#heading-6693 
								" Configure Encode
								$LF
							]a
						]li
						[li 
							[a href=#heading-6694 
								" Ram Search
								$LF
							]a
						]li
						[li 
							[a href=#heading-6695 
								" Ram Watch
								$LF
							]a
						]li
					]ul
				]li
				[li 
					[a href=#heading-6696 
						" Input
						$LF
					]a
				]li
				[li 
					[ul 
						[li 
							[a href=#heading-6697 
								" Recalibrate mouse position
								$LF
							]a
						]li
					]ul
				]li
			]ul
		]li
	]ul
]div
[h3 
	" Main Window
	$LF
	[a id=heading-6669 
	]a
]h3
[h4 
	" Frames per second
	$LF
	[a id=heading-6670 
	]a
]h4
[p 
	"You have to set a fps number prior to running a game. Many games accept any value and rely on the vsync parameter to either have to game running at fixed fps depending on the screen framerate, or uncapped fps. In this case, you can set the value you want, and libtas will simulate an activated vsync with the corresponding framerate. It means that the time will advance by exactly 1/fps seconds after each screen draw.
	$LF
]p
[p 
	"Some games are build with a constant framerate in mind, and setting another fps value will trigger abnormal results (like duplicate frames). In this case, it is possible to guess the intended game framerate by checking 
	[tt 
		"Runtime > Debug > Uncontrolled time
	]tt
	". This will deactivate the deterministic timer, meaning that the game will access the real system time. Then, you can run the game and look at the obtained fps value. This mode is not meant to be used for TASing, because it makes inputs recording non-deterministic.
	$LF
]p
[h4 
	" System Time
	$LF
	[a id=heading-6671 
	]a
]h4
[p 
	"The System Time is the time that is accessed by the game. It can be set before starting the game to have different starting times. Because system time is often use as a seed to a random number generator, setting this value can affect the random behaviors in the game. This is why initial system time is stored in movie files. When the game has started, this value shows the current time that the game has access to.
	$LF
]p
[h3 
	" File
	$LF
	[a id=heading-6672 
	]a
]h3
[h4 
	" Executable Options
	$LF
	[a id=heading-6673 
	]a
]h4
[p 
	"When the game requires to be run from a specific working directory, the 
	[tt 
		"Run path
	]tt
	" field must be set to that directory. Also, if the game is bundled with its own shared libraries, you probably want to add that library directory path to 
	[tt 
		"Library path
	]tt
	" field
	$LF
]p
[h3 
	" Movie
	$LF
	[a id=heading-6674 
	]a
]h3
[h4 
	" Annotations
	$LF
	[a id=heading-6675 
	]a
]h4
[p 
	"Movies can require specific instructions to run, such as a specific game version, additional libraries, game options, libTAS options, etc. Please provide such instructions inside this field to help other people playing back your movie.
	$LF
]p
[h4 
	" Autosave
	$LF
	[a id=heading-6676 
	]a
]h4
[p 
	"Opens a window to enable or disable autosaving. When enabled, the movie is saved when a certain time has passed, and when the user advanced a certain number of frames. Autosave movies are stored in 
	[tt 
		"~/.libtas/movie/
	]tt
	". Also, old autosave movies are deleted as new ones are created.
	$LF
]p
[h4 
	" Auto-restart game (since v1.3.3)
	$LF
	[a id=heading-6677 
	]a
]h4
[p 
	"When this option is enabled, if the game is closed while recording or playing a movie, then it is automatically restarted and the movie recording/playback is resumed. It works if the game closes by itself, or if the user pressed inputs that result in the game closing (like going to the menu and exit game). This does 
	[b 
		"not
	]b
	" work if the user closes the game window, because it is not an input inside the game, but an input of the window manager. In that case, you have to use the 
	[tt 
		"restart
	]tt
	" input, which sends a 
	[tt 
		"quit
	]tt
	" event to the game and makes libTAS restart the game. This input is like any input, it must be mapped in the input mapping configuration.
	$LF
]p
[h4 
	" Input Editor
	$LF
	[a id=heading-6678 
	]a
]h4
[p 
	"Opens a window showing the inputs of the playing movie. The first column shows the slot of the savestate if there is one at that frame. The second column shows the frame number and each subsequent column indicates the value of each single input present in the movie. For binary inputs (keys, mouse buttons, controller buttons), each cell indicates if that input was pressed at the corresponding frame, and it is possible to toggle that input by left-clicking on it. For analog inputs (mouse coordinates, controller axes), each cell indicates the value of the input at the corresponding frame, and it is possible to modify the value by double-clicking on it. It is not possible to edit an input before the current frame (past inputs).
	$LF
]p
[p 
	"It is possible to change the label of an input, or to add an input column by right-clicking on a column header. Also, right-clicking on a cell provides several options to the user.
	$LF
]p
[p 
	"When the input editor is opened, the savestates work a bit differently. When in recording mode, if you load a savestate, it will load the entire movie even past the current frame of the savestate.
	$LF
]p
[h3 
	" Video
	$LF
	[a id=heading-6679 
	]a
]h3
[h4 
	" Virtual screen resolution
	$LF
	[a id=heading-6680 
	]a
]h4
[p 
	"This option simulates a monitor that only supports the specified resolution, so that games may conform with this setting and display at the specified resolution. This is useful to encode movies at a higher resolution than the monitor resolution. This doesn't work for all games.
	$LF
]p
[h4 
	" Force software rendering
	$LF
	[a id=heading-6681 
	]a
]h4
[p 
	"This option force the OpenGL device driver Mesa 3D to use its software implementation of OpenGL (llvmpipe) to run the game. While this makes the game much slower, it is usually required to be able to use savestates. Indeed, the state of the GPU cannot be easily accessed and stored into savestates by the tool, thus savestates are incomplete and may crash the game. When using Mesa's software implementation, all of the graphic pipeline is done by the cpu and can be stored in the savestate.
	$LF
]p
[p 
	"You must be using Mesa 3D to be able to use this option, which usually means that you must be using the free driver for you GPU (e.g. 
	[tt 
		"nouveau
	]tt
	" for nvidia GPUs or 
	[tt 
		"radeon
	]tt
	" for ATI/AMD CPUs)
	$LF
]p
[h4 
	" Add performance flags to software rendering
	$LF
	[a id=heading-6682 
	]a
]h4
[p 
	"When software rendering is on, you can check some performance flags for llvmpipe driver to skip some steps in the rendering pipeline, which can gives a small performance boost.
	$LF
]p
[h4 
	" On-screen Display (OSD)
	$LF
	[a id=heading-6683 
	]a
]h4
[p 
	"Displays some information on the game screen such as framecount, inputs, notifications and ram watches. The placement of those texts can be modified, and can be displayed in the encode video.
	$LF
]p
[h3 
	" Runtime
	$LF
	[a id=heading-6684 
	]a
]h3
[h4 
	" Time tracking
	$LF
	[a id=heading-6685 
	]a
]h4
[p 
	"Some game expects, at some point, the time to advance, and wait in a loop, querying the time constantly until the time has advanced enough. However, we only advance time during a frame boundary, triggered by a screen display call. To avoid this softlock, we can let the time advance after a threshold number of calls from the same time-querying function. Checking functions in 
	[tt 
		"Main thread
	]tt
	" affects sync, but the game should run deterministically. However, checking functions in 
	[tt 
		"Secondary threads
	]tt
	" is making the game non-deterministic.
	$LF
]p
[h4 
	" Savestates
	$LF
	[a id=heading-6686 
	]a
]h4
[p 
	"The 
	[tt 
		"Incremental savestates
	]tt
	" option allows to take advantage of the recent 
	[a class=extlink href=https://lwn.net/Articles/546966 rel=nofollow 
		"soft-dirty bit
	]a
	" pushed by 
	[a class=extlink href=https://criu.org rel=nofollow 
		"CRIU
	]a
	" project, which can track which memory pages have been written to. When the first savestate is triggered, a complete memory dump is performed (like a regular savestate), but the soft-dirty bit is cleared. If another savestate is performed, only the memory pages that were modified since are saved, leading to lightweight savestates. However, to be effective, this option requires the user to make the first savestate as late as possible. The tool detects at startup if this feature is available on the system, and disables the option if not.
	$LF
]p
[p 
	"It is also possible to store savestates in RAM. This is good for users that don't have an SSD, but no check is performed if there is enough remaining memory when savestating.
	$LF
]p
[p 
	"The third option 
	[tt 
		"Backtrack savestate
	]tt
	" (since v1.3.3) make the game save a state each time savestates are invalidated by a thread creation or destruction. This state can be loaded with 
	[tt 
		"F10
	]tt
	" (by default). It allows used to get back to the earliest frame that is available.
	$LF
]p
[h4 
	" Save screen
	$LF
	[a id=heading-6687 
	]a
]h4
[p 
	"This setting controls the option of storing the game screen in memory. It unlocks a few features:
	$LF
]p
[ul 
	[li 
		" When doing a savestate, the game screen is stored inside it. When the savestate is loaded, the game screen is refreshed with the image stored inside the savestate
		$LF
	]li
	[li 
		" When you hide the game window with another window, the tool issues an expose message to the game to refresh the screen
		$LF
	]li
	[li 
		" When the game is paused, you can preview the inputs you are pressing on the game screen if you have enabled 
		[tt 
			"Video > OSD > Inputs
		]tt
		$LF
	]li
]ul
[p 
	"For now, this functionality does not work in some games. If you see a black screen when one of the above scenarios occurs, you may want to turn it off.
	$LF
]p
[h4 
	" Backup savefiles in memory
	$LF
	[a id=heading-6688 
	]a
]h4
[p 
	"This option aims at preventing the game to save in savefiles on disk. This is useful to keep the same state of the game whenever you load a savestate or you quit and restart the game. To enable that, libTAS detects if the game opens a regular file in write mode, and instead opens a virtual file in memory with a copy of the content of the actual file. The game does not notice it and uses regular file commands (e.g. read, write, seek) on it. Because this virtual file is in memory, it is saved inside savestates and is recovered when loading a savestate. Also, when the game is closed, all the modifications in the virtual file are lost. This option may cause some games to crash, if they are doing uncommon operations with savefiles, or if the tool incorrectly detected savefiles.
	$LF
]p
[h4 
	" Recycle threads
	$LF
	[a id=heading-6689 
	]a
]h4
[p 
	"One current limitation of the savestates is that loading a savestate won't recreated threads that have exited since the savestate was done. It makes loading impossible in common cases like between levels, and the user will be forced to restart the entire movie because he cannot load any savestate. We can work around this limitation by recycling threads. When a game thread exits, it turns into a wait mode instead, and the next time the game creates a new thread, no thread is actually created and the thread function is passed to this waiting thread. Thanks to this, savestates are much more likely to be possible.
	$LF
]p
[p 
	"However, some games will crash when this option is checked (e.g. recent mono games) because thread-local storage is not completely supported.
	$LF
]p
[h4 
	" Virtual Steam client
	$LF
	[a id=heading-6690 
	]a
]h4
[p 
	"When enabled, it will simulate a dummy Steam client in case games want to connect to Steam. This is mandatory for games that require Steam to be opened, because libTAS does not work with Steam. The implementation of this dummy client is not completed, so it won't work with all games.
	$LF
]p
[h4 
	" Debug
	$LF
	[a id=heading-6691 
	]a
]h4
[p 
	"The 
	[tt 
		"Uncontrolled time
	]tt
	" option makes the game access the real system time. It is useful to see if a softlocked game can run fine with this option. It also gives the user a good idea of the native framerate of the game. Checking this option will cause desyncs in input recording/playback.
	$LF
]p
[p 
	"The 
	[tt 
		"Native events
	]tt
	" option makes the game access the real event system. It is useful to debug games that don't take inputs from the user. Checking this option may make input recording not working.
	$LF
]p
[h3 
	" Tools
	$LF
	[a id=heading-6692 
	]a
]h3
[h4 
	" Configure Encode
	$LF
	[a id=heading-6693 
	]a
]h4
[p 
	"Video encode is configured in this window. The program offers some audio and video codecs as dropdown menu, which fills the corresponding ffmpeg options, but you can manually modify the options to be send to ffmpeg. Also, the container is determined from the file extension (e.g. name your video 
	[tt 
		"encode.mkv
	]tt
	" will use the Matroska container).
	$LF
]p
[h4 
	" Ram Search
	$LF
	[a id=heading-6694 
	]a
]h4
[p 
	"There is a rudimentary Ram Search feature implemented. To start a new search, you need to:
	$LF
]p
[ol 
	[li 
		" Check the memory regions you want to include. In the most common case, you will want to only include 
		[tt 
			"Heap
		]tt
		" and 
		[tt 
			"Anon RW Mapping
		]tt
		" which are the two regions of dynamically allocated read/write memory.
		$LF
	]li
	[li 
		" Choose 
		[tt 
			"Unknown/Previous Value
		]tt
		" if you don't want to filter the results, or 
		[tt 
			"Specific Value
		]tt
		" if you want to filter base on a comparison to a specific value. In that case, fill the value and the operator above. Be careful that the allocated memory can be very big in some games, so whenever possible, filter the results for a new search. Also, try to filter the value 
		[tt 
			"0
		]tt
		" because a non-negligible part of memory contains zeros. If too many results are retained, the program will 
		[b 
			"crash
		]b
		$LF
	]li
	[li 
		" Choose the type of variable to search for, and how it will be displayed
		$LF
	]li
	[li 
		" Press 
		[tt 
			"New
		]tt
		$LF
	]li
]ol
[p 
	"Then, for more filtering, set the appropriate parameters and press 
	[tt 
		"Search
	]tt
	". If you find a result that you want to keep, you can select the row and press 
	[tt 
		"Add Watch
	]tt
	". You will be able to save the address and apply a label. Then, the saved addresses are available in the 
	[tt 
		"Ram Watch
	]tt
	" menu.
	$LF
]p
[h4 
	" Ram Watch
	$LF
	[a id=heading-6695 
	]a
]h4
[p 
	"A simple window to look at the ram watches. It is also possible to scan for pointers to a specific address. Because most memory is allocated dynamically, the location of a particular value that you are looking for will probably change for every game execution. To be able to keep track of this value, you can search for a chain of pointers that starts from a static address (which never change) to the actual value location. It will look like 
	[tt 
		"pointer -> offset -> pointer -> offset -> pointer -> offset -> location
	]tt
	".
	$LF
]p
[p 
	"The pointer scan feature will scan for pointer chains to a specific address. Selecting a ram watch and pressing the button will open a new window. You can then set the maximum number of pointers in the chain and the maximum value of offsets. The Search will take some time, but all the layout is stored so you can search again with different parameters or other addresses in a very short time, as long as you don't frame advance. Then, you can store results in the Ram Watch.
	$LF
]p
[h3 
	" Input
	$LF
	[a id=heading-6696 
	]a
]h3
[h4 
	" Recalibrate mouse position
	$LF
	[a id=heading-6697 
	]a
]h4
[p 
	"Some games move their cursor using the relative movement of the mouse, so there will be an offset between the system mouse cursor and the game cursor. To align both cursors, after choosing this option, click on the game cursor.
	$LF
]p
