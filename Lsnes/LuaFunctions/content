21
[p 
	"This page documents various lua functions in lsnes.
	$LF
]p
[p 
	"Unless otherwise noted, functions are in rr1 version and work anywhere.
	$LF
]p
[div class=toc 
	[ul 
		[li 
			[a href=#Bitmanipulationfunctions 
				"Bit manipulation functions
				$LF
			]a
		]li
		[ul 
			[li 
				[a href=#(Genericremarks) 
					"(Generic remarks)
					$LF
				]a
			]li
			[li 
				[a href=#Bit.none/bit.bnot 
					"bit.none / bit.bnot
					$LF
				]a
			]li
			[li 
				[a href=#Bit.any/bit.bor 
					"bit.any / bit.bor
					$LF
				]a
			]li
			[li 
				[a href=#Bit.all/bit.band 
					"bit.all / bit.band
					$LF
				]a
			]li
			[li 
				[a href=#Bit.parity 
					"bit.parity
					$LF
				]a
			]li
			[li 
				[a href=#Bit.lrotate 
					"bit.lrotate
					$LF
				]a
			]li
			[li 
				[a href=#Bit.rrotate 
					"bit.rrotate
					$LF
				]a
			]li
			[li 
				[a href=#Bit.lshift 
					"bit.lshift
					$LF
				]a
			]li
			[li 
				[a href=#Bit.lrshift 
					"bit.lrshift
					$LF
				]a
			]li
			[li 
				[a href=#Bit.arshift 
					"bit.arshift
					$LF
				]a
			]li
			[li 
				[a href=#Bit.extract 
					"bit.extract
					$LF
				]a
			]li
			[li 
				[a href=#Bit.value 
					"bit.value
					$LF
				]a
			]li
			[li 
				[a href=#Bit.test_any 
					"bit.test_any
					$LF
				]a
			]li
			[li 
				[a href=#Bit.test_all 
					"bit.test_all
					$LF
				]a
			]li
			[li 
				[a href=#Bit.popcount 
					"bit.popcount
					$LF
				]a
			]li
			[li 
				[a href=#Bit.clshift 
					"bit.clshift
					$LF
				]a
			]li
			[li 
				[a href=#Bit.crshift 
					"bit.crshift
					$LF
				]a
			]li
			[li 
				[a href=#Bit.flagdecode 
					"bit.flagdecode
					$LF
				]a
			]li
			[li 
				[a href=#Bit.rflagdecode 
					"bit.rflagdecode
					$LF
				]a
			]li
		]ul
		[li 
			[a href=#GUIfunctions 
				"GUI functions
				$LF
			]a
		]li
		[ul 
			[li 
				[a href=#(Colornotation) 
					"(Color notation)
					$LF
				]a
			]li
			[li 
				[a href=#(Coordinatesystem) 
					"(Coordinate system)
					$LF
				]a
			]li
			[li 
				[a href=#(Draworder) 
					"(Draw order)
					$LF
				]a
			]li
			[li 
				[a href=#(Validin) 
					"(Valid in)
					$LF
				]a
			]li
			[li 
				[a href=#Gui.screenshot 
					"gui.screenshot
					$LF
				]a
			]li
			[li 
				[a href=#Gui.circle 
					"gui.circle
					$LF
				]a
			]li
			[li 
				[a href=#Gui.resolution 
					"gui.resolution
					$LF
				]a
			]li
			[li 
				[a href=#Gui.left_gap/gui.top_gap/gui.right_gap/gui.bottom_gap 
					"gui.left_gap / gui.top_gap / gui.right_gap / gui.bottom_gap
					$LF
				]a
			]li
			[li 
				[a href=#Gui.repaint 
					"gui.repaint
					$LF
				]a
			]li
			[li 
				[a href=#Gui.subframe_update 
					"gui.subframe_update
					$LF
				]a
			]li
			[li 
				[a href=#Gui.color 
					"gui.color
					$LF
				]a
			]li
			[li 
				[a href=#Gui.status 
					"gui.status
					$LF
				]a
			]li
			[li 
				[a href=#Gui.crosshair 
					"gui.crosshair
					$LF
				]a
			]li
			[li 
				[a href=#Gui.line 
					"gui.line
					$LF
				]a
			]li
			[li 
				[a href=#Gui.pixel 
					"gui.pixel
					$LF
				]a
			]li
			[li 
				[a href=#Gui.rectangle 
					"gui.rectangle
					$LF
				]a
			]li
			[li 
				[a href=#Gui.box 
					"gui.box
					$LF
				]a
			]li
			[li 
				[a href=#Gui.text/gui.textH/gui.textV/gui.textHV 
					"gui.text / gui.textH / gui.textV / gui.textHV
					$LF
				]a
			]li
			[li 
				[a href=#Gui.bitmap_draw 
					"gui.bitmap_draw
					$LF
				]a
			]li
			[li 
				[a href=#Gui.palette_new 
					"gui.palette_new
					$LF
				]a
			]li
			[li 
				[a href=#Gui.palette_set 
					"gui.palette_set
					$LF
				]a
			]li
			[li 
				[a href=#Gui.bitmap_new 
					"gui.bitmap_new
					$LF
				]a
			]li
			[li 
				[a href=#Gui.bitmap_pset 
					"gui.bitmap_pset
					$LF
				]a
			]li
			[li 
				[a href=#Gui.bitmap_size 
					"gui.bitmap_size
					$LF
				]a
			]li
			[li 
				[a href=#Gui.bitmap_blit 
					"gui.bitmap_blit
					$LF
				]a
			]li
			[li 
				[a href=#Gui.bitmap_load 
					"gui.bitmap_load
					$LF
				]a
			]li
			[li 
				[a href=#Gui.rainbow 
					"gui.rainbow
					$LF
				]a
			]li
		]ul
		[li 
			[a href=#Hostmemoryfunctions 
				"Hostmemory functions
				$LF
			]a
		]li
		[ul 
			[li 
				[a href=#(Generic) 
					"(Generic)
					$LF
				]a
			]li
			[li 
				[a href=#Hostmemory.read/hostmemory.readbyte/hostmemory.readword/hostmemory.readdword/hostmemory.readqword 
					"hostmemory.read / hostmemory.readbyte / hostmemory.readword / hostmemory.readdword / hostmemory.readqword
					$LF
				]a
			]li
			[li 
				[a href=#Hostmemory.readsbyte/hostmemory.readsword/hostmemory.readsdword/hostmemory.readsqword 
					"hostmemory.readsbyte / hostmemory.readsword / hostmemory.readsdword / hostmemory.readsqword
					$LF
				]a
			]li
			[li 
				[a href=#Hostmemory.write/hostmemory.writebyte/hostmemory.writeword/hostmemory.writedword/hostmemory.writeqword 
					"hostmemory.write / hostmemory.writebyte / hostmemory.writeword / hostmemory.writedword / hostmemory.writeqword
					$LF
				]a
			]li
		]ul
		[li 
			[a href=#Inputfunctions 
				"Input functions
				$LF
			]a
		]li
		[ul 
			[li 
				[a href=#(Generic) 
					"(Generic)
					$LF
				]a
			]li
			[li 
				[a href=#Input.set 
					"input.set
					$LF
				]a
			]li
			[li 
				[a href=#Input.get 
					"input.get
					$LF
				]a
			]li
			[li 
				[a href=#Input.reset 
					"input.reset
					$LF
				]a
			]li
			[li 
				[a href=#Input.raw 
					"input.raw
					$LF
				]a
			]li
			[li 
				[a href=#Input.keyhook 
					"input.keyhook
					$LF
				]a
			]li
			[li 
				[a href=#Input.geta 
					"input.geta
					$LF
				]a
			]li
			[li 
				[a href=#Input.seta 
					"input.seta
					$LF
				]a
			]li
			[li 
				[a href=#Input.joyget 
					"input.joyget
					$LF
				]a
			]li
			[li 
				[a href=#Input.joyset 
					"input.joyset
					$LF
				]a
			]li
		]ul
		[li 
			[a href=#Memoryfunctions 
				"Memory functions
				$LF
			]a
		]li
		[ul 
			[li 
				[a href=#(Generic) 
					"(Generic)
					$LF
				]a
			]li
			[li 
				[a href=#Memory.read/memory.readbyte/memory.readword/memory.readdword/memory.readqword 
					"memory.read / memory.readbyte / memory.readword / memory.readdword / memory.readqword
					$LF
				]a
			]li
			[li 
				[a href=#Memory.readsbyte/memory.readsword/memory.readsdword/memory.readsqword 
					"memory.readsbyte / memory.readsword / memory.readsdword / memory.readsqword
					$LF
				]a
			]li
			[li 
				[a href=#Memory.write/memory.writebyte/memory.writeword/memory.writedword/memory.writeqword 
					"memory.write / memory.writebyte / memory.writeword / memory.writedword / memory.writeqword
					$LF
				]a
			]li
			[li 
				[a href=#Memory.mapbyte/memory.mapsbyte/memory.mapword/memory.mapsword/memory.mapdword/memory.mapsdword/memory.mapqword/memory.mapsqword 
					"memory.mapbyte / memory.mapsbyte / memory.mapword / memory.mapsword / memory.mapdword / memory.mapsdword / memory.mapqword / memory.mapsqword
					$LF
				]a
			]li
			[li 
				[a href=#Memory.map_structure() 
					"memory.map_structure()
					$LF
				]a
			]li
			[li 
				[a href=#Memory.vma_count 
					"memory.vma_count
					$LF
				]a
			]li
			[li 
				[a href=#Memory.read_vma 
					"memory.read_vma
					$LF
				]a
			]li
			[li 
				[a href=#Memory.find_vma 
					"memory.find_vma
					$LF
				]a
			]li
			[li 
				[a href=#Memory.hash_state 
					"memory.hash_state
					$LF
				]a
			]li
			[li 
				[a href=#Memory.hash_region 
					"memory.hash_region
					$LF
				]a
			]li
			[li 
				[a href=#Memory.readregion 
					"memory.readregion
					$LF
				]a
			]li
			[li 
				[a href=#Memory.writeregion 
					"memory.writeregion
					$LF
				]a
			]li
		]ul
		[li 
			[a href=#Moviefunctions 
				"Movie functions
				$LF
			]a
		]li
		[ul 
			[li 
				[a href=#Movie.currentframe 
					"movie.currentframe
					$LF
				]a
			]li
			[li 
				[a href=#Movie.framecount 
					"movie.framecount
					$LF
				]a
			]li
			[li 
				[a href=#Movie.readonly 
					"movie.readonly
					$LF
				]a
			]li
			[li 
				[a href=#Movie.readwrite 
					"movie.readwrite
					$LF
				]a
			]li
			[li 
				[a href=#Movie.frame_subframes 
					"movie.frame_subframes
					$LF
				]a
			]li
			[li 
				[a href=#Movie.read_subframes 
					"movie.read_subframes
					$LF
				]a
			]li
			[li 
				[a href=#Movie.read_rtc 
					"movie.read_rtc
					$LF
				]a
			]li
			[li 
				[a href=#Movie.unsafe_rewind 
					"movie.unsafe_rewind
					$LF
				]a
			]li
			[li 
				[a href=#Movie.rerecords 
					"movie.rerecords
					$LF
				]a
			]li
		]ul
		[li 
			[a href=#Settingsfunctions 
				"Settings functions
				$LF
			]a
		]li
		[ul 
			[li 
				[a href=#(Generic) 
					"(Generic)
					$LF
				]a
			]li
			[li 
				[a href=#Settings.set 
					"settings.set
					$LF
				]a
			]li
			[li 
				[a href=#Setting.get 
					"setting.get
					$LF
				]a
			]li
			[li 
				[a href=#Setting.blank 
					"setting.blank
					$LF
				]a
			]li
			[li 
				[a href=#Setting.is_set 
					"setting.is_set
					$LF
				]a
			]li
		]ul
		[li 
			[a href=#Misc.functions 
				"Misc. functions
				$LF
			]a
		]li
		[ul 
			[li 
				[a href=#Exec 
					"exec
					$LF
				]a
			]li
			[li 
				[a href=#Print 
					"print
					$LF
				]a
			]li
			[li 
				[a href=#Utime 
					"utime
					$LF
				]a
			]li
			[li 
				[a href=#Emulator_ready 
					"emulator_ready
					$LF
				]a
			]li
			[li 
				[a href=#Set_idle_timeout 
					"set_idle_timeout
					$LF
				]a
			]li
			[li 
				[a href=#Set_timer_timeout 
					"set_timer_timeout
					$LF
				]a
			]li
			[li 
				[a href=#Bus_address 
					"bus_address
					$LF
				]a
			]li
			[li 
				[a href=#Loopwrapper( 
					"loopwrapper(
					$LF
				]a
			]li
		]ul
		[li 
			[a href=#Callbacks 
				"Callbacks
				$LF
			]a
		]li
		[ul 
			[li 
				[a href=#(Generic) 
					"(Generic)
					$LF
				]a
			]li
			[li 
				[a href=#On_paint 
					"on_paint
					$LF
				]a
			]li
			[li 
				[a href=#On_video 
					"on_video
					$LF
				]a
			]li
			[li 
				[a href=#On_input 
					"on_input
					$LF
				]a
			]li
			[li 
				[a href=#On_reset 
					"on_reset
					$LF
				]a
			]li
			[li 
				[a href=#On_frame 
					"on_frame
					$LF
				]a
			]li
			[li 
				[a href=#On_readwrite 
					"on_readwrite
					$LF
				]a
			]li
			[li 
				[a href=#On_startup 
					"on_startup
					$LF
				]a
			]li
			[li 
				[a href=#On_pre_load 
					"on_pre_load
					$LF
				]a
			]li
			[li 
				[a href=#On_err_load 
					"on_err_load
					$LF
				]a
			]li
			[li 
				[a href=#On_post_load 
					"on_post_load
					$LF
				]a
			]li
			[li 
				[a href=#On_pre_save 
					"on_pre_save
					$LF
				]a
			]li
			[li 
				[a href=#On_err_save 
					"on_err_save
					$LF
				]a
			]li
			[li 
				[a href=#On_post_save 
					"on_post_save
					$LF
				]a
			]li
			[li 
				[a href=#On_snoop 
					"on_snoop
					$LF
				]a
			]li
			[li 
				[a href=#On_quit 
					"on_quit
					$LF
				]a
			]li
			[li 
				[a href=#On_keyhook 
					"on_keyhook
					$LF
				]a
			]li
			[li 
				[a href=#On_set_rewind 
					"on_set_rewind
					$LF
				]a
			]li
			[li 
				[a href=#On_pre_rewind 
					"on_pre_rewind
					$LF
				]a
			]li
			[li 
				[a href=#On_post_rewind 
					"on_post_rewind
					$LF
				]a
			]li
			[li 
				[a href=#On_frame_emulated 
					"on_frame_emulated
					$LF
				]a
			]li
			[li 
				[a href=#On_idle 
					"on_idle
					$LF
				]a
			]li
			[li 
				[a href=#On_timer 
					"on_timer
					$LF
				]a
			]li
		]ul
	]ul
]div
[h2 id=Bitmanipulationfunctions 
	"Bit manipulation functions
	$LF
]h2
[h3 id=(Genericremarks) 
	"(Generic remarks)
	$LF
]h3
[p 
	"Bit manipulation functions work on 48-bit numbers and return 48-bit results. Negative numbers are interpreted as two's complement.
	$LF
]p
[h3 id=Bit.none/bit.bnot 
	"bit.none / bit.bnot
	$LF
]h3
[blockquote 
	"Syntax: Number bit.none(Number n...)
	[br 
	]br
	$LF
	"Syntax: Number bit.bnot(Number n...)
	$LF
]blockquote
[p 
	"Returns number that has bit i set exactly when none of the arguments has the bit i set.
	$LF
]p
[p 
	"When called with one argument, this is the same as the bitwise NOT.
	$LF
]p
[h3 id=Bit.any/bit.bor 
	"bit.any / bit.bor
	$LF
]h3
[blockquote 
	"Syntax: Number bit.any(Number n...)
	[br 
	]br
	$LF
	"Syntax: Number bit.bor(Number n...)
	$LF
]blockquote
[p 
	"Returns number that has bit i set exactly when any of the arguments has the bit i set.
	$LF
]p
[p 
	"If called with two arguments, this is the same as bitwise OR.
	$LF
]p
[h3 id=Bit.all/bit.band 
	"bit.all / bit.band
	$LF
]h3
[blockquote 
	"Syntax: Number bit.all(Number n...)
	[br 
	]br
	$LF
	"Syntax: Number bit.band(Number n...)
	$LF
]blockquote
[p 
	"Returns number that has bit i set exactly when all of the arguments have the bit i set.
	$LF
]p
[p 
	"If called with two arguments, this is the same as bitwise AND.
	$LF
]p
[h3 id=Bit.parity 
	"bit.parity
	$LF
]h3
[blockquote 
	"Syntax: Number bit.parity(Number n...)
	[br 
	]br
	$LF
	"Syntax: Number bit.bxor(Number n...)
	$LF
]blockquote
[p 
	"Returns number that has bit i set exactly when odd number of the arguments has the bit i set.
	$LF
]p
[p 
	"If called with two arguments, this is the same as bitwise XOR.
	$LF
]p
[h3 id=Bit.lrotate 
	"bit.lrotate
	$LF
]h3
[blockquote 
	"Syntax: Number bit.lrotate(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, rotated left by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]p
[p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]p
[h3 id=Bit.rrotate 
	"bit.rrotate
	$LF
]h3
[blockquote 
	"Syntax: Number bit.rrotate(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, rotated right by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]p
[p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]p
[h3 id=Bit.lshift 
	"bit.lshift
	$LF
]h3
[blockquote 
	"Syntax: Number bit.lshift(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, shifted left by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]p
[p 
	"The bits that leave 
	[b 
		"nbits
	]b
	" least significant bits are discarded. The shifted in bits are zeroes.
	$LF
]p
[p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]p
[h3 id=Bit.lrshift 
	"bit.lrshift
	$LF
]h3
[blockquote 
	"Syntax: Number bit.lrshift(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, shifted logically right by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]p
[p 
	"The bits that drop off the right end are discarded. The shifted in bits are zeroes.
	$LF
]p
[p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]p
[h3 id=Bit.arshift 
	"bit.arshift
	$LF
]h3
[blockquote 
	"Syntax: Number bit.arshift(Number base, [Number nplaces], [Number nbits])
	$LF
]blockquote
[ul 
	[li 
		" If 
		[b 
			"nplaces
		]b
		" is not specified, defaults to 1.
		$LF
	]li
	[li 
		" If 
		[b 
			"nbits
		]b
		" is not specified, defaults to 48.
		$LF
	]li
]ul
[p 
	"Returns 
	[b 
		"base
	]b
	", assumed to be 
	[b 
		"nbits
	]b
	" bits, shifted arithmetically right by 
	[b 
		"nplaces
	]b
	" places.
	$LF
]p
[p 
	"The bits that drop off the right end are discarded. The shifted in bits are copies of the most significant bit.
	$LF
]p
[p 
	"Behavior is undefined if 
	[b 
		"nbits
	]b
	" is greater than 48 or if 
	[b 
		"nplaces
	]b
	" is greater than 47.
	$LF
]p
[h3 id=Bit.extract 
	"bit.extract
	$LF
]h3
[blockquote 
	"Syntax: Number bit.extract(Number base, Number/Boolean place...)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ5
		$LF
	]li
]ul
[p 
	"Returns a number where ith bit is taken from the ith 
	[b 
		"place
	]b
	"th bit of 
	[b 
		"base
	]b
	".
	$LF
]p
[p 
	"As special case, if ith 
	[b 
		"place
	]b
	" is boolean, the ith returned bit is that value (1 if argument was true, 0 if false).
	$LF
]p
[h3 id=Bit.value 
	"bit.value
	$LF
]h3
[blockquote 
	"Syntax: Number bit.value(Number/nil place...)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ5
		$LF
	]li
]ul
[p 
	"Returns number that has all 
	[b 
		"place
	]b
	"th bits set.
	$LF
]p
[p 
	"As special case, any nil arguments are ignored.
	$LF
]p
[h3 id=Bit.test_any 
	"bit.test_any
	$LF
]h3
[blockquote 
	"Syntax: Boolean bit.test_any(Number a, Number b)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[p 
	"Returns true if a and b have common set bit or bits.
	$LF
]p
[h3 id=Bit.test_all 
	"bit.test_all
	$LF
]h3
[blockquote 
	"Syntax: Boolean bit.test_all(Number a, Number b)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[p 
	"Returns true if a has all the bits set in b set.
	$LF
]p
[h3 id=Bit.popcount 
	"bit.popcount
	$LF
]h3
[blockquote 
	"Syntax: Number bit.popcount(Number a)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[p 
	"Returns population count (number of set bits) of a.
	$LF
]p
[h3 id=Bit.clshift 
	"bit.clshift
	$LF
]h3
[blockquote 
	"Syntax: Number,Number bit.clshift(Number a, Number b, [Number places], [Number bits])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[p 
	"Chained shift of a and b left by specified number of places (default 1). The numbers are treated as having specified number of bits (default 48).
	$LF
]p
[h3 id=Bit.crshift 
	"bit.crshift
	$LF
]h3
[blockquote 
	"Syntax: Number,Number bit.crshift(Number a, Number b, [Number places], [Number bits])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[p 
	"Chained shift of a and b right by specified number of places (default 1). The numbers are treated as having specified number of bits (default 48).
	$LF
]p
[h3 id=Bit.flagdecode 
	"bit.flagdecode
	$LF
]h3
[blockquote 
	"Syntax: String bit.flagdecode(Number a, Number bits, [String set], [String clear])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[p 
	"Returns string where ith character is ith character (only character or '*') of set if corresponding bit is set, otherwise corresponding character of clear.
	$LF
]p
[h3 id=Bit.rflagdecode 
	"bit.rflagdecode
	$LF
]h3
[blockquote 
	"Syntax: String bit.rflagdecode(Number a, Number bits, [String set], [String clear])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ16 / rr2-β2
		$LF
	]li
]ul
[p 
	"Same as bit.flagdecode, but reverses the output string.
	$LF
]p
[h2 id=GUIfunctions 
	"GUI functions
	$LF
]h2
[h3 id=(Colornotation) 
	"(Color notation)
	$LF
]h3
[ul 
	[li 
		" -1 is fully transparent.
		$LF
	]li
	[li 
		" 16777216 * a + 65536 * r + 256 * g + b for other colors, where a is transparency.
		$LF
	]li
	[li 
		" * The range of r, g and b and a is 0-255.
		$LF
	]li
	[li 
		" * Alpha 0 is fully opaque, alpha 256 is fully transparent.
		$LF
	]li
	[li 
		" * The a of this notation only goes to 255, despite there being alpha 256.
		$LF
	]li
]ul
[h3 id=(Coordinatesystem) 
	"(Coordinate system)
	$LF
]h3
[ul 
	[li 
		" Origin is at top left of the game area.
		$LF
	]li
	[li 
		" Positive directions are right and down.
		$LF
	]li
	[li 
		" Left gap and top gap have negative coordinates.
		$LF
	]li
]ul
[h3 id=(Draworder) 
	"(Draw order)
	$LF
]h3
[ul 
	[li 
		" The primitives are drawn in order they are specified.
		$LF
	]li
	[li 
		" Gap settings always overtake everything else.
		$LF
	]li
]ul
[h3 id=(Validin) 
	"(Valid in)
	$LF
]h3
[ul 
	[li 
		" These primitives (unless otherwise noted) are only valid in callbacks 
		[b 
			"on_paint
		]b
		" and 
		[b 
			"on_video
		]b
		".
		$LF
	]li
	[li 
		" If called in 
		[b 
			"on_paint
		]b
		", the screen is affected.
		$LF
	]li
	[li 
		" If called in 
		[b 
			"on_video
		]b
		", the dumped video is affected.
		$LF
	]li
]ul
[h3 id=Gui.screenshot 
	"gui.screenshot
	$LF
]h3
[blockquote 
	"Syntax: none gui.screenshot(string filename)
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere.
		$LF
	]li
]ul
[p 
	"Take a screenshot in PNG format and save it to 
	[b 
		"filename
	]b
	$LF
]p
[h3 id=Gui.circle 
	"gui.circle
	$LF
]h3
[blockquote 
	"Syntax: none gui.circle(Number x, Number y, Number r, [Number thickness], [Number outline_color], [Number fill_color])
	$LF
]blockquote
[ul 
	[li 
		" thickness defaults to 1
		$LF
	]li
	[li 
		" outline_color defaults to white
		$LF
	]li
	[li 
		" fill_color defaults to transparent
		$LF
	]li
]ul
[p 
	"Draws a circle centered at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	") with radius 
	[b 
		"r
	]b
	".
	$LF
]p
[p 
	"The outline is of thickness 
	[b 
		"thickness
	]b
	" and is drawn using color specified by 
	[b 
		"outline_color
	]b
	$LF
]p
[p 
	"The interior region is filled with color 
	[b 
		"fill_color
	]b
	".
	$LF
]p
[h3 id=Gui.resolution 
	"gui.resolution
	$LF
]h3
[blockquote 
	" Syntax (number width, number height) gui.resolution()
	$LF
]blockquote
[p 
	"Returns the width (
	[b 
		"width
	]b
	") and height (
	[b 
		"height
	]b
	") of game area.
	$LF
]p
[h3 id=Gui.left_gap/gui.top_gap/gui.right_gap/gui.bottom_gap 
	"gui.left_gap / gui.top_gap / gui.right_gap / gui.bottom_gap
	$LF
]h3
[blockquote 
	" Syntax none gui.left_gap(number pixels)
	[br 
	]br
	$LF
	" Syntax none gui.top_gap(number pixels)
	[br 
	]br
	$LF
	" Syntax none gui.right_gap(number pixels)
	[br 
	]br
	$LF
	" Syntax none gui.bottom_gap(number pixels)
	$LF
]blockquote
[p 
	"Sets the width of drawable blank area to the left/top/right/bottom of the game area to 
	[b 
		"pixels
	]b
	".
	$LF
]p
[h3 id=Gui.repaint 
	"gui.repaint
	$LF
]h3
[blockquote 
	" Syntax: none gui.repaint()
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere.
		$LF
	]li
]ul
[p 
	"Arranges 
	[b 
		"on_paint
	]b
	" hook to be called as soon as possible.
	$LF
]p
[h3 id=Gui.subframe_update 
	"gui.subframe_update
	$LF
]h3
[blockquote 
	" Syntax: none gui.subframe_update(boolean enabled)
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere
		$LF
	]li
]ul
[p 
	"Enables (
	[b 
		"enabled
	]b
	"=true)/Disables (
	[b 
		"enabled
	]b
	"=false) calling of 
	[b 
		"on_paint
	]b
	" on every subframe (as opposed to just when new frame is available).
	$LF
]p
[h3 id=Gui.color 
	"gui.color
	$LF
]h3
[blockquote 
	" Syntax: Number gui.color(Number r, Number g, Number b, [Number a])
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere.
		$LF
	]li
	[li 
		" 
		[b 
			"a
		]b
		" defaults to 0 if not specified.
		$LF
	]li
]ul
[p 
	"Returns the color code for color (
	[b 
		"r
	]b
	",
	[b 
		"g
	]b
	",
	[b 
		"b
	]b
	") (0-255 each channel) with alpha of 
	[b 
		"a
	]b
	" (0-256).
	$LF
]p
[h3 id=Gui.status 
	"gui.status
	$LF
]h3
[blockquote 
	" Syntax: none gui.status(String name, String value)
	$LF
]blockquote
[ul 
	[li 
		" Valid anywhere
		$LF
	]li
]ul
[p 
	"Set status 
	[b 
		"name
	]b
	" to value 
	[b 
		"value
	]b
	".
	$LF
]p
[p 
	"If 
	[b 
		"value
	]b
	" is "", the status 
	[b 
		"name
	]b
	" is erased.
	$LF
]p
[h3 id=Gui.crosshair 
	"gui.crosshair
	$LF
]h3
[blockquote 
	" Syntax: none gui.crosshair(Number x, Number y, Number size, [Number color])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"color
		]b
		" defaults to white.
		$LF
	]li
]ul
[p 
	"Draws a crosshair of size 
	[b 
		"size
	]b
	" at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	") using color 
	[b 
		"color
	]b
	".
	$LF
]p
[h3 id=Gui.line 
	"gui.line
	$LF
]h3
[blockquote 
	" Syntax: none gui.color(Number x1, Number y1, Number x2, Number y2, [Number color])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"color
		]b
		" defaults to white.
		$LF
	]li
]ul
[p 
	"Draws a line from (
	[b 
		"x1
	]b
	",
	[b 
		"y1
	]b
	") to (
	[b 
		"x2
	]b
	",
	[b 
		"y2
	]b
	") using color 
	[b 
		"color
	]b
	".
	$LF
]p
[h3 id=Gui.pixel 
	"gui.pixel
	$LF
]h3
[blockquote 
	" Syntax: none gui.pixel(Number x, Number y, [Number color])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"color
		]b
		" defaults to white.
		$LF
	]li
]ul
[p 
	"Draws pixel at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	") using color 
	[b 
		"color
	]b
	".
	$LF
]p
[p 
	"Be careful with this function. Even if it is the lightest of all draw functions, lots of draw functions don't do any good to performance.
	$LF
]p
[h3 id=Gui.rectangle 
	"gui.rectangle
	$LF
]h3
[blockquote 
	" Syntax: none gui.rectangle(Number x, Number y, Number w, Number h, [Number thickness], [Number outline_color], [Number fill_color])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"tickness
		]b
		" defaults to 1.
		$LF
	]li
	[li 
		" 
		[b 
			"outline_color
		]b
		" defaults to white.
		$LF
	]li
	[li 
		" 
		[b 
			"fill_color
		]b
		" defaults to transparent.
		$LF
	]li
]ul
[p 
	"Draws rectangle of size (
	[b 
		"w
	]b
	",
	[b 
		"h
	]b
	") with top-left corner at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	"). Outline is of thickness 
	[b 
		"thickness
	]b
	" and is colored with color 
	[b 
		"outline_color
	]b
	".
	$LF
]p
[p 
	"The interior is filled with color 
	[b 
		"fill_color
	]b
	".
	$LF
]p
[h3 id=Gui.box 
	"gui.box
	$LF
]h3
[blockquote 
	" Syntax: none gui.box(Number x, Number y, Number w, Number h, [Number thickness], [Number hilight_color], [Number shadow_color], [Number fill_color])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ6
		$LF
	]li
	[li 
		" 
		[b 
			"thickness
		]b
		" defaults to 1.
		$LF
	]li
	[li 
		" 
		[b 
			"hilight_color
		]b
		" defaults to white.
		$LF
	]li
	[li 
		" 
		[b 
			"shadow_color
		]b
		" defaults to dark gray.
		$LF
	]li
	[li 
		" 
		[b 
			"fill_color
		]b
		" defaults to gray.
		$LF
	]li
]ul
[p 
	"Draws rectangle of size (
	[b 
		"w
	]b
	",
	[b 
		"h
	]b
	") with top-left corner at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	").
	$LF
]p
[p 
	"The outline is of thickness 
	[b 
		"thickness
	]b
	" and is colored with 
	[b 
		"hilight_color
	]b
	"/
	[b 
		"shadow_color
	]b
	" to create a 3D effect.
	$LF
]p
[p 
	"The interior is filled with fill_color.
	$LF
]p
[h3 id=Gui.text/gui.textH/gui.textV/gui.textHV 
	"gui.text / gui.textH / gui.textV / gui.textHV
	$LF
]h3
[blockquote 
	" Syntax: none gui.text(Number x, Number y, String text, [Number fgcolor], [Number bgcolor])
	[br 
	]br
	$LF
	" Syntax: none gui.textH(Number x, Number y, String text, [Number fgcolor], [Number bgcolor])
	[br 
	]br
	$LF
	" Syntax: none gui.textV(Number x, Number y, String text, [Number fgcolor], [Number bgcolor])
	[br 
	]br
	$LF
	" Syntax: none gui.textHV(Number x, Number y, String text, [Number fgcolor], [Number bgcolor])
	$LF
]blockquote
[ul 
	[li 
		" 
		[b 
			"fgcolor
		]b
		" defaults to white.
		$LF
	]li
	[li 
		" 
		[b 
			"bgcolor
		]b
		" defaults to transparent.
		$LF
	]li
]ul
[p 
	"Draws text string 
	[b 
		"text
	]b
	" starting from (
	[b 
		"x
	]b
	", 
	[b 
		"y
	]b
	").
	$LF
]p
[p 
	"The text will be colored using color 
	[b 
		"fgcolor
	]b
	" and the text background is colored using 
	[b 
		"bgcolor
	]b
	".
	$LF
]p
[p 
	"The 
	[tt 
		"H
	]tt
	" variants will draw the text using double width, and the 
	[tt 
		"V
	]tt
	" variants will draw the text using double height.
	$LF
]p
[h3 id=Gui.bitmap_draw 
	"gui.bitmap_draw
	$LF
]h3
[blockquote 
	" Syntax: none gui.bitmap_draw(Number x, Number y, BITMAP bmp, PALETTE pal)
	[br 
	]br
	$LF
	" Syntax: none gui.bitmap_draw(Number x, Number y, DBITMAP bmp)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
]ul
[p 
	"Render bitmap 
	[b 
		"bmp
	]b
	" with upper-left corner at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	").
	$LF
]p
[p 
	"If the bitmap is indexed, it will be rendered using palette 
	[b 
		"pal
	]b
	".
	$LF
]p
[h3 id=Gui.palette_new 
	"gui.palette_new
	$LF
]h3
[blockquote 
	" Syntax: PALETTE gui.palette_new()
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[p 
	"Returns a new PALETTE object. All colors are initialized to transparent.
	$LF
]p
[h3 id=Gui.palette_set 
	"gui.palette_set
	$LF
]h3
[blockquote 
	" Syntax: none gui.palette_set(PALETTE pal, number idx, number color)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[p 
	"Sets the color index 
	[b 
		"idx
	]b
	" in palette 
	[b 
		"pal
	]b
	" to color 
	[b 
		"color
	]b
	".
	$LF
]p
[h3 id=Gui.bitmap_new 
	"gui.bitmap_new
	$LF
]h3
[blockquote 
	" Syntax: BITMAP gui.bitmap_new(number width, number height, 
	[b 
		"false
	]b
	")
	[br 
	]br
	$LF
	" Syntax: DBITMAP gui.bitmap_new(number width, number height, 
	[b 
		"true
	]b
	")
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[p 
	"Returns a new bitmap of size 
	[b 
		"width
	]b
	" by 
	[b 
		"height
	]b
	".
	$LF
]p
[p 
	"The third argument determines if the bitmap is indexed (false) or not (true).
	$LF
]p
[h3 id=Gui.bitmap_pset 
	"gui.bitmap_pset
	$LF
]h3
[blockquote 
	" Syntax: none gui.bitmap_pset(BITMAP/DBITMAP bmp, number x, number y, number c)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[p 
	"Sets the pixel at (
	[b 
		"x
	]b
	",
	[b 
		"y
	]b
	") in bitmap 
	[b 
		"bmp
	]b
	" to color 
	[b 
		"c
	]b
	".
	$LF
]p
[p 
	"The 
	[b 
		"c
	]b
	" is color index for indexed bitmaps and color for non-indexed ones.
	$LF
]p
[h3 id=Gui.bitmap_size 
	"gui.bitmap_size
	$LF
]h3
[blockquote 
	" Syntax: (Number w, Number h) gui.bitmap_size(BITMAP/DBITMAP bmp)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[p 
	"Returns the width (
	[b 
		"w
	]b
	") and height (
	[b 
		"h
	]b
	") of bitmap 
	[b 
		"bmp
	]b
	".
	$LF
]p
[h3 id=Gui.bitmap_blit 
	"gui.bitmap_blit
	$LF
]h3
[blockquote 
	" Syntax: none gui.bitmap_blit(BITMAP target, number dx, number dy, BITMAP source, number sx, number sy, number w, number h, [number colorkey])
	[br 
	]br
	$LF
	" Syntax: none gui.bitmap_blit(DBITMAP target, number dx, number dy, DBITMAP source, number sx, number sy, number w, number h, [number colorkey])
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere.
		$LF
	]li
	[li 
		" 
		[b 
			"colorkey
		]b
		" defaults to NONE.
		$LF
	]li
]ul
[p 
	"Blits region of size 
	[b 
		"w
	]b
	" by 
	[b 
		"h
	]b
	" starting from (
	[b 
		"sx
	]b
	",
	[b 
		"sy
	]b
	") from 
	[b 
		"source
	]b
	" to region starting from (
	[b 
		"dx
	]b
	",
	[b 
		"dy
	]b
	") in 
	[b 
		"target
	]b
	".
	$LF
]p
[p 
	"If 
	[b 
		"colorkey
	]b
	" is specified, the pixels with that color are not blitted.
	$LF
]p
[p 
	"Note that this copies pixels, not composites those. This matters when copying (partially) transparent regions.
	$LF
]p
[h3 id=Gui.bitmap_load 
	"gui.bitmap_load
	$LF
]h3
[blockquote 
	" Syntax: BITMAP/DBITMAP gui.bitmap_load(string filename)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ4.
		$LF
	]li
	[li 
		" Can be used anywhere
		$LF
	]li
]ul
[p 
	"Loads BITMAP or DBITMAP from file 
	[b 
		"filename
	]b
	" and returns the result.
	$LF
]p
[p 
	"If the result is indexed or not depends on the file.
	$LF
]p
[h3 id=Gui.rainbow 
	"gui.rainbow
	$LF
]h3
[blockquote 
	" Syntax: Number gui.rainbow(Number step, Number steps, Number base)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ6.
		$LF
	]li
	[li 
		" Can be used anywhere
		$LF
	]li
]ul
[p 
	"Performs hue rotation on color 
	[b 
		"base
	]b
	".
	$LF
]p
[p 
	"The rotation is 
	[b 
		"step
	]b
	"/
	[b 
		"steps
	]b
	" of full hue circle. The positive direction is red->yellow->green->cyan->blue->magenta->red.
	$LF
]p
[p 
	"The rotation will preserve saturation, value and opacity.
	$LF
]p
[h2 id=Hostmemoryfunctions 
	"Hostmemory functions
	$LF
]h2
[h3 id=(Generic) 
	"(Generic)
	$LF
]h3
[p 
	"These read/write memory space that is preserved over saves and loads.
	$LF
]p
[p 
	"All functions use little-endian byte order.
	$LF
]p
[p 
	"The data types are:
	$LF
]p
[ul 
	[li 
		" byte (unspecified is byte) is 8 bits.
		$LF
	]li
	[li 
		" word is 16 bits.
		$LF
	]li
	[li 
		" dword is 32 bits.
		$LF
	]li
	[li 
		" qword is 64 bits.
		$LF
	]li
]ul
[h3 id=Hostmemory.read/hostmemory.readbyte/hostmemory.readword/hostmemory.readdword/hostmemory.readqword 
	"hostmemory.read / hostmemory.readbyte / hostmemory.readword / hostmemory.readdword / hostmemory.readqword
	$LF
]h3
[blockquote 
	" Syntax: Number hostmemory.read(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readbyte(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readdword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readqword(Number address)
	$LF
]blockquote
[p 
	"Returns the unsigned value read from address 
	[b 
		"address
	]b
	" (or false if out of bounds). 
	$LF
]p
[h3 id=Hostmemory.readsbyte/hostmemory.readsword/hostmemory.readsdword/hostmemory.readsqword 
	"hostmemory.readsbyte / hostmemory.readsword / hostmemory.readsdword / hostmemory.readsqword
	$LF
]h3
[blockquote 
	" Syntax: Number hostmemory.readsbyte(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readsword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readsdword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.readsqword(Number address)
	$LF
]blockquote
[p 
	"Returns the signed (two's complement) value read from address 
	[b 
		"address
	]b
	" (or false if out of bounds).
	$LF
]p
[h3 id=Hostmemory.write/hostmemory.writebyte/hostmemory.writeword/hostmemory.writedword/hostmemory.writeqword 
	"hostmemory.write / hostmemory.writebyte / hostmemory.writeword / hostmemory.writedword / hostmemory.writeqword
	$LF
]h3
[blockquote 
	" Syntax: Number hostmemory.write(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.writebyte(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.writeword(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.writedword(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: Number hostmemory.writeqword(Number address, Number value)
	$LF
]blockquote
[p 
	"Writes the value 
	[b 
		"value
	]b
	" (two's complement if negative) to address 
	[b 
		"address
	]b
	" (extending memory if out of bounds).
	$LF
]p
[h2 id=Inputfunctions 
	"Input functions
	$LF
]h2
[h3 id=(Generic) 
	"(Generic)
	$LF
]h3
[p 
	"Unless otherwise noted, these are only valid in 
	[b 
		"on_input
	]b
	" callback.
	$LF
]p
[p 
	"Physical controllers 0-3 are on port #1 and controllers 4-7 are on port #2.
	$LF
]p
[p 
	"The control indices are:
	$LF
]p
[table 
	[tbody 
		[tr 
			[td 
				"Index
			]td
			[td 
				"SNES gamepad
			]td
			[td 
				"GB(C) gamepad
			]td
			[td 
				"mouse
			]td
			[td 
				"justifier
			]td
			[td 
				"superscope
			]td
		]tr
		[tr 
			[td 
				"0
			]td
			[td 
				"B
			]td
			[td 
				"A
			]td
			[td 
				"xaxis
			]td
			[td 
				"xaxis
			]td
			[td 
				"xaxis
			]td
		]tr
		[tr 
			[td 
				"1
			]td
			[td 
				"Y
			]td
			[td 
				"B
			]td
			[td 
				"yaxis
			]td
			[td 
				"yaxis
			]td
			[td 
				"yaxis
			]td
		]tr
		[tr 
			[td 
				"2
			]td
			[td 
				"select
			]td
			[td 
				"select
			]td
			[td 
				"L
			]td
			[td 
				"trigger
			]td
			[td 
				"trigger
			]td
		]tr
		[tr 
			[td 
				"3
			]td
			[td 
				"start
			]td
			[td 
				"start
			]td
			[td 
				"R
			]td
			[td 
				"start
			]td
			[td 
				"cursor
			]td
		]tr
		[tr 
			[td 
				"4
			]td
			[td 
				"up
			]td
			[td 
				"right
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"turbo
			]td
		]tr
		[tr 
			[td 
				"5
			]td
			[td 
				"down
			]td
			[td 
				"left
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"pause
			]td
		]tr
		[tr 
			[td 
				"6
			]td
			[td 
				"left
			]td
			[td 
				"up
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"7
			]td
			[td 
				"right
			]td
			[td 
				"down
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"8
			]td
			[td 
				"A
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"9
			]td
			[td 
				"X
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"10
			]td
			[td 
				"L
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
		[tr 
			[td 
				"11
			]td
			[td 
				"R
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
			[td 
				"-
			]td
		]tr
	]tbody
]table
[h3 id=Input.set 
	"input.set
	$LF
]h3
[blockquote 
	" Syntax: none input.set(number controller, number index, number value)
	$LF
]blockquote
[ul 
	[li 
		" This function does nothing in read-only mode.
		$LF
	]li
]ul
[p 
	"Set input on physical controller 
	[b 
		"controller
	]b
	" control index 
	[b 
		"index
	]b
	" to value 
	[b 
		"value
	]b
	".
	$LF
]p
[p 
	"In case of buttons, zero is released, anything else is pressed.
	$LF
]p
[h3 id=Input.get 
	"input.get
	$LF
]h3
[blockquote 
	" Syntax: number input.get(number controller, number index)
	$LF
]blockquote
[p 
	"Returns the value of physical controller 
	[b 
		"controller
	]b
	" input index 
	[b 
		"index
	]b
	".
	$LF
]p
[h3 id=Input.reset 
	"input.reset
	$LF
]h3
[blockquote 
	" Syntax: none input.reset([number delay])
	$LF
]blockquote
[ul 
	[li 
		" Only valid in 
		[b 
			"on_input
		]b
		" callback with subframe flag clear.
		$LF
	]li
	[li 
		" 
		[b 
			"delay
		]b
		" defaults to 0.
		$LF
	]li
	[li 
		" Nonzero 
		[b 
			"delay
		]b
		" since rr1-Δ8.
		$LF
	]li
	[li 
		" This function does nothing in read-only mode.
		$LF
	]li
]ul
[p 
	"Resets console. If 
	[b 
		"delay
	]b
	" is specified and delayed reset is supported, the reset will be delayed by that amount (but still at most one frame).
	$LF
]p
[h3 id=Input.raw 
	"input.raw
	$LF
]h3
[blockquote 
	" Syntax: table input.raw()
	$LF
]blockquote
[ul 
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[p 
	"Returns a table of tables. The outer table is indexed by key name.
	$LF
]p
[p 
	"The inner table has the following fields:
	$LF
]p
[ul 
	[li 
		" last_value: Raw value of input.
		$LF
	]li
]ul
[pre 
	" * For keys, this is 0 for released, 1 for pressed.
	$LF
	" * For mouse, this is coordinate relative to top left of draw area (note that this may be negative!).
	$LF
	" * For axis types, this is raw value of axis.
	$LF
	" * For hats, 1 is up, 2 is right, 4 is down, 8 is left. Diagonals are OR of primary directions.
	$LF
]pre
[ul 
	[li 
		" cal_left: Left/Top calibration limit.
		$LF
	]li
	[li 
		" cal_center: Center calibration value.
		$LF
	]li
	[li 
		" cal_right: Right/Bottom calibration limit.
		$LF
	]li
	[li 
		" cal_tolerance: Tolerance of button (the width of dead zone, 0<x<1).
		$LF
	]li
	[li 
		" ktype: The type of the key.
		$LF
	]li
]ul
[pre 
	" * disabled: Disabled axis.
	$LF
	" * key: Key
	$LF
	" * axis: Axis
	$LF
	" * axis-inverse: Axis (inverted).
	$LF
	" * hat: Hat
	$LF
	" * mouse: Mouse axis.
	$LF
	" * pressure-mp: Pressure-sensitive button, reads cal_left when released, cal_right when pressed.
	$LF
	" * pressure-m0: Pressure-sensitive button, reads cal_left when released, cal_center when pressed.
	$LF
	" * pressure-0m: Pressure-sensitive button, reads cal_center when released, cal_left when pressed.
	$LF
	" * pressure-0p: Pressure-sensitive button, reads cal_center when released, cal_right when pressed.
	$LF
	" * pressure-pm: Pressure-sensitive button, reads cal_right when released, cal_left when pressed.
	$LF
	" * pressure-p0: Pressure-sensitive button, reads cal_right when released, cal_center when pressed.
	$LF
]pre
[p 
	"For mouse axes, cal_left is top/left edge of draw area, cal_center is top/left edge of game area, and cal_right is bottom/right edge of draw area.
	$LF
]p
[h3 id=Input.keyhook 
	"input.keyhook
	$LF
]h3
[blockquote 
	" Syntax: none input.keyhook(string key, boolean enabled)
	$LF
]blockquote
[ul 
	[li 
		" Can be used anywhere.
		$LF
	]li
]ul
[p 
	"If 
	[b 
		"enabled
	]b
	"=true, requests 
	[b 
		"on_keyhook
	]b
	" callback to happen when key 
	[b 
		"key
	]b
	" changes state.
	$LF
]p
[p 
	"If 
	[b 
		"enabled
	]b
	"=false, requests that state changes on key 
	[b 
		"key
	]b
	" do not cause callbacks to 
	[b 
		"on_keyhook
	]b
	".
	$LF
]p
[h3 id=Input.geta 
	"input.geta
	$LF
]h3
[blockquote 
	" Syntax: Tuple input.geta(Number controller)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ5
		$LF
	]li
]ul
[p 
	"Get all input indices of physical controller 
	[b 
		"controller
	]b
	" at once. The returned tuple is in control index order.
	$LF
]p
[h3 id=Input.seta 
	"input.seta
	$LF
]h3
[blockquote 
	" Syntax: none input.seta(Number controller, Number values...)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ5
		$LF
	]li
]ul
[p 
	"Set all input indices of physical controller 
	[b 
		"controller
	]b
	" at once. The 
	[b 
		"value
	]b
	"s are in control index order.
	$LF
]p
[h3 id=Input.joyget 
	"input.joyget
	$LF
]h3
[blockquote 
	" Syntax: table input.joyget(Number controller)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ15
		$LF
	]li
]ul
[p 
	"Returns a table, indexes by control name containing state of logical controller 
	[b 
		"controller
	]b
	".
	$LF
]p
[h3 id=Input.joyset 
	"input.joyset
	$LF
]h3
[blockquote 
	" Syntax: none input.joyset(Number controller, table state)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ14ε1
		$LF
	]li
]ul
[p 
	"Set state of logical controller 
	[b 
		"controller
	]b
	" to 
	[b 
		"state
	]b
	". The 
	[b 
		"state
	]b
	" is indexed by control name.
	$LF
]p
[p 
	"For buttons, nil/false is released, anything else is pressed (normal lua boolean rules).
	$LF
]p
[h2 id=Memoryfunctions 
	"Memory functions
	$LF
]h2
[h3 id=(Generic) 
	"(Generic)
	$LF
]h3
[p 
	"These functions read/write console memory space.
	$LF
]p
[p 
	"The byte order used depends on the target address. Normally it is little-endian, but DSP memory is host-endian.
	$LF
]p
[p 
	"The data types are:
	$LF
]p
[ul 
	[li 
		" byte (unspecified is byte) is 8 bits.
		$LF
	]li
	[li 
		" word is 16 bits.
		$LF
	]li
	[li 
		" dword is 32 bits.
		$LF
	]li
	[li 
		" qword is 64 bits.
		$LF
	]li
]ul
[h3 id=Memory.read/memory.readbyte/memory.readword/memory.readdword/memory.readqword 
	"memory.read / memory.readbyte / memory.readword / memory.readdword / memory.readqword
	$LF
]h3
[blockquote 
	" Syntax: Number memory.read(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readbyte(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readdword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readqword(Number address)
	$LF
]blockquote
[p 
	"Returns the unsigned value read from address 
	[b 
		"address
	]b
	" (out of bounds bytes read as zeroes).
	$LF
]p
[h3 id=Memory.readsbyte/memory.readsword/memory.readsdword/memory.readsqword 
	"memory.readsbyte / memory.readsword / memory.readsdword / memory.readsqword
	$LF
]h3
[blockquote 
	" Syntax: Number memory.readsbyte(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readsword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readsdword(Number address)
	[br 
	]br
	$LF
	" Syntax: Number memory.readsqword(Number address)
	$LF
]blockquote
[p 
	"Returns the signed (two's complement) value read from address 
	[b 
		"address
	]b
	" (out of bounds bytes read as zeroes).
	$LF
]p
[h3 id=Memory.write/memory.writebyte/memory.writeword/memory.writedword/memory.writeqword 
	"memory.write / memory.writebyte / memory.writeword / memory.writedword / memory.writeqword
	$LF
]h3
[blockquote 
	" Syntax: None memory.write(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: None memory.writebyte(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: None memory.writeword(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: None memory.writedword(Number address, Number value)
	[br 
	]br
	$LF
	" Syntax: None memory.writeqword(Number address, Number value)
	$LF
]blockquote
[p 
	"Writes the value 
	[b 
		"value
	]b
	" (two's complement if negative) to address 
	[b 
		"address
	]b
	" (writes out of bounds are ignored).
	$LF
]p
[h3 id=Memory.mapbyte/memory.mapsbyte/memory.mapword/memory.mapsword/memory.mapdword/memory.mapsdword/memory.mapqword/memory.mapsqword 
	"memory.mapbyte / memory.mapsbyte / memory.mapword / memory.mapsword / memory.mapdword / memory.mapsdword / memory.mapqword / memory.mapsqword
	$LF
]h3
[blockquote 
	" Syntax: Table memory.map<type>()
	[br 
	]br
	$LF
	" Syntax: Table memory.map<type>(Number base, Number aperturesize)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ15ε2
		$LF
	]li
]ul
[p 
	"Map area of size 
	[b 
		"aperturesize
	]b
	" starting from 
	[b 
		"base
	]b
	" (the entire map space if not specified) with specified type.
	$LF
]p
[p 
	"The returned table can be read/written to read/write console memory space.
	$LF
]p
[p 
	"The index values to this table are measured in bytes.
	$LF
]p
[h3 id=Memory.map_structure() 
	"memory.map_structure()
	$LF
]h3
[blockquote 
	" Syntax: MAP_STRUCTURE memory.map_structure()
	[br 
	]br
	$LF
	" Syntax: none MAP_STRUCTURE(String field, Number address, String type)
	[br 
	]br
	$LF
	" Syntax: MAP_STRUCTURE:<field>
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ15ε2
		$LF
	]li
]ul
[p 
	"Returns an object that works like a structure that maps console memory variables as fields.
	$LF
]p
[p 
	"On call to object, the field 
	[b 
		"field
	]b
	" is mapped to memory address 
	[b 
		"address
	]b
	" (with type 
	[b 
		"type
	]b
	", which can be "byte", "sbyte", "word", "sword", "dword", "sdword", "qword" or "sqword").
	$LF
]p
[h3 id=Memory.vma_count 
	"memory.vma_count
	$LF
]h3
[blockquote 
	" Syntax: number memory.vma_count()
	$LF
]blockquote
[p 
	"Returns the number of VMAs active.
	$LF
]p
[h3 id=Memory.read_vma 
	"memory.read_vma
	$LF
]h3
[blockquote 
	" Syntax: Table/Nil memory.read_vma(Number vma)
	$LF
]blockquote
[p 
	"Returns a table (Nil if index is out of range) about 
	[b 
		"vma
	]b
	"th VMA (zero-based).
	$LF
]p
[p 
	"The returned table has the following fields:
	$LF
]p
[ul 
	[li 
		" region_name: Readable name of region
		$LF
	]li
	[li 
		" baseaddr: Starting address of region.
		$LF
	]li
	[li 
		" size: Size of region in bytes.
		$LF
	]li
	[li 
		" lastaddr: Last address belonging to the region.
		$LF
	]li
	[li 
		" readonly: True if VMA is read-only, false if VMA is writable.
		$LF
	]li
	[li 
		" native_endian: True if VMA is native-endian, false if little-endian.
		$LF
	]li
]ul
[p 
	"Invalid VMA index causes nil to be returned.
	$LF
]p
[h3 id=Memory.find_vma 
	"memory.find_vma
	$LF
]h3
[blockquote 
	" Syntax: Table/Nil memory.find_vma(Number address)
	$LF
]blockquote
[p 
	"Return the information (the same table as returned by memory.read_vma) about the VMA where address 
	[b 
		"address
	]b
	" belongs to.
	$LF
]p
[p 
	"If the address 
	[b 
		"address
	]b
	" is not covered by any VMA, returns nil.
	$LF
]p
[h3 id=Memory.hash_state 
	"memory.hash_state
	$LF
]h3
[blockquote 
	" Syntax: String memory.hash_state()
	$LF
]blockquote
[p 
	"Return hash (hexadecimal) of state of the entire system. Mainly useful for debugging core savestate code.
	$LF
]p
[h3 id=Memory.hash_region 
	"memory.hash_region
	$LF
]h3
[blockquote 
	" Syntax: String memory.hash_region(Number base, Number size)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ8
		$LF
	]li
]ul
[p 
	"Returns the SHA-256 hash (hexadecimal) of the contents of memory in region of size 
	[b 
		"size
	]b
	" starting from 
	[b 
		"base
	]b
	".
	$LF
]p
[h3 id=Memory.readregion 
	"memory.readregion
	$LF
]h3
[blockquote 
	" Syntax: Table memory.readregion(Number base, Number size)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ15ε2
		$LF
	]li
]ul
[p 
	"Returns a table (zero-based) containing the byte values of memory region of size 
	[b 
		"size
	]b
	" starting from 
	[b 
		"base
	]b
	".
	$LF
]p
[p 
	"Note that behavior is undefined if the specified range crosses a VMA boundary.
	$LF
]p
[h3 id=Memory.writeregion 
	"memory.writeregion
	$LF
]h3
[blockquote 
	" Syntax: None memory.writeregion(Number base, Number size, Table data)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ15ε2
		$LF
	]li
]ul
[p 
	"Writes contents of tabe 
	[b 
		"data
	]b
	" (zero-based) as byte values to memory region of size 
	[b 
		"size
	]b
	" starting from 
	[b 
		"base
	]b
	".
	$LF
]p
[p 
	"Note that behavior is undefined if the specified range crosses a VMA boundary.
	$LF
]p
[h2 id=Moviefunctions 
	"Movie functions
	$LF
]h2
[h3 id=Movie.currentframe 
	"movie.currentframe
	$LF
]h3
[blockquote 
	" Syntax: Number movie.currentframe()
	$LF
]blockquote
[p 
	"Returns the current frame number. 
	$LF
]p
[h3 id=Movie.framecount 
	"movie.framecount
	$LF
]h3
[blockquote 
	" Syntax: Number movie.framecount()
	$LF
]blockquote
[p 
	"Returns the number of frames in movie.
	$LF
]p
[h3 id=Movie.readonly 
	"movie.readonly
	$LF
]h3
[blockquote 
	" Syntax: Boolean movie.readonly()
	$LF
]blockquote
[p 
	"Returns true in readonly mode, otherwise false.
	$LF
]p
[h3 id=Movie.readwrite 
	"movie.readwrite
	$LF
]h3
[blockquote 
	" Syntax: none movie.readwrite()
	$LF
]blockquote
[p 
	"Set readwrite mode.
	$LF
]p
[p 
	"Note: Does not trigger callback to 
	[b 
		"on_readwrite
	]b
	".
	$LF
]p
[h3 id=Movie.frame_subframes 
	"movie.frame_subframes
	$LF
]h3
[blockquote 
	" Syntax: Number movie.frame_subframes(Number frame)
	$LF
]blockquote
[p 
	"Returns the number of subframes in frame 
	[b 
		"frame
	]b
	".
	$LF
]p
[h3 id=Movie.read_subframes 
	"movie.read_subframes
	$LF
]h3
[blockquote 
	" Syntax: Table movie.read_subframes(Number frame, Number subframe)
	$LF
]blockquote
[p 
	"Reads subframe 
	[b 
		"subframe
	]b
	" (0-based) of frame 
	[b 
		"frame
	]b
	".
	$LF
]p
[p 
	"Return value is a table with numeric indices:
	$LF
]p
[ul 
	[li 
		" 0: Frame sync flag.
		$LF
	]li
	[li 
		" 1: Reset flag.
		$LF
	]li
	[li 
		" 2: Delay field low (units of 0).
		$LF
	]li
	[li 
		" 3: Delay field high (units of 10000)
		$LF
	]li
	[li 
		" 4-99: Controller buttons/axes.
		$LF
	]li
]ul
[p 
	"The index i of controller c is at table index 12 * c + i + 4.
	$LF
]p
[p 
	"Buttons/flags read as 0 (released, not set) or 1 (pressed, set).
	$LF
]p
[h3 id=Movie.read_rtc 
	"movie.read_rtc
	$LF
]h3
[blockquote 
	" Syntax: (Number seconds, Number sseconds) movie.read_rtc()
	$LF
]blockquote
[p 
	"Returns the current RTC time. 
	[b 
		"seconds
	]b
	" is in whole seconds (since 19700101T000000Z) and 
	[b 
		"sseconds
	]b
	" is  subsecond ticks (32040.5*768 per second for SNES, 32768*64 per second for second for GB(C)) in second.
	$LF
]p
[h3 id=Movie.unsafe_rewind 
	"movie.unsafe_rewind
	$LF
]h3
[blockquote 
	" Syntax: none movie.unsafe_rewind()
	$LF
	" Syntax: none movie.unsafe_rewind(UNSAFEREWIND r)
	$LF
]blockquote
[ul 
	[li 
		" Since rr1-Δ9.
		$LF
	]li
]ul
[p 
	"If called without parameters, triggers call to 
	[b 
		"on_set_rewind
	]b
	" with state.
	$LF
]p
[p 
	"If called with parameter 
	[b 
		"r
	]b
	", rewinds to that state.
	$LF
]p
[p 
	"The state rewinded must be in past or the results are undefined.
	$LF
]p
[h3 id=Movie.rerecords 
	"movie.rerecords
	$LF
]h3
[blockquote 
	" Syntax: Number movie.rerecords()
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ14.
		$LF
	]li
]ul
[p 
	"Returns the current rerecord count.
	$LF
]p
[h2 id=Settingsfunctions 
	"Settings functions
	$LF
]h2
[h3 id=(Generic) 
	"(Generic)
	$LF
]h3
[p 
	"On failure, the first return value is nil and the second is error message.
	$LF
]p
[h3 id=Settings.set 
	"settings.set
	$LF
]h3
[blockquote 
	" Syntax: true settings.set(String name, String value)
	$LF
]blockquote
[p 
	"Sets setting 
	[b 
		"name
	]b
	" to value 
	[b 
		"value
	]b
	". 
	$LF
]p
[h3 id=Setting.get 
	"setting.get
	$LF
]h3
[blockquote 
	" Syntax: String/false settings.get(String name)
	$LF
]blockquote
[p 
	"Reads setting 
	[b 
		"name
	]b
	". Returns value or false if setting is not set.
	$LF
]p
[h3 id=Setting.blank 
	"setting.blank
	$LF
]h3
[blockquote 
	" Syntax: true setting.blank(String name)
	$LF
]blockquote
[p 
	"Blanks setting 
	[b 
		"name
	]b
	". Returns true on success.
	$LF
]p
[h3 id=Setting.is_set 
	"setting.is_set
	$LF
]h3
[blockquote 
	" Syntax: boolean setting.is_set(String name)
	$LF
]blockquote
[p 
	"Checks if setting 
	[b 
		"name
	]b
	" is set. Returns true if it is, false if it isn't.
	$LF
]p
[h2 id=Misc.functions 
	"Misc. functions
	$LF
]h2
[h3 id=Exec 
	"exec
	$LF
]h3
[blockquote 
	" Syntax: none exec(String cmd)
	$LF
]blockquote
[p 
	"Invokes emulator command 
	[b 
		"cmd
	]b
	".
	$LF
]p
[h3 id=Print 
	"print
	$LF
]h3
[blockquote 
	" Syntax: none print(...)
	$LF
]blockquote
[p 
	"Print value(s)
	$LF
]p
[p 
	"Prints values of all arguments (note: Table, function, thread, light userdata and userdata values can't be printed). The arguments are printed separated by tabs.
	$LF
]p
[h3 id=Utime 
	"utime
	$LF
]h3
[blockquote 
	" Syntax: (Number secs, Number usecs) utime()
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[p 
	"Return the current time. 
	[b 
		"secs
	]b
	" is the number of seconds since 19700101T000000Z. 
	[b 
		"usecs
	]b
	" is the number of microseconds within second.
	$LF
]p
[h3 id=Emulator_ready 
	"emulator_ready
	$LF
]h3
[blockquote 
	" Syntax: boolean emulator_ready()
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[p 
	"Returns true if on_startup has already been called, false otherwise.
	$LF
]p
[h3 id=Set_idle_timeout 
	"set_idle_timeout
	$LF
]h3
[blockquote 
	" Syntax: none set_idle_timeout(Number microsecs)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[p 
	"After 
	[b 
		"microsecs
	]b
	" microseconds have passed and the emulator is idle, call the on_idle callback.
	$LF
]p
[h3 id=Set_timer_timeout 
	"set_timer_timeout
	$LF
]h3
[blockquote 
	" Syntax: none set_timer_timeout(Number microsecs)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[p 
	"After 
	[b 
		"microsecs
	]b
	" microseconds have passed, call the on_timer callback.
	$LF
]p
[h3 id=Bus_address 
	"bus_address
	$LF
]h3
[blockquote 
	" Syntax: Number bus_address(Number address)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ10.
		$LF
	]li
]ul
[p 
	"Returns the map address corresponding to address 
	[b 
		"address
	]b
	" on physical console bus.
	$LF
]p
[p 
	"Currently only supported for SNES & co.
	$LF
]p
[h3 id=Loopwrapper( 
	"loopwrapper(
	$LF
]h3
[blockquote 
	" Syntax: Function loopwrapper(Function fn, ...)
	$LF
]blockquote
[ul 
	[li 
		" Since: rr1-Δ14ε1
		$LF
	]li
]ul
[p 
	"First calls function 
	[b 
		"fn
	]b
	" with function suspending the execution of the function when called and any remaining arguments.
	$LF
]p
[p 
	"When the function calls the suspend function, loopwrapper returns function that will resume 
	[b 
		"fn
	]b
	" when called.
	$LF
]p
[p 
	"The suspend function returns the values passed to resume function as parameters.
	$LF
]p
[p 
	"This is handy for using functions that have internal loops, that need to run over a long time, as callbacks.
	$LF
]p
[h2 id=Callbacks 
	"Callbacks
	$LF
]h2
[h3 id=(Generic) 
	"(Generic)
	$LF
]h3
[p 
	"These all are defined by Lua scripts.
	$LF
]p
[p 
	"Return fast from these hooks or the performance suffers. Not returning at all locks up the emulator.
	$LF
]p
[h3 id=On_paint 
	"on_paint
	$LF
]h3
[p 
	"Called when screen is rerendered. Any draw primitives here affect the drawn screen.
	$LF
]p
[p 
	"Parameter: boolean non_synthetic
	$LF
]p
[p 
	[b 
		"non_synthetic
	]b
	" is true if 
	[b 
		"on_paint
	]b
	" is triggered by actual frame from console or by a subframe (if requested). It is false for calls triggered by gui.request_paint().
	$LF
]p
[h3 id=On_video 
	"on_video
	$LF
]h3
[p 
	"Called when video frame is rendered. Any draw primitives here affect dumped video frame.
	$LF
]p
[ul 
	[li 
		" May be called multiple times per frame if multiple dumpers are active.
		$LF
	]li
	[li 
		" SDMP dumper does not call this.
		$LF
	]li
]ul
[h3 id=On_input 
	"on_input
	$LF
]h3
[p 
	"Called when input for frame is decided. May change the input in readwrite mode.
	$LF
]p
[p 
	"Parameter: boolean subframe
	$LF
]p
[p 
	[b 
		"subframe
	]b
	" is true if this is in response to subframe. Otherwise false.
	$LF
]p
[h3 id=On_reset 
	"on_reset
	$LF
]h3
[p 
	"Called when console resets.
	$LF
]p
[h3 id=On_frame 
	"on_frame
	$LF
]h3
[p 
	"Called after frame has completed (after 
	[b 
		"on_paint
	]b
	")
	$LF
]p
[h3 id=On_readwrite 
	"on_readwrite
	$LF
]h3
[p 
	"Called when entering readwrite mode.
	$LF
]p
[h3 id=On_startup 
	"on_startup
	$LF
]h3
[p 
	"Called when the emulator starts up.
	$LF
]p
[h3 id=On_pre_load 
	"on_pre_load
	$LF
]h3
[ul 
	[li 
		" Parameter #1: String savename
		$LF
	]li
]ul
[p 
	"Called before loading a savestate or movie.
	$LF
]p
[p 
	"Parameter: String 
	[b 
		"name
	]b
	$LF
]p
[p 
	"The name of savestate or movie to load is passed as 
	[b 
		"name
	]b
	".
	$LF
]p
[h3 id=On_err_load 
	"on_err_load
	$LF
]h3
[p 
	"Called if loading savestate or movie failed.
	$LF
]p
[p 
	"Parameter: String 
	[b 
		"name
	]b
	$LF
]p
[p 
	"The name of savestate or movie attempted to load is passed as 
	[b 
		"name
	]b
	".
	$LF
]p
[h3 id=On_post_load 
	"on_post_load
	$LF
]h3
[p 
	"Called if loading savestate or movie succeeded.
	$LF
]p
[ul 
	[li 
		" Parameter: String name
		$LF
	]li
	[li 
		" Parameter: boolean is_state.
		$LF
	]li
]ul
[p 
	"The name of savestate/movie is 
	[b 
		"name
	]b
	". 
	[b 
		"is_state
	]b
	" is true if savestate, false for movies.
	$LF
]p
[h3 id=On_pre_save 
	"on_pre_save
	$LF
]h3
[p 
	"Called before saving savestate or movie (except if movie save was requested from Lua).
	$LF
]p
[ul 
	[li 
		" Parameter: String name
		$LF
	]li
	[li 
		" Parameter: boolean is_state.
		$LF
	]li
]ul
[p 
	[b 
		"name
	]b
	" is the name of savestate or movie. 
	[b 
		"is_state
	]b
	" is true if this is savestate, false if movie.
	$LF
]p
[h3 id=On_err_save 
	"on_err_save
	$LF
]h3
[p 
	"Called if saving savestate or movie failed (except if movie save was requested from Lua).
	$LF
]p
[ul 
	[li 
		" Parameter: String name
		$LF
	]li
]ul
[p 
	[b 
		"name
	]b
	" is the name of savestate or movie that failed to save.
	$LF
]p
[h3 id=On_post_save 
	"on_post_save
	$LF
]h3
[p 
	"Called if saving savestate or movie succeeded (except if movie save was requested from Lua).
	$LF
]p
[ul 
	[li 
		" Parameter: String name
		$LF
	]li
	[li 
		" Parameter: boolean is_state.
		$LF
	]li
]ul
[p 
	[b 
		"name
	]b
	" is the name of savestate or movie. 
	[b 
		"is_state
	]b
	" is true if this is savestate, false if movie.
	$LF
]p
[h3 id=On_snoop 
	"on_snoop
	$LF
]h3
[p 
	"Called just before answering a poll from emulator core. Can't alter the result.
	$LF
]p
[ul 
	[li 
		" Parameter: number port
		$LF
	]li
	[li 
		" Parameter: number controller
		$LF
	]li
	[li 
		" Parameter: number index
		$LF
	]li
	[li 
		" Parameter: number value.
		$LF
	]li
]ul
[p 
	"The poll is for port 
	[b 
		"port
	]b
	", controller 
	[b 
		"controller
	]b
	", control index 
	[b 
		"index
	]b
	" and the value to be returned is 
	[b 
		"value
	]b
	".
	$LF
]p
[h3 id=On_quit 
	"on_quit
	$LF
]h3
[p 
	"Called just before the emulator quits.
	$LF
]p
[h3 id=On_keyhook 
	"on_keyhook
	$LF
]h3
[p 
	"Called if status of key has changed (and callbacks have been requested for that key).
	$LF
]p
[ul 
	[li 
		" Parameter: String key
		$LF
	]li
	[li 
		" Parameter: Table state
		$LF
	]li
]ul
[p 
	"The key state change is for is 
	[b 
		"key
	]b
	". 
	[b 
		"state
	]b
	" is state table, in the same format  as the inner tables of input.raw.
	$LF
]p
[h3 id=On_set_rewind 
	"on_set_rewind
	$LF
]h3
[p 
	"Called when unsafe rewind point has been set up.
	$LF
]p
[ul 
	[li 
		" Parameter: UNSAFEREWIND state
		$LF
	]li
]ul
[p 
	"The state object is passed as 
	[b 
		"state
	]b
	".
	$LF
]p
[h3 id=On_pre_rewind 
	"on_pre_rewind
	$LF
]h3
[p 
	"Called just before unsafe rewind occurs.
	$LF
]p
[h3 id=On_post_rewind 
	"on_post_rewind
	$LF
]h3
[p 
	"Called just after unsafe rewind has occured.
	$LF
]p
[h3 id=On_frame_emulated 
	"on_frame_emulated
	$LF
]h3
[ul 
	[li 
		" Since: rr1-Δ5.
		$LF
	]li
]ul
[p 
	"Called just after frame emulation finishes, but before 
	[b 
		"on_paint
	]b
	".
	$LF
]p
[h3 id=On_idle 
	"on_idle
	$LF
]h3
[p 
	"Called when the specified idle timeout expires and the emulator is idle.
	$LF
]p
[h3 id=On_timer 
	"on_timer
	$LF
]h3
[p 
	"Called when the specified timer timeout expires.
	$LF
]p
