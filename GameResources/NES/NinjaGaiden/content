45
[div class= 
	[ul class=nav nav-tabs role=tablist 
		[li class=nav-item 
			[a class=active nav-link data-toggle=tab href=#tabs-26-0 
				"Table of contents
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#tabs-26-1 
				"RAM Map
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#tabs-26-2 
				"Lua Scripts
			]a
		]li
		[li class=nav-item 
			[a class=nav-link data-toggle=tab href=#tabs-26-3 
				"Symbolic Namelists
			]a
		]li
	]ul
	[div class=tab-content 
		[div class=tab-pane active id=tabs-26-0 
			[div class=toc 
				[ul 
					[li 
						[a href=#Movement
 
							" Movement
							$LF
						]a
					]li
					[li 
						[ul 
							[li 
								[a href=#HorizontalMovement
 
									" Horizontal Movement
									$LF
								]a
							]li
							[li 
								[ul 
									[li 
										[a href=#Preservingspeed
 
											" Preserving speed
											$LF
										]a
									]li
									[li 
										[a href=#StickyFloors
 
											" Sticky Floors
											$LF
										]a
									]li
								]ul
							]li
							[li 
								[a href=#VerticalMovement
 
									" Vertical Movement
									$LF
								]a
							]li
							[li 
								[ul 
									[li 
										[a href=#RecoveryWalljump
 
											" Recovery Walljump
											$LF
										]a
									]li
									[li 
										[a href=#Wall-Climbing
 
											" Wall-Climbing
											$LF
										]a
									]li
								]ul
							]li
						]ul
					]li
					[li 
						[a href=#Attacking
 
							" Attacking
							$LF
						]a
					]li
					[li 
						[a href=#Randomnessandmanipulation
 
							" Randomness and manipulation
							$LF
						]a
					]li
					[li 
						[ul 
							[li 
								[a href=#Knifetossers
 
									" Knife tossers
									$LF
								]a
							]li
							[li 
								[a href=#Tysons
 
									" Tysons
									$LF
								]a
							]li
							[li 
								[a href=#Birds
 
									" Birds
									$LF
								]a
							]li
							[li 
								[a href=#Bats
 
									" Bats
									$LF
								]a
							]li
							[li 
								[a href=#Cheetahs
 
									" Cheetahs
									$LF
								]a
							]li
							[li 
								[a href=#InheritedSub-Pixels(andmanipulation)
 
									" Inherited Sub-Pixels (and manipulation)
									$LF
								]a
							]li
							[li 
								[a href=#Spawns,theirdelaysandcancellations
 
									" Spawns, their delays and cancellations
									$LF
								]a
							]li
							[li 
								[a href=#Interrupts
 
									" Interrupts
									$LF
								]a
							]li
							[li 
								[a href=#LevelTimer
 
									" Level Timer
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#Glitcheswithnoknownapplication
 
							" Glitches with no known application
							$LF
						]a
					]li
					[li 
						[ul 
							[li 
								[a href=#Takingdamageatthesametimeabossiskilled
 
									" Taking damage at the same time a boss is killed
									$LF
								]a
							]li
							[li 
								[a href=#Verticalscreen-wrapping
 
									" Vertical screen-wrapping
									$LF
								]a
							]li
							[li 
								[a href=#MakingEnemiesFallfromPlatforms
 
									" Making Enemies Fall from Platforms
									$LF
								]a
							]li
							[li 
								[a href=#Thatonethingwhereyoupassthroughanenemyorgrabapower-upandgraphicsglitchoutforaframe
 
									" that one thing where you pass through an enemy or grab a power-up and graphics glitch out for a frame
									$LF
								]a
							]li
						]ul
					]li
				]ul
			]div
		]div
		[div class=tab-pane fade id=tabs-26-1 
			[table 
				[tbody 
					[tr 
						[th 
							"Address
						]th
						[th 
							"Description
						]th
					]tr
					[tr 
						[td 
							"0060
							[br 
							]br
							"0061
						]td
						[td 
							"Score, little endian. Game can only display 4 digits; "00" on the right of score display is static.
						]td
					]tr
					[tr 
						[td 
							"0062
						]td
						[td 
							"Timer fractions. Cycles 60-0, normally decrementing once per frame during game play.
						]td
					]tr
					[tr 
						[td 
							"0063
						]td
						[td 
							"Level Timer. Decrements when $0062 = 60.
						]td
					]tr
					[tr 
						[td 
							"0064
						]td
						[td 
							"Ninpo (Points used for special attacks)
						]td
					]tr
					[tr 
						[td 
							"0065
						]td
						[td 
							"Ryu's Hit Points
						]td
					]tr
					[tr 
						[td 
							"0066
						]td
						[td 
							"Enemy HP Display (separate from actual enemy HP, stored at $0490-0497)
						]td
					]tr
					[tr 
						[td 
							"0067-006C
						]td
						[td 
							"Level Scrolling
						]td
					]tr
					[tr 
						[td 
							"006D
							[br 
							]br
							"006E
						]td
						[td 
							"Current Stage
						]td
					]tr
					[tr 
						[td 
							"006F
						]td
						[td 
							"Related to stage transitions
						]td
					]tr
					[tr 
						[td 
							"0075
						]td
						[td 
							"TODO: explain this
						]td
					]tr
					[tr 
						[td 
							"0076
						]td
						[td 
							"Ryu's Lives
						]td
					]tr
					[tr 
						[td 
							"0080-0083
						]td
						[td 
							"Ryu's Animations
						]td
					]tr
					[tr 
						[td 
							"0084
						]td
						[td 
							"Ryu's facing and state (standing/jumping/clinging to wall/etc.)
						]td
					]tr
					[tr 
						[td 
							"0085
						]td
						[td 
							"Ryu's x position, fractions
						]td
					]tr
					[tr 
						[td 
							"0086
						]td
						[td 
							"Ryu's x position, pixels
						]td
					]tr
					[tr 
						[td 
							"0087
						]td
						[td 
							"Ryu's y speed, fractions
						]td
					]tr
					[tr 
						[td 
							"0089
						]td
						[td 
							"Ryu's y speed, pixels
						]td
					]tr
					[tr 
						[td 
							"008A
						]td
						[td 
							"Ryu's y position
						]td
					]tr
					[tr 
						[td 
							"0092
						]td
						[td 
							"0x00 until Ryu uses his sword, after which it is 0x10, meaning the first sword attack after the game starts is always ineffective. First jumping slash after having used Spin Slash also affected.
						]td
					]tr
					[tr 
						[td 
							"0095
						]td
						[td 
							"Invulnerability timer, runs 60-0 starting when Ryu takes damage.
						]td
					]tr
					[tr 
						[td 
							"0096-009F
						]td
						[td 
							"pointers
						]td
					]tr
					[tr 
						[td 
							"00A2
						]td
						[td 
							"Screen position, fractions
						]td
					]tr
					[tr 
						[td 
							"00A3
						]td
						[td 
							"Screen position, pixels
						]td
					]tr
					[tr 
						[td 
							"00AC
						]td
						[td 
							"Ryu's x speed, fractions
						]td
					]tr
					[tr 
						[td 
							"00AD
						]td
						[td 
							"Ryu's x speed, pixels
						]td
					]tr
					[tr 
						[td 
							"00B5
						]td
						[td 
							"Object spawn iterator (increments 8 times a frame)
						]td
					]tr
					[tr 
						[td 
							"00BF
						]td
						[td 
							"Global Timer
						]td
					]tr
					[tr 
						[td 
							"00C9
						]td
						[td 
							"Current Special Weapon.
							[br 
							]br
							"$00=None
							[br 
							]br
							"$80=Art of the Fire Wheel
							[br 
							]br
							"$81=Throwing Star
							[br 
							]br
							"$82=Windmill Star
							[br 
							]br
							"$84=Invincible Fire Wheel
							[br 
							]br
							"$85=Jump and Slash
						]td
					]tr
					[tr 
						[td 
							"02xx
						]td
						[td 
							"Sprite Data
						]td
					]tr
					[tr 
						[td 
							"03xx
						]td
						[td 
							"Background Data
						]td
					]tr
					[tr 
						[td 
							"0400-0407
						]td
						[td 
							"Enemy ID
						]td
					]tr
					[tr 
						[td 
							"0408-040F
						]td
						[td 
							"Frames until enemy action (changing direction, throwing/shooting stuff)
						]td
					]tr
					[tr 
						[td 
							"0438-043F
						]td
						[td 
							"Enemy movement
						]td
					]tr
					[tr 
						[td 
							"0440-0447
						]td
						[td 
							"Enemy facing (left/right)
						]td
					]tr
					[tr 
						[td 
							"0448-044F
						]td
						[td 
							"Enemy x speed, fractions
						]td
					]tr
					[tr 
						[td 
							"0450-0457
						]td
						[td 
							"Enemy x speed, pixels
						]td
					]tr
					[tr 
						[td 
							"0458-045F
						]td
						[td 
							"Enemy x position, fractions
						]td
					]tr
					[tr 
						[td 
							"0460-0467
						]td
						[td 
							"Enemy x position, pixels
						]td
					]tr
					[tr 
						[td 
							"0468-046F
						]td
						[td 
							"Enemy y speed, fractions
						]td
					]tr
					[tr 
						[td 
							"0470-0477
						]td
						[td 
							"Enemy y speed, pixels
						]td
					]tr
					[tr 
						[td 
							"0478-047F
						]td
						[td 
							"Enemy y position, fractions
						]td
					]tr
					[tr 
						[td 
							"0480-0487
						]td
						[td 
							"Enemy y position, pixels
						]td
					]tr
					[tr 
						[td 
							"0490-0497
						]td
						[td 
							"Enemy hit points (only non-zero for bosses and those grey disc-tossers)
						]td
					]tr
					[tr 
						[td 
							"04B8-04BA
						]td
						[td 
							"Boss Explosion Animations
						]td
					]tr
					[tr 
						[td 
							"04BB
						]td
						[td 
							"Spec. Weapon C x position
						]td
					]tr
					[tr 
						[td 
							"04BC
						]td
						[td 
							"Spec. Weapon B x position
						]td
					]tr
					[tr 
						[td 
							"04BD
						]td
						[td 
							"Spec. Weapon A x position
						]td
					]tr
					[tr 
						[td 
							"04BE
						]td
						[td 
							"Spec. Weapon C y position
						]td
					]tr
					[tr 
						[td 
							"04BF
						]td
						[td 
							"Spec. Weapon B y position
						]td
					]tr
					[tr 
						[td 
							"04C0
						]td
						[td 
							"Spec. Weapon A y position
						]td
					]tr
					[tr 
						[td 
							"04C1-04C6
						]td
						[td 
							"Spec. Weapon Speed (used differently for each weapon)
						]td
					]tr
					[tr 
						[td 
							"04C7
						]td
						[td 
							"Spec. Weapon time-out, fractions (hourglass, invincible fire wheel)
						]td
					]tr
					[tr 
						[td 
							"04C8
						]td
						[td 
							"Spec. Weapon time-out (hourglass, invincible fire wheel)
						]td
					]tr
					[tr 
						[td 
							"04D0-04D7
						]td
						[td 
							"Lantern(or bug or bird)/Power-Up x position, fractions
						]td
					]tr
					[tr 
						[td 
							"04D8-04DF
						]td
						[td 
							"Lantern/PU x position, pixels
						]td
					]tr
					[tr 
						[td 
							"04E0-04E7
						]td
						[td 
							"Lantern/PU y position, pixels (no fractions for this)
						]td
					]tr
					[tr 
						[td 
							"04E8-04EF
						]td
						[td 
							"Frames until power-up vanishes
						]td
					]tr
					[tr 
						[td 
							"05xx
						]td
						[td 
							"Unused
						]td
					]tr
					[tr 
						[td 
							"06xx
						]td
						[td 
							"Sound
						]td
					]tr
				]tbody
			]table
		]div
		[div class=tab-pane fade id=tabs-26-2 
			[pre 
				[code class=language-lua 
					"--Displays most of the RAM addresses relevant to making a TAS over or around the game's info display.
					$LF
					"local function NGRAMview()
					$LF
					"  yspd = memory.readbytesigned(0x89) + (memory.readbyte(0x87)/256)
					$LF
					"  xpos = memory.readbyte(0x86) + (memory.readbyte(0x85)/256)
					$LF
					"  ypos = memory.readbyte(0x8A)
					$LF
					"  scrnpos = memory.readbyte(0xA3); scrnsub = memory.readbyte(0xA2)
					$LF
					"  timerf = memory.readbyte(0x62); timer = memory.readbyte(0x63)
					$LF
					"  rnga = memory.readbyte(0xB5); rngb = memory.readbyte(0xBF)
					$LF
					"  ninpo = memory.readbyte(0x64)
					$LF
					"  bosshp = memory.readbyte(0x497); abosshp = memory.readbyte(0x496)
					$LF
					"  inv = memory.readbyte(0x95)
					$LF
					"  gui.text(25,9,string.format("Y-Spd:%6.3f",yspd))
					$LF
					"  gui.text(25,17,string.format("Position: %5.1f, %3d",scrnpos+xpos+(scrnsub/256),ypos))
					$LF
					"  gui.text(129,17,string.format("[%05.1f+%02X,%02X]",xpos,scrnpos,scrnsub))
					$LF
					"  gui.text(73,33,string.format("%3d:%02d",timer,timerf))
					$LF
					"  if bosshp > 0 then
					$LF
					"   if bosshp > 16 then gui.text(177,41,string.format("%02d",abosshp))
					$LF
					"    else gui.text(177,41,string.format("%02d",bosshp)); end; end
					$LF
					"  if inv > 0 then
					$LF
					"   gui.text(229,33,string.format("%02d",inv));end
					$LF
					"  gui.text(208,17,string.format("B5:%3d ",rnga))
					$LF
					"  gui.text(208,25,string.format("BF:%3d ",rngb))
					$LF
					"  gui.text(81,41,string.format("[%02d]",ninpo))
					$LF
					"end
					$LF
					"gui.register(NGRAMview)
					$LF
					"emu.frameadvance()
					$LF
				]code
			]pre
			[pre 
				[code class=language-lua 
					"--Accurately tracks the game's inaccurate conception of time, displaying how many "seconds" elapse over the course of a game session.
					$LF
					"--Obviously, it is not smart enough to account for save states, but here it is in case somebody finds this interesting.
					$LF
					"local minutes=0;seconds=0;frames=0
					$LF
					"while true do
					$LF
					" prevt = memory.readbyte(0x62)
					$LF
					" emu.frameadvance()
					$LF
					" currt = memory.readbyte(0x62)
					$LF
					" if prevt ~= currt then
					$LF
					"  frames=frames+1;end
					$LF
					" if frames == 61 then
					$LF
					"  seconds=seconds+1;frames=0;end
					$LF
					" if seconds == 60 then
					$LF
					"  minutes=minutes+1;seconds=0;end
					$LF
					" gui.text(199,9,string.format("%02d:%02d:%02d",minutes,seconds,frames))
					$LF
					"end
					$LF
				]code
			]pre
			[pre 
				[code class=language-lua 
					"curves = {}
					$LF
					"function PredictBird()
					$LF
					"	-- feos, 2014
					$LF
					"	-- draws birds trajectories
					$LF
					"	-- color marks direction
					$LF
					"	for slot = 0, 7 do
					$LF
					"		if (memory.readbyte(0x400 + slot) ~= 11) or (memory.readbyte(0x498 + slot) == 0) then
					$LF
					"			curves.slot = nil
					$LF
					"		else
					$LF
					"			if (curves.slot == nil) then curves.slot = {} end
					$LF
					"			local ryuY      = memory.readbyte(0x8A)
					$LF
					"			local ryuX      = memory.readbyte(0x86)
					$LF
					"			local birdY     = memory.readbyte(0x480 + slot)
					$LF
					"			local birdX     = memory.readbyte(0x460 + slot)       + memory.readbyte(0x458 + slot)/256
					$LF
					"			local birdSpeed = memory.readbytesigned(0x450 + slot) + memory.readbyte(0x448 + slot)/256
					$LF
					"			local newY = 0
					$LF
					"			local newX = 0
					$LF
					"			local newSpeed = 0
					$LF
					"			while (#curves.slot <= 200) do
					$LF
					"				if (#curves.slot == 0) then
					$LF
					"					if (birdY > ryuY)
					$LF
					"					then newY = birdY - 1
					$LF
					"					else newY = birdY + 1
					$LF
					"					end
					$LF
					"					if (birdX > ryuX)
					$LF
					"					then newSpeed = birdSpeed - 16/256
					$LF
					"					else newSpeed = birdSpeed + 16/256
					$LF
					"					end
					$LF
					"					newX = birdX + newSpeed
					$LF
					"				else
					$LF
					"					local index = #curves.slot
					$LF
					"					local tempY = curves.slot[index].oldY
					$LF
					"					local tempX = curves.slot[index].oldX
					$LF
					"					local tempSpeed = curves.slot[index].oldSpeed
					$LF
					"					if (tempY > ryuY)
					$LF
					"					then newY = tempY - 1
					$LF
					"					else newY = tempY + 1
					$LF
					"					end
					$LF
					"					if (tempX > ryuX)
					$LF
					"					then newSpeed = tempSpeed - 16/256
					$LF
					"					else newSpeed = tempSpeed + 16/256
					$LF
					"					end
					$LF
					"					newX = tempX + newSpeed
					$LF
					"				end				
					$LF
					"				table.insert(curves.slot, {oldY = newY, oldX = newX, oldSpeed = newSpeed})
					$LF
					"			end
					$LF
					"			if (#curves.slot == 200) then table.remove(curves.slot, 1) end			
					$LF
					"			for index = 1, #curves.slot do
					$LF
					"				local color = nil
					$LF
					"				if (curves.slot[index].oldSpeed < 0) then color = "#008800" else color = "#0000ff" end
					$LF
					"				gui.box  (curves.slot[index].oldX - 1, curves.slot[index].oldY - 1,
					$LF
					"						  curves.slot[index].oldX + 1, curves.slot[index].oldY + 1, color)
					$LF
					"			end
					$LF
					"			for index = 1, #curves.slot do
					$LF
					"				gui.pixel(curves.slot[index].oldX, curves.slot[index].oldY, "white")
					$LF
					"			end
					$LF
					"		end
					$LF
					"	end
					$LF
					"end
					$LF
				]code
			]pre
			[pre 
				[code class=language-lua 
					"function GetCell(X,Y)
					$LF
					"	local temp = memory.readbyte(0xE7CC+SHIFT(X,4))+memory.readbyte(0x5F)
					$LF
					"	if (temp >= 0xC0) then temp = temp-0xC0 end
					$LF
					"	Y = Y-0x40
					$LF
					"	if (Y < 0) then Y = 0 end
					$LF
					"	temp = SHIFT(Y,5)+temp
					$LF
					"	return temp
					$LF
					"end
					$LF
					$LF
					"function DrawBG(arg,offset,x,y)
					$LF
					"	local color2 = "#00ff00ff"
					$LF
					"	local function box(color,text)
					$LF
					"		gui.box(x,y+offset,x+16,y+offset+16,color)
					$LF
					"		if (text == 1) then
					$LF
					"			gui.text(x+1,y+offset+1,string.format("%d",arg))
					$LF
					"		end
					$LF
					"	end
					$LF
					"	local function line(up,down,left,right)
					$LF
					"		if (up    == 1) then gui.line(x   ,y+offset   ,x+16,y+offset   ,color2) end
					$LF
					"		if (down  == 1) then gui.line(x   ,y+offset+16,x+16,y+offset   ,color2) end
					$LF
					"		if (left  == 1) then gui.line(x   ,y+offset   ,x   ,y+offset+16,color2) end
					$LF
					"		if (right == 1) then gui.line(x+16,y+offset   ,x+16,y+offset+16,color2) end
					$LF
					"	end
					$LF
					"	if (arg ~= 0) then
					$LF
					"		if     (arg == 1) then line(0,0,0,1) -- right wall
					$LF
					"		elseif (arg == 2) then line(0,0,1,0) -- left wall
					$LF
					"		elseif (arg == 3) then line(0,0,1,1) -- two-sided wall
					$LF
					"		elseif (arg == 4) then line(1,0,0,1) -- right corner
					$LF
					"		elseif (arg == 5) then line(1,0,1,0) -- left corner
					$LF
					"		elseif (arg == 6) then line(1,0,1,1) -- two-sided corner
					$LF
					"		elseif (arg == 7) then line(1,0,0,0) -- floor
					$LF
					"		elseif (arg == 8) then box("#ff000066",0) -- ejecting block
					$LF
					"		elseif (arg == 9) then box("#00ff0066",0) -- ladder
					$LF
					"		elseif (arg >= 12) and (arg <= 15)
					$LF
					"		then box("#ffffff66",0) -- exits
					$LF
					"		else box("#00ff0066",1)
					$LF
					"		end
					$LF
					"	end
					$LF
					"end
					$LF
					$LF
					"function ViewBG(style)
					$LF
					"	-- feos, 2014
					$LF
					"	-- style: 0=none, 1=new, 2=old, 3=both
					$LF
					"	local base = 0x300
					$LF
					"	local RyuX = memory.readbyte(0x86)
					$LF
					"	local RyuY = memory.readbyte(0x8A)
					$LF
					"	local RyuYspeed = memory.readbytesigned(0x89)
					$LF
					"	local RyuXspeed = memory.readbytesigned(0xAD)+memory.readbyte(0xAC)/256
					$LF
					"	if (AND(memory.readbyte(0x84),4) == 0) then RyuYspeed = 0 end
					$LF
					"	local RyuCell = GetCell(RyuX, RyuY+RyuYspeed)
					$LF
					"	local RyuRow = math.floor(RyuCell/6)
					$LF
					"	local Screen = memory.readwordsigned(0x51)
					$LF
					"	if (AND(style,1) == 1)
					$LF
					"	and (memory.readbyte(0x1FC) == 0x87)
					$LF
					"	or  (memory.readbyte(0x1F3) == 0xD8) then
					$LF
					"		for tRow = RyuRow-14, RyuRow+14 do
					$LF
					"			for tLine = 0,5 do
					$LF
					"				local address = base+((tRow*6+tLine)%0xC0)
					$LF
					"				local hi = SHIFT(memory.readbyte(address),  4)
					$LF
					"				local lo =   AND(memory.readbyte(address),0xF)
					$LF
					"				local x = (tRow-RyuRow)*16+RyuX-RyuX%0x10-Screen%0x10
					$LF
					"				local y = tLine*32+64
					$LF
					"				DrawBG(hi, 0,x,y)
					$LF
					"				DrawBG(lo,16,x,y)
					$LF
					"			end
					$LF
					"		end
					$LF
					"		gui.box(xpos-9,ypos+RyuYspeed-1,xpos+5,ypos+RyuYspeed-5,"#0000ff66")
					$LF
					"	end
					$LF
					"	if (AND(style,2) == 2) then
					$LF
					"		for cell = 0,191 do
					$LF
					"			local hi = SHIFT(memory.readbyte(base+cell),  4)
					$LF
					"			local lo =   AND(memory.readbyte(base+cell),0xF)
					$LF
					"			local bX = math.floor(cell/6)
					$LF
					"			local bY = cell%6
					$LF
					"			local rX = (RyuRow%32)*6-1
					$LF
					"			local rY = math.floor(RyuY/16)*8-32
					$LF
					"			if (hi == 0) then hi = " " else hi = string.format("%X",hi) end
					$LF
					"			if (lo == 0) then lo = " " else lo = string.format("%X",lo) end
					$LF
					"			gui.text(bX*6,bY*16+9,hi.."\n"..lo)
					$LF
					"			gui.box(rX,rY,rX+6,rY+8,"#00ff0000")
					$LF
					"		end
					$LF
					"	end
					$LF
					"end
					$LF
				]code
			]pre
			[pre 
				[code class=language-lua 
					"function Spawns()
					$LF
					"	-- feos, 2014
					$LF
					"	-- uncovers which spawns will occur per frame
					$LF
					"	local SubCur= memory.readbyte(0x50)/25.6
					$LF
					"	local PosCur= AND(memory.readbyte(0x51),0xF)
					$LF
					"	local BlCur = memory.readbyte(0x4E)
					$LF
					"	local Blptr = memory.readword(0x96)
					$LF
					"	local Yptr  = memory.readword(0x98)
					$LF
					"	local IDptr = memory.readword(0x9A)
					$LF
					"	local Count = memory.readbyte(0xB4)
					$LF
					"	local Iterator = memory.readbyte(0xB5)-8
					$LF
					"	local IteratorLast = memory.readbyte(0xB5)-1
					$LF
					"	if (Blptr == 0) then return end
					$LF
					"	while (Iterator < 0) do Iterator = Count+Iterator end
					$LF
					"	if (IteratorLast < 0) then IteratorLast = Count+IteratorLast end	
					$LF
					"	local Interrupt = AND(memory.readbyte(0x4C),0x40)
					$LF
					"	local forward = memory.readbyte(0x3D)
					$LF
					"	if (memory.readbyte(0x1FC) == 0x87)
					$LF
					"	or (memory.readbyte(0x1F3) == 0xD8) then
					$LF
					"		for i = 0,Count-1 do
					$LF
					"			local color1 = "white"
					$LF
					"			local block = memory.readbyte(Blptr+i)
					$LF
					"			local ypos  = memory.readbyte(Yptr +i)
					$LF
					"			local id    = memory.readbyte(IDptr+i)
					$LF
					"			local x = i*16%256+1
					$LF
					"			local y = 57+math.floor(i/16)*30
					$LF
					"			if (block == BlCur) then gui.box(x-1,y-1,x+12,y+23,"#00ff0088") end
					$LF
					"			if (forward == 0) then backspawn = -0xD else backspawn = 0xE end
					$LF
					"			if (block == (BlCur+backspawn)) then gui.box(x-1,y-1,x+12,y+23,"#ff00ff88") end
					$LF
					"			if (i+1 >= Iterator) and (i+1 < Iterator+8)
					$LF
					"			or (i+1 < Iterator+8-Count) then color1 = "#ffccaaff" end
					$LF
					"			if (Interrupt > 0) then color2 = "red" else color2 = "#44ffffff" end
					$LF
					"			gui.text(x,y,string.format("%X\n%X\n%X",block,ypos,id),color1)
					$LF
					"			gui.text(108,41,string.format("Block: %X.%02d.%d\nIterator: %02d-%02d/%d",
					$LF
					"				BlCur,PosCur,SubCur,Iterator,IteratorLast,Count),color2,"#000000ff")
					$LF
					"		end
					$LF
					"	end
					$LF
					"end
					$LF
				]code
			]pre
		]div
		[div class=tab-pane fade id=tabs-26-3 
			[p 
				[tt 
					"Ninja Gaiden (U) 
					[em 
					]em
					"[!]
					[em 
					]em
					".nes.ram.nl 
				]tt
				$LF
			]p
			[pre 
				[code class=language-sh 
					"$003D#Whichwayisforward#
					$LF
					"$004C#DrawingInterrupt#
					$LF
					"$004E#CurrentSpawnBlock#
					$LF
					"$0050#temp XposSub#
					$LF
					"$0051#temp Xpos#
					$LF
					"$0052#temp XposHi#
					$LF
					"$005D#NewBlockLo#
					$LF
					"$005E#NewBlockHi#
					$LF
					"$0060#ScoreLo#
					$LF
					"$0061#ScoreHi#
					$LF
					"$0062#Timer_frames#
					$LF
					"$0063#Timer_seconds#
					$LF
					"$0064#ninpo#
					$LF
					"$0065#RyuHP#
					$LF
					"$0067#ScrollBlockSubS#
					$LF
					"$0068#ScrollBlockS#
					$LF
					"$0069#ScrollPosSub#
					$LF
					"$006A#ScrollPos#
					$LF
					"$006B#ScrollBlock#
					$LF
					"$006C#ScrollArea#
					$LF
					"$006D#Current_stage#
					$LF
					"$006E#Current_room#
					$LF
					"$0070#ProcLo#
					$LF
					"$0071#ProcHi#
					$LF
					"$0073#Busy Slots#
					$LF
					"$0074#Current Slot#
					$LF
					"$0079#temp State#
					$LF
					"$007A#temp Facing#
					$LF
					"$0084#Ryu state#
					$LF
					"$0085#Ryu XposSub#
					$LF
					"$0086#Ryu Xpos#
					$LF
					"$0087#Ryu YspeedSub#
					$LF
					"$0089#Ryu Yspeed#
					$LF
					"$008A#Ryu Ypos#
					$LF
					"$008C#Ryu BGcollision#
					$LF
					"$008E#Ryu BGcollisionX#
					$LF
					"$008F#Ryu BGcollisionY#
					$LF
					"$0095#Inv. Timer#
					$LF
					"$0098#YpointerLo#
					$LF
					"$0099#YpointerHi#
					$LF
					"$009A#IDpointerLo#
					$LF
					"$009B#IDpointerHi#
					$LF
					"$0096#BlockPtrLo#
					$LF
					"$0097#BlockPtrHi#
					$LF
					"$00A2#ScreenPosSub#
					$LF
					"$00A3#ScreenPos#
					$LF
					"$00AC#Ryu XspeedSub#
					$LF
					"$00AD#Ryu Xspeed#
					$LF
					"$00B4#SpawnCount#
					$LF
					"$00B5#SpawnIterator#
					$LF
					"$00BF#Global Timer#
					$LF
					"$0300#LevelBlocks#
					$LF
					"$0400#ID#
					$LF
					"$0408#Timeout#
					$LF
					"$0410#Action#
					$LF
					"$0438#Movement#
					$LF
					"$0440#Facing#
					$LF
					"$0448#XspeedSub#
					$LF
					"$0450#Xspeed#
					$LF
					"$0458#XposSub#
					$LF
					"$0460#Xpos#
					$LF
					"$0468#YspeedSub#
					$LF
					"$0470#Yspeed#
					$LF
					"$0478#YposSub#
					$LF
					"$0480#Ypos#
					$LF
					"$0488#BGcollision#
					$LF
					"$0490#HP#
					$LF
					"$0498#State#
					$LF
					"$0600#Sound#
					$LF
					$LF
				]code
			]pre
			[p 
				[tt 
					"Ninja Gaiden (U) 
					[em 
					]em
					"[!]
					[em 
					]em
					".nes.7.nl  
				]tt
				$LF
			]p
			[pre 
				[code class=language-sh 
					"$DD4D#Slot: BusyCheck#
					$LF
					"$DD57#Object: Next#
					$LF
					"$DD5A#Slot: ScanLoop#
					$LF
					"$DD63#Slot: First#
					$LF
					"$DD6C#Object: Handle#
					$LF
					"$E024#Object: Positioning#
					$LF
					"$E243#Object: Common#
					$LF
					"$E2E5#Object: Init#
					$LF
					"$E66F#Slot: BusyMask#
					$LF
					"$F1AC#Object: HandleTemp#
					$LF
					"$E677#Collisions: DoAll#
					$LF
					"$E67E#Collisions: LowEnough#
					$LF
					"$E691#Collisions: UpperRight#
					$LF
					"$E6B0#Collisions: LowerRight#
					$LF
					"$E6C3#Collisions: UpperLeft#
					$LF
					"$E6DD#Collisions: LowerLeft#
					$LF
					"$E782#Collisions: Flags#
					$LF
					"$E792#Collisions: FindBlockType#
					$LF
					"$E7BA#Collisions: CheckBlockHalf#
					$LF
					"$E7C0#Collisions: ReadHighNibble#
					$LF
					"$E7C7#Collisions: ReadLowNibble#
					$LF
					"$EB81#InAir#
					$LF
					"$F603#Load New Block#
					$LF
					"$F5FB#Six Blocks#
					$LF
					"$C195#ProcsLo#
					$LF
					"$C196#ProcsHi#
					$LF
					"$C21D#Object: Tyson#
					$LF
					"$C75D#Object: Bird#
					$LF
					"$DFBD#IsRyuAround?#
					$LF
					"$C227#Walk (sleep)#
					$LF
					"$C29D#Attack!!!#
					$LF
					"$C253#Jump (seek)#
					$LF
					"$C232#Midair#
					$LF
					"$C234#OnGround#
					$LF
					"$C264#Aim#
					$LF
					"$C276#GetReady#
					$LF
					"$DFAB#CheckDistance#
					$LF
					"$C259#RyuIsHere!#
					$LF
					"$C22D#Act#
					$LF
					"$E5D3#ReadPos#
					$LF
					"$E5D5#Spawns: GetX#
					$LF
					"$E5D9#Spawns: GetSide#
					$LF
					"$E5E7#Spawns: GetY#
					$LF
					"$E5EE#Spawns: GetID#
					$LF
					"$E595#Spawns: CheckNewSpawn#
					$LF
					"$E5A6#Spawns: NextUnit#
					$LF
					"$E5A7#Spawns: CapTheIterator#
					$LF
					"$E144#DmgCollisions#
					$LF
					"$E122#CollisionMasks#
					$LF
					"$E578#BackSpawn: LeftScroller#
					$LF
					"$E581#BackSpawn: RightScroller#
					$LF
					"$DDEB#slashing?#
					$LF
					"$DDEF#or duckslashing?#
					$LF
					"$DECF#SlashCollision#
					$LF
					"$DF1F#Damage enemy#
					$LF
					"$DF3A#Enemy dead#
					$LF
					"$DF3D#Branch if not a boss#
					$LF
					$LF
				]code
			]pre
			[p 
				[tt 
					"Ninja Gaiden (U) 
					[em 
					]em
					"[!]
					[em 
					]em
					".nes.0.nl  
				]tt
				$LF
			]p
			[pre 
				[code class=language-sh 
					"$B300#Xhitboxes#
					$LF
					"$B400#Yhitboxes#
					$LF
					"$B500#Points table#
					$LF
					"$B530#HP table#
					$LF
					"$B560#Damage table#
					$LF
					$LF
				]code
			]pre
		]div
	]div
]div
[h2 id=Movement
 
	" Movement
	$LF
]h2
[h3 id=HorizontalMovement
 
	" Horizontal Movement
	$LF
]h3
[p 
	"Ryu has only three possible horizontal speeds: 1.5, 1, and 0.5 pixels per frame.
	$LF
]p
[ul 
	[li 
		" 1.5 p/f: when running either direction or pressing forward while airborne.
		$LF
	]li
	[li 
		" 0.5 p/f: when pressing back while airborne.
		$LF
	]li
	[li 
		" 1 p/f: when bouncing after taking damage from an enemy, until contact with a wall or platform. (the player has no control over Ryu's movement during this)
		$LF
	]li
]ul
[h4 id=Preservingspeed
 
	" Preserving speed
	$LF
]h4
[p 
	"Use of ↔, ← + ↕ or ← or → + B or A (←/→ + B/A only applicable when airborne, and if used for more than one from B and A must alternate every frame)
	$LF
	"serves to prevent a new speed value from being written, thereby preserving speed when transitioning from one type of movement to another. This is primarily useful for full-speed backwards air movement, but can alsobe used for more precise adjustments to Ryu's position.
	$LF
]p
[p 
	"Example: ↔ on the frame control is regained after 
	$LF
	"taking damage, then releasing ← and continuing on holding → puts Ryu a half-pixel behind where he'd be if only → had been held, which can actually be favorable in some instances. Care must also be taken to avoid this happening where it would be undesirable, such as pressing ← for one frame mid-jump to trigger an enemy spawn, then pressing →+B on the following frame. This would leave Ryu one pixel behind where he would have been if the attack had come one frame later, after resuming normal forward movement.
	$LF
]p
[h4 id=StickyFloors
 
	" Sticky Floors
	$LF
]h4
[p 
	"Landing on certain tiles (mostly found at platform edges, but not always or exclusively) will stop Ryu's forward movement for one frame. Usually this is
	$LF
	"avoidable, but in cases where it is not, and it is possible to jump on the following frame, it provides an opportunity to execute a special attack without losing time.
	$LF
]p
[h3 id=VerticalMovement
 
	" Vertical Movement
	$LF
]h3
[p 
	"Ryu move upwards in four ways: jumping from a floor or platform, jumping from a wall, being hit by an enemy, or climbing ladders.
	$LF
	"Each of these has its own rules, detailed below.
	$LF
]p
[ul 
	[li 
		" standing jump: rises 48 pixels, peaks 19-24 frames after jumping.
		$LF
	]li
]ul
[pre 
	"pattern: -4,-4,-4,-4,-4,-3,-3,-3,-3,-3,-2,-2,-2,-2,-1,-1,-1,-1,0,0,0,0,0,0,1...
	$LF
]pre
[ul 
	[li 
		" wall jump: rises 15 pixels, peaks 10-14 frames after jumping.
		$LF
	]li
]ul
[pre 
	"pattern: -2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1...
	$LF
]pre
[ul 
	[li 
		" damage boost: rises 29 pixels, peaks 14-19 frames after hit.
		$LF
	]li
]ul
[pre 
	"pattern: -3,-3,-3,-3,-3,-2,-2,-2,-2,-2,-1,-1,-1,-1,0,0,0,0,0,0,1...
	$LF
]pre
[ul 
	[li 
		" climbing a ladder moves Ryu 1 pixel per frame.
		$LF
	]li
]ul
[h4 id=RecoveryWalljump
 
	" Recovery Walljump
	$LF
]h4
[p 
	"When you hit by an enemy, you have no control until Ryu contact with a wall. So the fastest way to reduce 1.0px/f speed and "uncontrollness" length, is jumping into an enemy next to a wall while staying "between" the wall's climbable part and the enemy.
	$LF
	"This obviously requires enemy position manipulation and Ryu's X and Y positioning.
	$LF
]p
[p 
	"A perfect Recovery Walljump is possible to carry out with only 1 frame of negative direction (for example a wall-Ryu-enemy situation in 3 frames: →, being hit (-0.5px ~ -1.5px), → + A)
	$LF
]p
[h4 id=Wall-Climbing
 
	" Wall-Climbing
	$LF
]h4
[p 
	[b 
		"TODO:
	]b
	" what do we need to document about this?
	$LF
]p
[h2 id=Attacking
 
	" Attacking
	$LF
]h2
[p 
	"If you want to know the first frame a given enemy can be hit with the sword from a given jump without many tedious re-records, toggling a cheat that sets $82=2 will keep the sword in the attack state for the rest of a jump after B is pressed. Additionally you can poke some greater value to the enemy's HP to see a range of frames Ryu can attack it. Adjust by one frame for down+B if necessary.
	$LF
]p
[h2 id=Randomnessandmanipulation
 
	" Randomness and manipulation
	$LF
]h2
[h3 id=Knifetossers
 
	" Knife tossers
	$LF
]h3
[p 
	"From power on, $BF (Global Timer) increments once every frame, from 0 to 255. It is used to determine the delay (in frames) between tosses and the speed of the tossed objects for the four different object-tossing enemies (actually all the same enemy, just with variant sprites). A logical shift right is performed on the value of $BF for the toss-delay (so, 128 possible values). $BF is directly copied to the X and Y sub-pixel speeds and an AND #$01 sets the x speed. The Y speed is simply set to -3.
	$LF
]p
[p 
	"$BF is also used similarly for the final boss and the 'shrimp' it spews, but with two shift-rights for the spew-timer and a few more steps for the X speed to get possible values between -3 and 3.
	$LF
]p
[h3 id=Tysons
 
	" Tysons
	$LF
]h3
[p 
	"Tysons constantly do 10-frame jumps, checking if Ryu is around each time they touch the ground. When Ryu is within 32 pixels, they change their action ($410) to "ready" as they land, after the next jump they go "steady", the next jump they attack. It sounds consistent, but in fact it has a lot of randomness.
	$LF
]p
[ul 
	[li 
		" Inherited Y sub-pixels (see below) make them land sooner or later by 1 frame
		$LF
	]li
	[li 
		" Graphical interrupts (occuring every 10 frames as you run) freeze them for 1 frame.
		$LF
	]li
	[li 
		" If those interrupts occur right when Tyson is on the ground and is about to change his action, he will fail to do it this time, which means his attack may be delayed by ~10 frames, allowing you to pass.
		$LF
	]li
]ul
[h3 id=Birds
 
	" Birds
	$LF
]h3
[p 
	"Birds look so smart only because their AI is so simple. Each frame they are below Ryu, their Y pos increments, otherwise it decrements. Each frame they are to the right from Ryu, their X speed fractions decrease, otherwise they increase. Use the trajectory script to predict them.
	$LF
]p
[h3 id=Bats
 
	" Bats
	$LF
]h3
[p 
	"They spawn at certain Y position which is read from configs, but then gets overwritten. BatSpawnYpos = RyuYpos - 0x10. You would want to manipulate their height if you are going to damage boost from them and land as soon as possible.
	$LF
]p
[h3 id=Cheetahs
 
	" Cheetahs
	$LF
]h3
[p 
	"They use to run in one direction all the time, but sometimes they turn around. It happens when they touch the ground and hit the red (sticky) block, first half, that thing that freezes Ryu too if he does it.
	$LF
]p
[h3 id=InheritedSub-Pixels(andmanipulation)
 
	" Inherited Sub-Pixels (and manipulation)
	$LF
]h3
[p 
	"New enemy sub-pixel position gets added to the subpixel of the previous enemy in this slot that he had while disappearing. If the previous enemy disappeared at 0x07.00, the new one will have position 0xEF.80 (previous 0x08.80 => new 0xF0.00).
	$LF
]p
[p 
	"There's also a 1 frame window to manipulate this: 1 frame before they would spawn, you remove the direction frame. Obviously this only saves time, if you already need to sacrifice 1.5px.
	$LF
]p
[h3 id=Spawns,theirdelaysandcancellations
 
	" Spawns, their delays and cancellations
	$LF
]h3
[p 
	"The game divides levels into blocks of ~16 pixels. For each block, level configs are read on which object must spawn. The object limit per room is stored in $B4. $B5 iterates through all possible spawns for a given room, and picks up those whose block matches the current level block. It iterates by 8 units per frame, and the game can spawn up to 30 units per room. The game can't read through all units every frame, if there are more of them than 8, so some spawns get delayed, if the block already requires the spawn, but the iterator isn't at that unit yet.
	$LF
]p
[p 
	"Objects configs consist of 4 things: target level block, X position, Y position, and ID. X position can only be either 0x10, or 0xF0, putting it on one of the two screen sides. This way, by delaying the spawn of the object relatively to your own progression, you can affect their positions in the level. Screen-wise, it will spawn at the same place, but in the level it will be different. Just track which bunch of units was iterated through this frame, and delay the moment when it matches the current block. Use the Spawns lua function for that.
	$LF
]p
[p 
	"Another trick is delaying and even cancelling spawns by moving backwards for 1 frame when the iterator runs through the particular spawn unit. If there are many enemies to spawn in the room, it will read that unit only once per 3-4 frames. So during a jump, you can press the opposite direction during these few frames, moving back only by half a pixel, and then again moving forward by 1.5 pixel per frame. But the fewer enemies the room has, the more frames you need to press backward, because iterator would hit the unit in question more often. Sometimes it doesn't even work because of that.
	$LF
]p
[h3 id=Interrupts
 
	" Interrupts
	$LF
]h3
[p 
	"Every ~16 pixels (10-11 frames as you run) occurs and interrupt that loads the new graphics block into video memory. It takes s much time that the frame it occurs most calculations except for Ryu positioning are omitted. If you catch that frame and twitch left-right at 1.5 speed (or just a half pixel, depending on your position), the enemies will freeze. Interrupt is detected by looking at address $4C, which is 0xC1 or 0x80 during those frames.
	$LF
]p
[h3 id=LevelTimer
 
	" Level Timer
	$LF
]h3
[p 
	"Every second remaining on the level timer will take three frames to be converted to points and added to the score after a boss is killed—a fact that would seem to be at odds with doing things as fast as possible. But since the timer fractions, the "subtimer", carry over between stage transitions, there will be an optimal range of initial values for the subtimer to have when entering the boss stage so that a second that would otherwise remain on the clock will tick off during the boss fight. A way to find the maximum (the minimum is 0) desired subtimer value for a given, otherwise optimized, boss fight is to compare the 61 frames it takes the subtimer to tick a second off with (F) how many frames it will decrement during the fight (starting at either the first frame of input or the frame after and ending on the frame the boss dies or the frame after). F modulo 61 = max desired subtimer value. With that it can then be determined if the existing subtimer value is optimal or if it will be feasible to manipulate a value within that range.
	$LF
]p
[h2 id=Glitcheswithnoknownapplication
 
	" Glitches with no known application
	$LF
]h2
[h3 id=Takingdamageatthesametimeabossiskilled
 
	" Taking damage at the same time a boss is killed
	$LF
]h3
[p 
	[b 
		"TODO: haha, 3-3 actually does this
	]b
	$LF
]p
[h3 id=Verticalscreen-wrapping
 
	" Vertical screen-wrapping
	$LF
]h3
[p 
	"That happens when taking a hit from a vertical position of 4, 5, 14, 15, 16, 25, 26, 35, 36, 45, 46, 55, 56, 65, 66, 75, 84, 93, 102, or 111 or jumping from a wall with a vertical position of 73, 82, or 91, because there is no cap on falling speed and because the game only checks if Ryu is in the eight pixel death zone at the bottom of the screen, but doesn't care if he passes it, so falling from the right position will just make him wrap around to the top of the screen.
	$LF
]p
[h3 id=MakingEnemiesFallfromPlatforms
 
	" Making Enemies Fall from Platforms
	$LF
]h3
[p 
	[b 
		"TODO:
	]b
	" Spawn position dependent. Anything need to say?
	$LF
]p
[h3 id=Thatonethingwhereyoupassthroughanenemyorgrabapower-upandgraphicsglitchoutforaframe
 
	" that one thing where you pass through an enemy or grab a power-up and graphics glitch out for a frame
	$LF
]h3
[p 
	"That's a lag frame. The only place where it's not a lag frame is the end of 4-1.
	$LF
]p
[p 
	[b 
		"TODO:
	]b
	" The block config iterator is not a constant number. 8 for 1-1, 1 for 1-2, 3 for 2-1 etc. It's probably $C1-10 (18 == 8, 13 == 3, 1 == 1 <-- yeah... probably)
	[br 
	]br
	$LF
	[b 
		"TODO:
	]b
	" reword prespawn manipulation
	[br 
	]br
	$LF
	[b 
		"TODO:
	]b
	" write down enemy slot system ("It's the highest spare slot. Which means if you make it busy yourself, the object will just spawn in the next "highest spare slot".)
	[br 
	]br
	$LF
	[b 
		"TODO:
	]b
	" solve the "how to monitor birdy" problem, I think using the speed as a counter MIGHT be enough
	[br 
	]br
	$LF
	[b 
		"TODO:
	]b
	" fill in all the gaps
	$LF
]p
