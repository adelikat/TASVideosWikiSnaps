26
[div class=p 
	"This is improvement of 1121 frames over the 
	(__wikiLink|displaytext=Acmlm's currently published run|href=/1596M)
	" of which 596 frames were saved during level 18 and also 525 frames were saved after level 19 speed transition.
	$LF
]div
[div class=card mb-2 
	[div class=card-header 
		[strong 
			"Table of contents
		]strong
	]div
	[div class=card-body 
		[ul 
			[li 
				[ul 
					[li 
						[a href=#GameObjectives 
							" Game objectives
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Improvements 
					"Improvements
					$LF
				]a
				[ul 
					[li 
						[a href=#AlternativeStartingPoint 
							"Alternative starting point
							$LF
						]a
					]li
					[li 
						[a href=#ChessboardBuild 
							"Chessboard build
							$LF
						]a
					]li
					[li 
						[a href=#TetrominoCountControl 
							"Tetromino count control
							$LF
						]a
					]li
					[li 
						[a href=#PlansWithinPlansWithinPlans 
							"Plans within Plans within Plans
							$LF
						]a
						[ul 
							[li 
								[a href=#PrimaryOptimization 
									"Primary optimization
									$LF
								]a
							]li
							[li 
								[a href=#SecondaryOptimization 
									"Secondary optimization
									$LF
								]a
							]li
							[li 
								[a href=#TertiaryOptimization 
									"Tertiary optimization
									$LF
								]a
							]li
							[li 
								[a href=#QuaternaryOptimization 
									"Quaternary optimization
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#BrokenKnee 
							"Broken knee 
							$LF
						]a
					]li
					[li 
						[a href=#Tree3Skip 
							"Tree#3 skip
							$LF
						]a
					]li
					[li 
						[a href=#PostTransitionPlay 
							"Post-transition play 
							$LF
						]a
					]li
					[li 
						[a href=#Endgame 
							"Endgame
							$LF
						]a
						[ul 
							[li 
								[a href=#EndInputEarlier 
									"End input earlier 
									$LF
								]a
							]li
						]ul
					]li
				]ul
			]li
			[li 
				[a href=#TechnicalPart 
					"Technical part
					$LF
				]a
				[ul 
					[li 
						[a href=#LocalTerms 
							"Local terms
							$LF
						]a
					]li
					[li 
						[a href=#Tricks 
							"Tricks
							$LF
						]a
						[ul 
							[li 
								[a href=#3LineTetris 
									"3-line tetris
									$LF
								]a
							]li
							[li 
								[a href=#DlrTrick 
									"DLR trick
									$LF
								]a
							]li
							[li 
								[a href=#PauseTrick 
									"Pause trick
									$LF
								]a
							]li
							[li 
								[a href=#LrTrick 
									"LR trick
									$LF
								]a
							]li
							[li 
								[a href=#FastDrop 
									"Fast drop
									$LF
								]a
							]li
							[li 
								[a href=#TricksSummary 
									"Tricks summary
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#InvisibleBlocks 
							"Invisible blocks
							$LF
						]a
					]li
					[li 
						[a href=#PackingsGeneratorC 
							"Packings generator (C++)
							$LF
						]a
						[ul 
							[li 
								[a href=#Optimizations 
									"Optimizations
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#StandAloneBruteForceProgramC 
							"Stand-alone brute force program (C++)
							$LF
						]a
					]li
					[li 
						[a href=#PlacementDatabaseGeneratorC 
							"Placement database generator (C++)
							$LF
						]a
					]li
					[li 
						[a href=#ImplementationOfNesTetrisGameLogicC 
							"Implementation of NES Tetris game logic (C++)
							$LF
						]a
						[ul 
							[li 
								[a href=#TetrominoVerticalPosition 
									"Tetromino vertical position
									$LF
								]a
							]li
							[li 
								[a href=#Vramrow 
									"vramRow
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#TetrisListsPython 
							"Tetris lists (Python)
							$LF
						]a
					]li
					[li 
						[a href=#TetrisGraphPython 
							"Tetris graph (Python)
							$LF
						]a
						[ul 
							[li 
								[a href=#ListIntoGraphPython 
									"list into graph (Python)
									$LF
								]a
							]li
							[li 
								[a href=#GraphToListPython 
									"graph to list (Python)
									$LF
								]a
							]li
							[li 
								[a href=#TetrisDebugLua 
									"tetris debug (Lua)
									$LF
								]a
							]li
							[li 
								[a href=#TetrisCheckResultsLua 
									"tetris check results (Lua)
									$LF
								]a
							]li
						]ul
					]li
					[li 
						[a href=#AdditionalNotes 
							"Additional notes
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#SpecialThanksToAlexeyLeonidovichPajitnov 
					"Special thanks to Alexey Leonidovich Pajitnov
					$LF
				]a
			]li
		]ul
	]div
]div
[h3 id=GameObjectives 
	" Game objectives
	$LF
]h3
[ul 
	[li 
		" Emulator used: FCEUX-2.2.3
		$LF
	]li
	[li 
		" Fastest 999999 score
		$LF
	]li
	[li 
		" Completes the game without any blocks left
		$LF
	]li
	[li 
		" Aims for shortest input time
		$LF
	]li
	[li 
		" Heavy luck manipulation
		$LF
	]li
	[li 
		" Genre: Puzzle 
		$LF
	]li
]ul
[h2 id=Improvements 
	"Improvements
	$LF
]h2
[h3 id=AlternativeStartingPoint 
	"Alternative starting point
	$LF
]h3
[div class=p 
	"It is possible to take tiny advantage of using different starting points by waiting a few frames in menu. Including I-teromino gives starting height of 7 blocks while two normal terominoes gives only height of 6 blocks. This one additional block of height advantage extends the packing possibilities for Tree#1.
	$LF
]div
[h3 id=ChessboardBuild 
	"Chessboard build
	$LF
]h3
[div class=p 
	"Instead of making one long well at the central hole we divided it into four small knees. It enormously extends packing variability for level 18. Besides during Tree#2 building and also in the very end of the game it allows to burn faster because I-tetrominoes have to travel shorter distance to the ground.
	$LF
]div
[h3 id=TetrominoCountControl 
	"Tetromino count control
	$LF
]h3
[div class=p 
	"During packing it is possible to place some blocks above the screen where they will be destroyed.  So there is a degree of freedom in the number of tetrominoes is used.
	[br 
	]br
	$LF
	"X-mode - Extreme packing. Economical utilization of tetrominoes to reach the densest packaging ever possible. 
	$LF
	"N-Mode - Normal packing. Utilization of tetrominoes is not so strict. In this mode 4 blocks can be destroyed above the screen. Four destroyed blocks is equivalent to a whole tetromino.
	$LF
	"For example one knee in N-Mode require 40 tetrominoes to build while X-Mode require only 39 of them. Also it is possible to build a tree with different amount of tetrominoes as well.
	$LF
]div
[h3 id=PlansWithinPlansWithinPlans 
	"Plans within Plans within Plans
	$LF
]h3
[h4 id=PrimaryOptimization 
	"Primary optimization
	$LF
]h4
[div class=p 
	"At first we generated packs of solutions that allow to build glitched Tetris with triples at the top.
	$LF
]div
[h4 id=SecondaryOptimization 
	"Secondary optimization
	$LF
]h4
[div class=p 
	"Then we organized these packs in groups that allow to form one whole knee. 
	$LF
]div
[h4 id=TertiaryOptimization 
	"Tertiary optimization
	$LF
]h4
[div class=p 
	"Then checked all sequences for building four knees in a row.
	$LF
]div
[h4 id=QuaternaryOptimization 
	"Quaternary optimization
	$LF
]h4
[div class=p 
	"And finally solving whole level 18 with different number of tetraminoes in the first and in the second parts. 
	$LF
]div
[div class=p 
	"Path for solving level 18 in this TAS looks like this:
	[br 
	]br
	$LF
	"XXNN
	[br 
	]br
	$LF
	"NNNX
	$LF
]div
[div class=p 
	"Or slightly more exact:
	[br 
	]br
	$LF
	"10X-06X-10N-04N
	[br 
	]br
	$LF
	"10N-02N-10N-08/06X
	$LF
]div
[div class=p 
	"Or even more exact:
	[br 
	]br
	$LF
	"H07_101	TREE_1_Y_ShiftM_102A	102Y_07A	07_10B	T06_N	T06_N	T06_3X2	08_06B	10_10C	08_10A	08_10B	02_10A	02_04AA	07_04A	07_04B	04_04C
	[br 
	]br
	$LF
	"ERZ1_04T	ERZ2_10Z	ERZ3_06S	ERZ4_10I-ZN	TREE_2_TRUE_ZN_05_10A	05_04F10	04_02AA	02_02C	02_02C	02_02C	10_10C	10_10C	10_10C	10_10C	6780X	6780Q-80	10_06E08	08_06B
	$LF
]div
[h3 id=BrokenKnee 
	"Broken knee 
	$LF
]h3
[div class=p 
	"Last knee before Level 19 transition is divided in two parts. This trick is done to take two extra block of height advantage so during solving each tetris after transition, since it has two blocks shorter fall distance.
	$LF
]div
[h3 id=Tree3Skip 
	"Tree#3 skip
	$LF
]h3
[div class=p 
	"Tree#3 is skipped completely. Instead we delay burning of four remaining Tetris until very end of the game. Additional benefit of skipping Tree #3 is the possibility to continue building immediately after transition to Level 19. 
	$LF
]div
[h3 id=PostTransitionPlay 
	"Post-transition play 
	$LF
]h3
[div class=p 
	"At high speed upper left corner is no longer reachable. So we need to play honestly. It is a lot easier. With a little help of combinatorics and graph theory we were able to bruteforce through all possible intermediate incomplete states between tetrises and solve post-transition gameplay as a whole.
	$LF
]div
[div class=p 
	"Path for solving level 19 in this TAS looks like this:
	[br 
	]br
	$LF
	"SHAPE_000_102	SHAPE_102_101	SHAPE_101_251	SHAPE_251_213	SHAPE_213_104	SHAPE_104_239	SHAPE_239_END1_08	END2_10	END3_02	END4_10
	$LF
]div
[h3 id=Endgame 
	"Endgame
	$LF
]h3
[div class=p 
	"For the perfect end we need to get four I-tetromino pieces in a row.  It is possible only under special conditions. Spawn counter, value of RAM address 0x1A must be divisible by 8 without a remainder. For our case it is 112/8=14. That's why during solving level 18 it was absolutely necessary to use tetromino count control.
	$LF
]div
[h4 id=EndInputEarlier 
	"End input earlier 
	$LF
]h4
[div class=p 
	"Shortest input time is the most logical universal goal for all TAS. Tetris should not be an exception of this rule. In our movie end of input is done as soon as last I-tetromino rotated and prepared for free fall in desired place. Last tetris and reaching final maxed out 999999 score is done without any additional input.
	$LF
]div
[h2 id=TechnicalPart 
	"Technical part
	$LF
]h2
[h3 id=LocalTerms 
	"Local terms
	$LF
]h3
[dl 
	[dt 
		"Tetromino
	]dt
	[dd 
		" a piece in the game Tetris consisting of four cells.
		$LF
		[dt 
			"Tetris
		]dt
		[dd 
			" clearing 4 lines at once.
			$LF
			[dt 
				"Occupied cell
			]dt
			[dd 
				" cell which is not empty because it was occupied previously.
				$LF
				[dt 
					"To lock tetromino
				]dt
				[dd 
					" to make tetromino locked.
					$LF
					[dt 
						"Locked tetromino
					]dt
					[dd 
						" tetromino which is no longer movable by player.
						$LF
						[dt 
							"Placing (placement)
						]dt
						[dd 
							" a process or a sequence of key presses to lock tetromino in desired place.
							$LF
						]dd
					]dd
				]dd
			]dd
		]dd
	]dd
]dl
[div class=p 
	"Other local terms will be defined along the way.
	$LF
]div
[h3 id=Tricks 
	"Tricks
	$LF
]h3
[h4 id=3LineTetris 
	"3-line tetris
	$LF
]h4
[div class=p 
	"When three top lines of screen is cleared, due to an error within the code the game perceives this move as clearing four lines. And gives score as if tetris was made. Therefore let's call it 3-line tetris. Also all occupied cells are moved down by one cell. Actually clearing the line is just a copy other cells with an overwrite.
	$LF
]div
[div class=p 
	"The first line is checked as cleared, then it mistakenly shifts all the cells down. Since the lines are moved instead of overwrite and since cleared lines are counted interleaving with clearing the lines, remaining moved 3 full lines are checked as cleared as well, but copy with overwrite works as intended for them so they are cleared correctly. For more info look for 
	[em 
		"invisible blocks
	]em
	" section.
	$LF
]div
[h4 id=DlrTrick 
	"DLR trick
	$LF
]h4
[div class=p 
	"Single frame of the game is separated into multiple sub-states. Pressing simultaneously keys Down+Left+Right in some cases stops the execution in the middle of whole the frame-cycle due to a bug within the game. On the next frame the process is continued from the place where it was stopped, so everything continue as intended. This allows us to intentionally insert something that looks like a lag-frame.
	$LF
]div
[h4 id=PauseTrick 
	"Pause trick
	$LF
]h4
[div class=p 
	"Pressing pause allows to release key during the pause. It require additional frames in the pause but allows to move the tetromino piece faster within the game mechanics.
	$LF
]div
[h4 id=LrTrick 
	"LR trick
	$LF
]h4
[div class=p 
	"If any of Left or Right keys is just-pressed then the game thinks you just-pressed some sideways key, but which side move is performed is determined by held keys. In case LR pressed, both keys are held, and first checked key is Right, and move to the right is performed. Therefore sequence of " ", "R", "LR" does two shifts to the right within 3 frames, while normally you would have " ", "R" with one shift within 2 frames.
	$LF
]div
[h4 id=FastDrop 
	"Fast drop
	$LF
]h4
[div class=p 
	"Two things in the game makes tetromino fall:
	$LF
]div
[ul 
	[li 
		" automatical fall according to fall speed
		$LF
	]li
	[li 
		" holding Down key
		$LF
	]li
]ul
[div class=p 
	"Only one of them may happen during a frame. Falling using Down key is ignored when automatical fall happens. Therefore making sure all falls triggered by holding down key happen between automatical fall results in fast drop.
	$LF
]div
[h4 id=TricksSummary 
	"Tricks summary
	$LF
]h4
[div class=p 
	"LR trick and Pause trick are used to move piece in places which are not reachable without those tricks. DLR trick is used to reduce time in pause while awaiting new tetromino pieces. Those waits required for manipulation of getting desired next tetromino pieces. Fast drop just faster. 3-line tetris trick is used for achieving maximum score faster. Remaining 4-th line should not be considered as a copy, because it was actually filled by pieces. So, the only bonus we get from 3-line tetris is additional score for cells we haven't filled.
	$LF
]div
[h3 id=InvisibleBlocks 
	"Invisible blocks
	$LF
]h3
[dl 
	[dt 
		"Invisible block
	]dt
	[dd 
		" an occupied cell above the screen, so naturally it's invisible.
		$LF
	]dd
]dl
[div class=p 
	"How is it possible? Well, the game field naturally have 20 * 10 = 200 cells. But it is stored in free 256 bytes. Each cell corresponds to a single byte. In normal circumstances of gameplay only first 200 cells are used. But 3-line tetris trick changes everything. This bug happens because for each filled line game moves everything before it one line down. And for the first line from the top its first cell index is zero. So the first moved cell index should be -10, but the number is stored in a single byte as an unsigned number, so its value wraps around into value 246. So -10 is 246. And it eventually moves all bytes within range [0, 246] to [10, 256]. After several times, bottom occupied cells reach bytes [246-255] and during movement of current piece and during checks of cells above the screen, indices of cells also using unsigned numbers and cells above the screen are negative, so corresponding indices within range [246-255] are checked, if those are occupied, it results into phenomenon called 
	[em 
		"invisible blocks
	]em
	".
	$LF
]div
[h3 id=PackingsGeneratorC 
	"Packings generator (C++)
	$LF
]h3
[dl 
	[dt 
		"Packing
	]dt
	[dd 
		" a scheme of cutting of some part of the game field into pieces (tetrominos). Packing consists of borders between two different pieces (tetrominos), or cells already occupied.
		$LF
	]dd
]dl
[div class=p 
	[em 
		"Packing
	]em
	" may have different representations. Here is an example of a 
	[em 
		"packing
	]em
	" as a picture:
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/Dxk5HMv.png 
	]img
	$LF
]div
[div class=p 
	"Here is a text representation of the same 
	[em 
		"packing
	]em
	":
	$LF
]div
[pre 
	"..........
	$LF
	"....A.....
	$LF
	"BBBBACCCDD
	$LF
	"EEEEACFFDD
	$LF
	"GGGHAFFIII
	$LF
	".GHHHJJJJI
	$LF
]pre
[div class=p 
	"In text representation different letters corresponds to different tetrominos, and dots represent empty cells. In other words, text is enough to represent a 
	[em 
		"packing
	]em
	", no picture is required.
	$LF
]div
[div class=p 
	"As an input for packing generator it receive the state of the field in text form, and ending state of the field in text form. Then it enumerates all possible 
	[em 
		"packings
	]em
	". Among possible 
	[em 
		"packings
	]em
	" it also filters out impossible.
	$LF
]div
[dl 
	[dt 
		"Impossible packing
	]dt
	[dd 
		" a 
		[em 
			"packing
		]em
		" without 
		[em 
			"solutions
		]em
		$LF
		[dt 
			"Solution
		]dt
		[dd 
			" a sequence of 
			[em 
				"placements
			]em
			" leading to desired 
			[em 
				"packing
			]em
			$LF
		]dd
	]dd
]dl
[div class=p 
	"Also, for each possible solution of single packing it makes a 
	[em 
		"solver
	]em
	".
	$LF
]div
[dl 
	[dt 
		"Solver
	]dt
	[dd 
		" a representation of all possible 
		[em 
			"solutions
		]em
		" for desired 
		[em 
			"packing
		]em
		" in convenient format.
		$LF
	]dd
]dl
[div class=p 
	"Format which was chosen is a graph (more technically speaking: an automaton). Vertices of automaton are states of part of the game field, and edges are 
	[em 
		"placements
	]em
	" with required piece and key presses (
	[em 
		"placement
	]em
	" of the piece).
	$LF
]div
[div class=p 
	"After all 
	[em 
		"solvers
	]em
	" for each 
	[em 
		"packing
	]em
	" is made, packing generator then unifies them to make 
	[em 
		"unified solver
	]em
	".
	$LF
]div
[dl 
	[dt 
		"Unified solver
	]dt
	[dd 
		" a 
		[em 
			"solver
		]em
		" which represent all possible solutions for some set of 
		[em 
			"packings
		]em
		" as a single 
		[em 
			"solver
		]em
		$LF
	]dd
]dl
[div class=p 
	"Those 
	[em 
		"solvers
	]em
	" were saved in human readable text format, friendly to load from Lua scripts. Main benefit was: easier to debug when you can read or edit 
	[em 
		"solver
	]em
	" from simplest tool: any text editor.
	$LF
]div
[div class=p 
	"Same tool is able to perform next step: 
	[em 
		"solver
	]em
	" optimization. Why is it required? Well, many 
	[em 
		"placements
	]em
	" are suitable to find out all possible 
	[em 
		"packings
	]em
	". But we want fastest speed, so we need to find 
	[em 
		"placements
	]em
	" with shortest input. And those require to use Down presses, which increase work load on the generator. Thus, during stages of finding all 
	[em 
		"packings
	]em
	" and making 
	[em 
		"solvers
	]em
	" and unification Down presses wasn't taken into account to reduce the load. And because of this, optimization was required as an additional step.
	$LF
]div
[h4 id=Optimizations 
	"Optimizations
	$LF
]h4
[div class=p 
	"First implementation was making all possible Left parts and all possible Right parts then during iteration over all Right parts it was making complementary Left part pattern and looking for all Left parts with the same pattern among generated Left parts. This approach is called 
	[a href=https://www.geeksforgeeks.org/meet-in-the-middle/ rel=noopener external nofollow 
		"meet-in-the-middle
	]a
	". Later on, technique from dynamic-programming was used to enumerate all possible 
	[em 
		"packings
	]em
	" without repetitions in very efficient manner. Because it is guaranteed no duplicates it didn't require storage of unique packings found so far, so it required much less memory and checks for duplicates wasn't required anymore.
	$LF
]div
[ul 
	[li 
		" Cache all results for queries about 
		[em 
			"placements
		]em
		". It speed up the process drastically because same queries about possible 
		[em 
			"placements
		]em
		" happens a lot because different 
		[em 
			"packings
		]em
		" have a lot in common. Also, finding 
		[em 
			"solutions
		]em
		" is most expensive step in the process.
		$LF
	]li
	[li 
		" When finding possible solutions for fixed packing do the following. For each pair of tetromino pieces answer on question: is it possible to place first tetromino after second? If the second is not possible to place after the first, then the first should be placed before the second. Use this information to skip futile ways to solve.
		$LF
	]li
	[li 
		" It was shown that the only pieces possible to finish 3-line tetris is L, J, I in four possible positions in total. Thus, one tetromino in one of those four configurations 
		[b 
			"must
		]b
		" be present in the 
		[em 
			"packing
		]em
		".
		$LF
	]li
]ul
[h3 id=StandAloneBruteForceProgramC 
	"Stand-alone brute force program (C++)
	$LF
]h3
[div class=p 
	"This tool as an input receive:
	$LF
]div
[ul 
	[li 
		" the current state of a part of the game field
		$LF
	]li
	[li 
		" current state of invisible blocks
		$LF
	]li
	[li 
		" sequence of 
		[em 
			"solvers
		]em
		" to perform (apply one on top of other)
		$LF
	]li
	[li 
		" max number of frames to wait (while manipulating new next tetromino)
		$LF
	]li
	[li 
		" the number of best candidates to keep
		$LF
	]li
	[li 
		" the number of candidates to try from the given input. this is setting for ability to feed more inputs than will be considered.
		$LF
	]li
	[li 
		" multiple inputs, each of them consisting of:
		$LF
		[ul 
			[li 
				" current state of important RAM variables: RNG, frame counter, spawn counter, previous piece...
				$LF
			]li
			[li 
				" previous keys up to state which is defined
				$LF
			]li
			[li 
				" 
				[em 
					"placement
				]em
				" for next tetromino (because we manipulate new next)
				$LF
			]li
			[li 
				" meta - any additional text which the user want to carry along with the candidate. In the end we stored here sequence of 
				[em 
					"solvers
				]em
				" and current state of the field.
				$LF
			]li
		]ul
	]li
]ul
[div class=p 
	"Initial version was performing only single 
	[em 
		"solver
	]em
	", and just keeping number of best candidates. Later on, sequence of 
	[em 
		"solvers
	]em
	" was implemented. For single 
	[em 
		"solver
	]em
	" all possible ways were enumerated. Common number of 
	[em 
		"solutions
	]em
	" within single 
	[em 
		"solver
	]em
	" is several millions, but some of 
	[em 
		"solvers
	]em
	" had hundreds of millions. Among all results only few best candidates were selected and considered as inputs for the next solver. The number of candidates to keep is configured by user.
	$LF
]div
[div class=p 
	"There are many possible ways to get shortest input, they are easy overflowing any reasonable number of candidates to keep. So, if you set to keep 100 best candidates, it is fairly easy to make 100 of very similar inputs, so to find out best way after few phases it was required to set number of candidates to keep quite high. This was a problem. The solution is: we need to make code which able to detect 
	[em 
		"equivalent inputs
	]em
	".
	$LF
]div
[dl 
	[dt 
		"Equivalent inputs
	]dt
	[dd 
		$LF
	]dd
]dl
[div class=p 
	"Two inputs are equivalent if any other additional input added to both of them leads to same result. It's only applied to some fixed initial state after which those inputs are applied. If initial states are different then equivalent input is meaningless term.
	$LF
]div
[div class=p 
	"Functionality of code responsible for detection of equivalent inputs was fixed multiple times up to very recent version of stand-alone brute. In the end it was a class which would hold pool of inputs with methods to insert input, and clear pool. Insert is doing nothing if we try to insert duplicate or worse input.
	$LF
]div
[div class=p 
	"Later, main optimization was to store pool for each corresponding state of 
	[em 
		"solver
	]em
	". It increased speed a lot.
	$LF
]div
[div class=p 
	"One very important thing is handling 
	[em 
		"invisible blocks
	]em
	". They block 
	[em 
		"placements
	]em
	". And the main idea of optimized 
	[em 
		"unified solver
	]em
	" was to have premade 
	[em 
		"placements
	]em
	". If some 
	[em 
		"placement
	]em
	" is blocked, it doesn't mean that it's impossible to place tetromino in desired position. Probably there still exists 
	[em 
		"placement
	]em
	" which is slower but it's still an option. As first solution to address this problem was just to filter out 
	[em 
		"placements
	]em
	" which are not suitable for current situation. Another feasible approach would be to look for the best 
	[em 
		"placement
	]em
	" in current circumstances. But it requires time of program to enumerate 
	[em 
		"placements
	]em
	". It was postponed.
	$LF
]div
[div class=p 
	"Later on it was discovered that sometimes shortest input for 
	[em 
		"placement
	]em
	" is not always optimal. Sometimes it's reasonable to perform 
	[em 
		"placement
	]em
	" one frame longer. One of ways to solve this issue was to generate all 
	[em 
		"solvers
	]em
	" with multiple possible 
	[em 
		"placements
	]em
	", not only shortest. In other words, to perform new version of optimization. Fortunately, better way was found. Database of placements was made, with property that it tells what placements it stores if they exists, so it's easy to check: if 
	[em 
		"placement
	]em
	" we require is supposed to be in the database, then it should be in the database. If there is no 
	[em 
		"placement
	]em
	" we looking for then it doesn't exists. If 
	[em 
		"placement
	]em
	" is not supposed to be in the database then either look for 
	[em 
		"placement
	]em
	" yourself, or skip it.
	$LF
]div
[div class=p 
	"So new configuration was added: the database of 
	[em 
		"placements
	]em
	", and policy for 
	[em 
		"placements
	]em
	" which shouldn't be in the database: look for them or skip. With this change, all 
	[em 
		"solvers
	]em
	" from now on were able to choose best 
	[em 
		"placements
	]em
	" from the database.
	$LF
]div
[h3 id=PlacementDatabaseGeneratorC 
	"Placement database generator (C++)
	$LF
]h3
[div class=p 
	"Database is stored in SQLite using official SQLite library. It saves all 
	[em 
		"placements
	]em
	" which ever might be used with the limit on maximum desired vertical position of tetromino. Along each 
	[em 
		"placement
	]em
	" stored inputs required and set of cells which should be empty. Then user of the database can find all placements for desired tetromino type and orientation and pick the most suitable among them.
	$LF
]div
[h3 id=ImplementationOfNesTetrisGameLogicC 
	"Implementation of NES Tetris game logic (C++)
	$LF
]h3
[div class=p 
	"Parts of the game implemented in C++ and tested very carefully. A large number of outputs were compared using Lua from emulator with output from my C++ implementation to make complete match. Those outputs were produced from previous TAS, play by hands, other recordings.
	$LF
]div
[div class=p 
	"From resulting C++ implementation by trial and error was narrowed down variables which is involved in delays mysteries. In addition to frame counter it turned out to be tetromino vertical position (at address 0x41) and thing which is at address 0x49 named vramRow by meatfighter involved. Then, complete automaton of states with those variables involved was made. Using automaton minification algorithm this automaton was reduced similar states. And confirmed following hypothesis regarding delays:
	$LF
]div
[h4 id=TetrominoVerticalPosition 
	"Tetromino vertical position
	$LF
]h4
[ul 
	[li 
		" 0, 1, 2, 3, 4, 5 - equivalent
		$LF
	]li
	[li 
		" 6, 7, 8, 9 - equivalent
		$LF
	]li
	[li 
		" 10, 11, 12, 13 - equivalent
		$LF
	]li
	[li 
		" 18, 19 - equivalent
		$LF
	]li
]ul
[h4 id=Vramrow 
	"vramRow
	$LF
]h4
[ul 
	[li 
		"0, 1, 2, 3 - equivalent
		$LF
	]li
	[li 
		"4, 5, 6, 7 - equivalent
		$LF
	]li
	[li 
		"8, 9, 10, 11 - equivalent
		$LF
	]li
	[li 
		"12, 13, 14, 15 - equivalent
		$LF
	]li
	[li 
		"16, 17, 18, 19 - equivalent
		$LF
	]li
]ul
[div class=p 
	"Using this knowledge, for each possible combination, ways to make any delay was found and info about its generation was hardcoded into generator of 
	[em 
		"solvers
	]em
	". After this work was done, delay mystery was completely solved (for game A-TYPE).
	$LF
]div
[h3 id=TetrisListsPython 
	"Tetris lists (Python)
	$LF
]h3
[div class=p 
	"It is script which allows to run multiple stand-alone brute force tasks. As an input it receive list of sequences of 
	[em 
		"solvers
	]em
	". This is basically just a way to try many different sequences of 
	[em 
		"solvers
	]em
	" for the same set of inputs. Each 
	[em 
		"solver
	]em
	" was given short name, so sequence of 
	[em 
		"solvers
	]em
	" is just few short names. Settings for this script is same as settings of stand-alone brute force just with additional list of sequences to try.
	$LF
]div
[div class=p 
	"Small optimization was made: if there was sequence earlier which starts with same prefix, then take the results of those steps as is, and continue from the step where 
	[em 
		"solvers
	]em
	" differ. 
	$LF
]div
[h3 id=TetrisGraphPython 
	"Tetris graph (Python)
	$LF
]h3
[div class=p 
	"Evolution of Tetris lists. Instead of a list, it receive a graph of transitions. It allows to reuse outputs more efficiently than optimization with skipping common prefix.
	$LF
]div
[h4 id=ListIntoGraphPython 
	"list into graph (Python)
	$LF
]h4
[div class=p 
	"Script which automatically convert list of sequences into corresponding graph
	$LF
]div
[h4 id=GraphToListPython 
	"graph to list (Python)
	$LF
]h4
[div class=p 
	"Script to verify that graph was generated correctly
	$LF
]div
[h4 id=TetrisDebugLua 
	"tetris debug (Lua)
	$LF
]h4
[div class=p 
	"Script for FCEUX to display invisible blocks and other handy information
	$LF
]div
[h4 id=TetrisCheckResultsLua 
	"tetris check results (Lua)
	$LF
]h4
[div class=p 
	"Script for FCEUX to avoid copy pasting inputs by hands. It allows to visually check the results. 
	[a href=https://youtu.be/UMIgfJJRc8A rel=noopener external nofollow 
		"Here is an example video
	]a
	$LF
]div
[h3 id=AdditionalNotes 
	"Additional notes
	$LF
]h3
[ul 
	[li 
		"It was r57shell who wrote all those tools and was responsible for all technical aspects.
		$LF
	]li
	[li 
		"It was Archanfel who planned all strategies.
		$LF
	]li
	[li 
		"It took us about 2 years to complete this project.
		$LF
	]li
]ul
[h2 id=SpecialThanksToAlexeyLeonidovichPajitnov 
	"Special thanks to Alexey Leonidovich Pajitnov
	$LF
]h2
[div class=p 
	[img class=embed mw-100 src=https://s1.hostingkartinok.com/uploads/images/2022/08/34c3940c58b396c54b8575c587993cc8.jpg 
	]img
	$LF
]div
[ul 
	[li 
		"For creating tetris game in year 1984.
		$LF
	]li
	[li 
		"For his 
		[a href=https://venturebeat.com/2022/03/23/tetris-creator-alexey-pajitnov-condemns-russian-invasion-of-ukraine/ rel=noopener external nofollow 
			"anti-war position
		]a
		" in year 2022. 
		$LF
	]li
]ul
[hr 
]hr
[div class=p 
	[a class=intlink href=/Users/Profile/feos 
		"feos
	]a
	": Claiming for judging.
	$LF
]div
[div class=p 
	[a class=intlink href=/Users/Profile/feos 
		"feos
	]a
	": Incredible effort and great improvement! Max score is now reached 1052 frames sooner than in 
	(__wikiLink|href=/1596M|implicitdisplaytext=1596M)
	", and the input is 1121 frames shorter. Accepting as an improvement.
	$LF
]div
[div class=p 
	"Also since 999999 is 
	[a href=https://tetris.wiki/Maxout#Tetris_.28NES.2C_Nintendo.29 rel=noopener external nofollow 
		"actually
	]a
	" a maximum score in unmodified NES Tetris, this run 
	[b 
		"is
	]b
	" a max score run effectively. 
	(__wikiLink|displaytext=A month ago|href=/MovieRules/History#MaximumScoreCategoryAllowedForStandard20220714)
	" we started accepting max score as an unconditional standalone goal to Standard, so in the future there will be lots of runs that aim for max score, and in a lot of games the number is different from others. So to avoid the situation where we explicitly spell out every game's internal score cap in the branch label, we should use a common branch that covers them all while still being technically accurate. Of course if you hack the game and manually remove the score cap that developers added, you can reach higher score. But then it's a different game, derived from this one. So it still makes perfect sense to me to use a common goal for this branch from now on.
	$LF
]div
[div class=p 
	[a class=intlink href=/Users/Profile/Spikestuff 
		"Spikestuff
	]a
	": Publishing.
]div
