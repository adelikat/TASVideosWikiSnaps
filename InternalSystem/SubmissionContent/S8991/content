25
[div class=p 
	"Happy ACEVideos day! 
	$LF
]div
[div class=p 
	"Last year, I submitted an unoptimized (almost working) TAS of Super Mario Bros. that demonstrates executing arbitrary code. Due to emulator inaccuracies with “Open Bus”, the run did not sync on console. One pull request and a year later, I’ll be executing a larger payload inside Super Mario Bros. which 
	[a href=https://www.youtube.com/watch?v=OJXxmD_Qk2o rel=noopener external nofollow 
		"syncs on console! (Thank you Alyosha for verifying this!)
	]a
	$LF
]div
[div class=p 
	"This tool assisted demonstration uses pretty much everything I know about the NES. Enjoy!
	$LF
]div
[div class=p 
	"(This link is for the abridged version that skips the setup, and starts at the important part)
	$LF
]div
[div class=p 
	(youtube|v=lfG8DbxFibY)
	$LF
]div
[div class=p 
	"In these submission comments, I will explain how I created this run, how it works, the limitations I had to work with, and the ideas I used to make it *just* a bit nicer.
	$LF
]div
[div class=p 
	"This TAS was made in Bizhawk 2.9.1.
	$LF
]div
[div class=card mb-2 
	[div class=card-header 
		[strong 
			"Table of contents
		]strong
	]div
	[div class=card-body 
		[ul 
			[li 
				[a href=#Objectives 
					"Objectives:
					$LF
				]a
			]li
			[li 
				[a href=#WhatIsArbitraryCodeExecution 
					"What is Arbitrary Code Execution?
					$LF
				]a
			]li
			[li 
				[a href=#HowDoesArbitraryCodeExecutionWorkInSmb 
					"How does Arbitrary Code Execution work in SMB?
					$LF
				]a
				[ul 
					[li 
						[a href=#SoWhatDoesStartingTheGameInWorldNAchieve 
							"So what does starting the game in world ‘N’ achieve? 
							$LF
						]a
					]li
					[li 
						[a href=#WhatDoesObjectC9Do 
							"What does Object C9 do?
							$LF
						]a
					]li
					[li 
						[a href=#ExecutingArbitraryCode 
							" Executing Arbitrary Code
							$LF
						]a
					]li
					[li 
						[a href=#TangentLetSActuallyTalkAboutTheGameplayBeforeTheAce 
							"Tangent: Let's actually talk about the gameplay before the ACE
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Graphics 
					" The graphics
					$LF
				]a
				[ul 
					[li 
						[a href=#HowWasTheMusicVideoTransformedIntoSmbTiles 
							"How was the music video transformed into SMB tiles?
							$LF
						]a
					]li
					[li 
						[a href=#WhatStepsWereTakenToOptimizeRenderingAFrameInsideTheNes 
							"What steps were taken to optimize rendering a frame inside the NES?
							$LF
						]a
					]li
					[li 
						[a href=#PacketExamples 
							"Packet examples.
							$LF
						]a
					]li
					[li 
						[a href=#HowDidTheOutputListOfBytesGetConvertedIntoPackets 
							"How did the output list of bytes get converted into packets?
							$LF
						]a
					]li
					[li 
						[a href=#Implementing6502AsmCodeToReadThePackets 
							"Implementing 6502 ASM code to read the packets.
							$LF
						]a
					]li
					[li 
						[a href=#IMeantToTalkAboutAddress2002AndCouldnTFindAGoodSectionToMentionIt 
							"I meant to talk about address $2002, and couldn’t find a good section to mention it.
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#Audio 
					"The audio
					$LF
				]a
				[ul 
					[li 
						[a href=#TangentHowDoesThisControllerReadingRoutineWork 
							"Tangent: How does this controller reading routine work?
							$LF
						]a
					]li
					[li 
						[a href=#HowDidYouTurnTheMusicIntoButtonPresses 
							"How did you turn the music into button presses?
							$LF
						]a
					]li
					[li 
						[a href=#TangentUsingDifferentialPulseCodeModulationTheWayNintendoDefinitelyHadPlanned 
							"Tangent: Using Differential Pulse-Code Modulation the way Nintendo definitely had planned.
							$LF
						]a
					]li
					[li 
						[a href=#PlanBToMakeTheAudioCleaner 
							"Plan B to make the audio cleaner.
							$LF
						]a
					]li
					[li 
						[a href=#PlanCToMakeTheAudioCleaner 
							"Plan C to make the audio cleaner.
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#BetterVideoBetterAudioTheBigImprovementTheSecondNametable 
					"Better video, better audio. The big improvement. The second nametable.
					$LF
				]a
				[ul 
					[li 
						[a href=#PlanDToMakeTheAudioCleaner 
							"Plan D to make the audio cleaner.
							$LF
						]a
					]li
					[li 
						[a href=#TangentOkayButWhatIfWeCouldImproveTheGraphicsAgain 
							"Tangent: Okay, but what if we could improve the graphics again?
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#HowTheTasEnds 
					"How the TAS ends
					$LF
				]a
			]li
			[li 
				[a href=#FunDetailsAboutTheCreationOfThisTas 
					"Fun details about the creation of this TAS
					$LF
				]a
			]li
			[li 
				[a href=#Conclusion 
					"Conclusion
					$LF
				]a
			]li
			[li 
				[a href=#SpecialThanks 
					"Special Thanks:
					$LF
				]a
			]li
			[li 
				[a href=#HereSTheAsmCode 
					"Here’s the ASM code:
					$LF
				]a
				[ul 
					[li 
						[a href=#FunStatistics 
							" Fun statistics
							$LF
						]a
					]li
				]ul
			]li
			[li 
				[a href=#WhyDoesThisTasRunSlowlyInTheEmulator 
					"Why does this TAS run slowly in the emulator?
					$LF
				]a
			]li
		]ul
	]div
]div
[h2 id=Objectives 
	"Objectives:
	$LF
]h2
[ol 
	[li 
		"Do a little tomfoolery
		$LF
	]li
	[li 
		"Execute arbitrary code
		$LF
	]li
	[li 
		"Play the Bad Apple!! music video
		$LF
	]li
	[li 
		"Earn the maximum score
		$LF
	]li
	[li 
		"Beat the game in 4:53
		$LF
	]li
]ol
[h2 id=WhatIsArbitraryCodeExecution 
	"What is Arbitrary Code Execution?
	$LF
]h2
[div class=p 
	"Before I dive into the details, I thought I would explain what an “Arbitrary Code Execution” exploit is. Let’s ignore the word “Arbitrary” here, and focus on how the NES executes code in general. The programmers for a NES game write code in “6502 Assembly”, where an instruction may look like “LDA #$80”. Converting assembly code to machine code is remarkably simple, as every possible instruction corresponds to a different value for a byte. For instance, this “LDA” instruction would become the byte “A9”. The full instruction, “LDA #$80” would include that operand, “80” as well, so written as bytes, that entire instruction is simply “A9 80”.
	$LF
]div
[div class=p 
	"A list of 6502 instructions and the values of their opcodes can be found here: 
	[a href=https://www.nesdev.org/obelisk-6502-guide/reference.html rel=noopener external nofollow 
		"https://www.nesdev.org/obelisk-6502-guide/reference.html
	]a
	$LF
]div
[div class=p 
	"A slightly different topic: This is a sentence. As you read this sentence, you’re probably not keeping an exact count of how many words have appeared on this page up to this point. If every word on this page was assigned an ID in order of appearance, you probably wouldn’t correctly guess the ID of this sentence’s last word. The NES on the other hand, needs to know exactly which byte should be processed next, and this information is kept in a 16 bit register called the “Program Counter”, or PC. 
	$LF
]div
[div class=p 
	"The opcode A9 is processed. “LDA”. The PC is incremented. Next byte. The operand “80” is processed. The LDA instruction runs with the value “80”. The PC is incremented. Next byte.
	$LF
]div
[div class=p 
	"This process repeats hundreds of thousands of times a second. A byte is read and interpreted as an instruction, then the PC is moved and ready to interpret the next byte. 
	$LF
]div
[div class=p 
	"Some instructions, such as “JSR” or “JMP”, move the PC to any location of the programmer's choice. For example, suppose part of the code for collecting a coin is at address $BBFE. The instruction “JSR $BBFE” can move the PC there. Data is also pushed to the stack, so the one byte “RTS” instruction can move the PC back to where the “JSR” instruction was.
	$LF
]div
[div class=p 
	"That’s the oversimplified basics of code execution. Bytes are interpreted as instructions, and all the code is just a bunch of bytes. 
	$LF
]div
[div class=p 
	"Fun fact: RAM is just a bunch of bytes. Here’s where we talk about “Arbitrary Code Execution”. If the PC somehow ends up pointing to RAM, those bytes can be interpreted as instructions. More amusing though, if a player is able to manipulate the values in RAM where the PC will move to, they could write code that gets executed. Here’s what a player would need for an ACE exploit:
	$LF
]div
[ol 
	[li 
		"An exploit to move the PC to RAM. Writing a payload that cannot be executed is pointless.
		$LF
	]li
	[li 
		"The ability to manipulate RAM at a location the PC will execute. Moving the PC to RAM is not enough. If the PC jumps somewhere that cannot be manipulated, you cannot execute a payload. The more consecutive bytes that can be manipulated, the more power the player has.
		$LF
	]li
	[li 
		"A general understanding of 6502 ASM. You should be able to look at a series of bytes and know what instructions it will be executed as.
		$LF
	]li
	[li 
		"A goal. You should know what you are trying to achieve with your code.
		$LF
	]li
]ol
[div class=p 
	"With this general understanding of how ACE exploits work, let’s talk about Super Mario Bros. (henceforth referred to as “SMB”) 
	$LF
]div
[h2 id=HowDoesArbitraryCodeExecutionWorkInSmb 
	"How does Arbitrary Code Execution work in SMB?
	$LF
]h2
[div class=p 
	"This TAS begins in world ‘N’, which is not one of the 8 worlds normally found when playing SMB.
	$LF
]div
[div class=p 
	"For the curious, beyond world 8 is world 9, A, B… and so on. World N is the 23rd world. This world can be reached by changing address $7FD to a value of 0x16 (hexadecimal), and starting the game while holding the A Button.
	$LF
]div
[div class=p 
	"By the way, this TAS would actually begin inside another cartridge! In order to start the game in world ‘N’, the state of RAM must be manipulated in a specific way so SMB skips the routine that clears a few extra bytes in RAM when loading the title screen. 
	$LF
]div
[div class=p 
	"When you get a game over, SMB jumps to the same code that runs immediately after booting the game. Several NES games, SMB included, start by clearing almost every byte of RAM. Since your high score is displayed on the title screen, the developers need to check if the RAM values for your score are valid (if the game was already running before this code executed), or if it needs to be cleared too (if the game was not already running before this executed). If you were to use another game to set up RAM to pass the checks SMB1 makes, the stale memory can persist after swapping cartridges to SMB. 
	$LF
]div
[div class=p 
	"Another byte that doesn’t get cleared if the checks pass is the world you were in when you ran out of lives and returned to the title screen (address $7FD). If you hold down the A button while pressing Start, the game is programmed to start the game back at the start of the last world you were in. This TAS begins with modified RAM that passes the checks so these bytes aren’t cleared, and starts the game in world ‘N’. Ideally this modified RAM is set up through an incredibly short TAS of Super Mario Bros. 3, where total control can be achieved in less than a second, and RAM can be manipulated to any desired state. After the RAM is set up, the cartridge is swapped out for SMB, and this TAS begins.
	$LF
]div
[div class=p 
	"Since modern emulators don’t have cartridge swapping as a feature, this TAS was created in a modified version of Bizhawk 2.9.1, where I added such a feature. The uploaded TAS simply omits the Super Mario Bros. 3 step, and begins at the start of SMB with the RAM already set up.
	$LF
]div
[div class=p 
	"I consider this cartridge swapping, “Tomfoolery”, thus satisfying “Objective 1” of this TAS.
	$LF
]div
[h3 id=SoWhatDoesStartingTheGameInWorldNAchieve 
	"So what does starting the game in world ‘N’ achieve? 
	$LF
]h3
[div class=p 
	"Here’s a bit of a tangent, but I promise it’s related. An interesting detail in SMB is what happens when you defeat Bowser by hitting him with fireballs. When most enemies are defeated by fireballs, they flip upside down and fall off screen. When Bowser is defeated this way, his sprite is replaced with a different sprite that will then flip upside down and fall off screen. The “lore” behind this detail is that Bowser's minions are disguising themselves as Bowser, and Mario burns away the disguise.
	$LF
]div
[div class=p 
	"The game uses a LookUp Table to determine what Bowser is replaced with for each world. The order for worlds 1 through 8 is: Goomba, Koopa, Buzzy Beetle, Spiny, Lakitu, Blooper, Hammer Bro, Bowser. But what happens when you are playing beyond the 8 intended worlds of SMB? The table is parsed out of bounds, and unrelated bytes are read as if they were data from the table. In world ‘N’, Bowser gets replaced by an object with the ID 201, or 0xC9 in Hexadecimal.
	$LF
]div
[h3 id=WhatDoesObjectC9Do 
	"What does Object C9 do?
	$LF
]h3
[div class=p 
	"The logic for how each sprite behaves is handled by a Jump Table, which is a list of 16 bit addresses to jump the PC to corresponding to the ID of the enemy. In a similar fashion to the way being in world ‘N’ parses the Bowser table out of bounds, object 0xC9 will parse this jump table out of bounds. Remarkably, it jumps to stable code at address $D007. The code at $D007 is near the end of the screen transition routine. What runs next is code that clears out the enemy sprite slots, increments the game’s “State machine value” (Address $0772), and then jumps to the end of the frame where the console waits for the next vertical blank.
	$LF
]div
[div class=p 
	"The “State machine value” is used for one of the most important jump tables in the game’s logic. Here’s what happens based on the value of the state machine:
	$LF
]div
[div class=p 
	"0. This is used when the game boots up to initialize everything and set up the title screen.
	[br 
	]br
	$LF
	"1. This leads to a jump table of screen updating routines.
	[br 
	]br
	$LF
	"2. This is used during a screen transition to set up the next area.
	[br 
	]br
	$LF
	"3. This is for the regular gameplay loop as you move Mario around. 
	$LF
]div
[div class=p 
	"This value was 3 when Bowser was defeated, and the jump to $D007 increments it to a value of 4. Once again, we’re out of the bounds of a table. This time the game does not jump to stable code, and in fact it doesn’t jump to code at all! The PC is being moved to address $53AE, which isn’t mapped to anything! Not RAM, not ROM, no registers… nothing.
	$LF
]div
[div class=p 
	"Now when the PC fetches the next instruction, nothing comes back. Not necessarily a value of zero. Since nothing gets fetched, the PC ends up reading whatever value is currently on the console's Data Bus. This behavior is known as “Open Bus.” Let’s see what is currently on the Data Bus. An indirect jump instruction took us to address $53AE, and here’s how!
	$LF
]div
[div class=p 
	"JMP ($0006)
	$LF
	"(Addresses $0006 and $0007 are 0xAE and 0x53)
	$LF
]div
[div class=p 
	"1. The CPU Fetches the opcode 0x6C. Indirect Jump.
	[br 
	]br
	$LF
	"2. The CPU Fetches the first byte of the operand, 0x06: The low byte address of the pointer.
	[br 
	]br
	$LF
	"3. The CPU Fetches the second operand, 0x00: The high byte address of the pointer.
	[br 
	]br
	$LF
	"4. Using this pointer, the CPU fetches the target address low byte, 0xAE
	[br 
	]br
	$LF
	"5. Finally, the CPU fetches fetches the target address high byte, 0x53
	$LF
]div
[div class=p 
	"So 0x53 is the value currently on the Data Bus. Since the PC is at $53AE, nothing will get fetched, so the value on the databus will still be 0x53. Exhibiting Open Bus behavior, here’s how the following instruction is read.
	$LF
]div
[div class=p 
	"1. The CPU Fetches the opcode. 0x53
	[br 
	]br
	$LF
	"2. The CPU fetches the 1-byte operand, 0x53
	$LF
]div
[div class=p 
	"A brief note, opcode 0x53 is not an official opcode for the 6502 processor, and has no official name, though it is commonly called “(SRE),Y” which stands for “Indirect Logical Shift Right then Bitwise Exclusive OR Memory (with offset Y) with Accumulator”.
	$LF
]div
[div class=p 
	"3. Using the pointer from the operand, Fetch target address low byte, 0x00 (Address $0053 has a value of 0x00)
	[br 
	]br
	$LF
	"4. Using the pointer from the operand, Fetch target address high byte, 0x00. (This byte also has a value of 0x00) Add the value of the Y register (0x0A) to this address.
	$LF
]div
[div class=p 
	"The SRE instruction is about to modify the value at address $000A, which happens to be a byte the player can easily control. If they are holding down the A button on this frame (and not holding the B button), address $000A will have a value of 0x80, which will allow the PC to move somewhere useful.
	$LF
]div
[div class=p 
	"5. Read from target address, 0x80
	[br 
	]br
	$LF
	"6. Read from target address again, 0x80
	[br 
	]br
	$LF
	"7. Store the old value (0x80) at target address, 0x80
	[br 
	]br
	$LF
	"8. Perform the SRE operation, and store this new value at the target address. 0x40
	$LF
]div
[div class=p 
	"Now the SRE instruction has ended, and the PC is still not mapped to anything. This next instruction will once again exhibit Open Bus behavior. This time, 0x40 is on the bus.
	$LF
]div
[div class=p 
	"1. The CPU fetches the opcode, 0x40. RTI
	$LF
	"…
	$LF
]div
[div class=p 
	"The RTI instruction will pull 3 bytes from the stack. The processor status flags, the target address low byte, and the target address high byte. This ends up moving the PC to address $1181.
	$LF
]div
[h3 id=ExecutingArbitraryCode 
	" Executing Arbitrary Code
	$LF
]h3
[div class=p 
	"Finally, we’re about to execute the arbitrary code. Address $1181 is a location in RAM that SMB never clears when the game boots up. Since this RAM in uninitialized, in theory it could be anything! Uninitialized RAM is the perfect place to write a payload, since it will never be overwritten. Recall how this TAS uses a separate cartridge to start SMB in world 'N'. While the TAS is manipulating RAM pre-cartridge-swap, it can also write custom code at address $1181. 
	$LF
]div
[div class=p 
	"The code written at address $1181 will do the following:
	$LF
]div
[ol 
	[li 
		"Read the controller, write that value to address $C3. (Target address High byte)
		$LF
	]li
	[li 
		"Read the controller, write that value to address $C2. (Target address Low byte)
		$LF
	]li
	[li 
		"Read the controller, write that value to address $C1. (Payload length)
		$LF
	]li
	[li 
		"Set the X register to zero.
		$LF
	]li
	[li 
		"Read the controller, write that value to (Target Address) with offset X. 
		$LF
	]li
	[li 
		"Increment X.
		$LF
	]li
	[li 
		"Repeat steps 5 and 6 until X == (Payload length).
		$LF
	]li
	[li 
		"Read the controller. If the value is zero, return to step 1.
		$LF
	]li
	[li 
		"Read the controller twice, storing at C3 and C2. 
		$LF
	]li
	[li 
		"JMP ($00C2). This jumps to the address determined by step 9.
		$LF
	]li
]ol
[div class=p 
	"With this payload, RAM could be manipulated to nearly any state. (I say “nearly” any state, since overwriting the location where this code is written would take some finesse.)
	$LF
]div
[div class=p 
	"This is used to write code for updating the graphics and playing audio through the sample channel, which is how this TAS plays the video and music for Bad Apple. Once the code is written, a simple jump to the new custom code is all it takes to get the show started. (followed by reading the controller 5.8 million times over the next 3 and a half minutes to get all the visual and audio data)
	$LF
]div
[div class=p 
	"Running arbitrary code is “Objective 2” of this TAS, which has now been satisfied. Objective 3, “Play the Bad Apple!! Music video” might be a bit tricky. Let’s figure this out one step at a time, beginning with the graphics.
	$LF
]div
[h3 id=TangentLetSActuallyTalkAboutTheGameplayBeforeTheAce 
	"Tangent: Let's actually talk about the gameplay before the ACE
	$LF
]h3
[div class= 
	[div class= 
		[ul class=nav nav-tabs role=tablist 
			[li class=nav-item 
				[a class=active nav-link data-bs-toggle=tab href=#tabs-13828-0 
					"Hide Tangent
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-13828-1 
					"Show Tangent
				]a
			]li
		]ul
	]div
	[div class=tab-content 
		[div class=tab-pane fade active show id=tabs-13828-0 
		]div
		[div class=tab-pane fade id=tabs-13828-1 
			[div class=p 
				"World N-1:
				$LF
			]div
			[div class=p 
				"N-1 is an exact copy of 8-3. In addition to beating the level as fast as possible, I also need to collect a fire flower. After submitting my TAS for last year's April Fools Day, I had help from Mizumaririn and Seraphmlll optimizing the gameplay. Out of curiosity, I attempted to save any frames if possible, despite knowing very little about TASing SMB1.
				$LF
			]div
			[div class=p 
				"This TAS includes your typical SMB1 TAS strategies, such as pressing Left+Right to accelerate faster than normal. After parts where I needed to turn around, I also press Left before walking off a ledge, which can allow Mario to accelerate faster.
				$LF
			]div
			[div class=p 
				"To collect a fireflower, one must first collect a mushroom. I was actually able to collect the mushroom a frame before Mizu, though I have no idea how to manipulate hammer bro RNG, losing a frame or two by slowing down to get the right pattern. In any case, I beat N-1 on the same framerule as Mizu was able to. 
				$LF
			]div
			[div class=p 
				"Despite reading a ton of documentation, and even getting the flagpole glitch, I still have no clue how it works or how I would ever do that again. I just compared mario's position, and subpixels with a different TAS, then lined everything up by holding and releasing the R button while mid-air to manipulate the subpixels.
				$LF
			]div
			[div class=p 
				"World N-2:
				$LF
			]div
			[div class=p 
				"N-2 is the same as 8-4, except taking any pipes will warp you back to the start of the level. Instead, you simply run to the right and skip all of the pipes. When Seraphmlll TASed this section last year to optimize my ACE proof of concept TAS, the objective also included landing on the axe after Bowser is defeated. Since this TAS doesn't require that, (and due to a frame I was able to save at the very start of the level) I was able to defeat bowser 4 frames faster than the previous ACE TAS.
				$LF
			]div
			[div class=p 
				"That makes this TAS my first submission to include optimized inputs with actual gameplay, as my other submissions have all utilized subframe inputs to complete a game from the title screen. (or my unoptimized ACEVideos submission last year)
				$LF
			]div
		]div
	]div
]div
[h2 id=Graphics 
	" The graphics
	$LF
]h2
[h3 id=HowWasTheMusicVideoTransformedIntoSmbTiles 
	"How was the music video transformed into SMB tiles?
	$LF
]h3
[div class=p 
	"SMB does not have CHR-RAM, which means the only graphics that can be drawn on screen are a pre-made set of 512 “characters”, 8 pixels by 8 pixels in size. By writing to the PPU register at address $2000, A specific group of 256 characters could be chosen for the Nametable (The background), while another group of 256 characters could be chosen for Objects. (The sprites)
	$LF
]div
[div class=p 
	"Here are the 256 characters used for the backgrounds in SMB: (using a grayscale color palette)
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/Oduc6Db.png 
	]img
	$LF
]div
[div class=p 
	"The first step in turning the music video into characters on the NES’s background, is to decide the resolution. My initial plan was to use the full 256x240 pixels, but since the video is in 4 by 3 aspect ratio, I took it down to 256x192. I wanted the video to play in full glorious 60 FPS, only to realize later down the road the video is actually, in fact, only 30 FPS. Even still, I need to change an incredibly large amount of tiles in a single frame, and to make it worse these can only be updated during a blanking period. (Well, they can only be updated properly during a blanking period. Some visual corruptions occur otherwise).
	$LF
]div
[div class=p 
	"Each frame has 7,161 PPU cycles of Vertical Blank, or 2,387 CPU cycles. Suppose you wanted to draw the same character in every tile on a single screen. Here’s some ASM code to do that.
	$LF
]div
[pre 
	"	LDA #20	 	; A = 0x20. Let's change the PPU Address to $2000
	$LF
	"	STA $2006	; Store 0x20 in the PPU Address. (this changes the high byte)
	$LF
	"	LDA #0	 	; A = 0
	$LF
	"	STA $2006	; Store 0x00 in the PPU Address. (this changes the low byte)
	$LF
	"	LDA #$24	; We’re going to place Character 0x24 in every spot.
	$LF
	"	LDX #C0 	; X = C0
	$LF
	"	LDY #4	 	; Y = 4
	$LF
	"Loop:			; This will run 0x3C0 times. Once per tile on a nametable.
	$LF
	"	STA $2007 	; Store the target character at the next location on nametable.
	$LF
	"	DEX		; Decrement X
	$LF
	"	BNE Loop	; Loop unless X = 0
	$LF
	"	DEY		; Decrement Y
	$LF
	"	BNE Loop	; Loop unless Y = 0
	$LF
]pre
[div class=p 
	"	
	$LF
	"But unless rendering was disabled, something has gone horribly wrong when executing this code. Only about a quarter of the Nametable was changed, and the visuals rendered to the screen were completely wrong.
	$LF
]div
[div class=p 
	"Nametable:
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/1f7eKYa.png 
	]img
	$LF
]div
[div class=p 
	"Screen:
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/vn8Scfi.png 
	]img
	$LF
]div
[div class=p 
	"What happened? When the Vertical Blanking Interval ended, the PPU started drawing the screen using whatever PPU Address was currently loaded. Then, while drawing to the screen, the PPU address was still being changed by the code trying to update the Nametable. Two different processes were using the same address for different means, and they prevented either process from working as intended.
	$LF
]div
[div class=p 
	"While the code for updating the table could be optimized (quite a bit, actually) the real crux of the issue is how limiting the vertical blanking interval is. If 2,387 CPU cycles isn’t enough to draw the whole screen with the exact same tile, then what code could possibly be written to draw a detailed frame with multiple characters? The solution: require fewer tiles to be drawn.
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/ob2E71g.png 
	]img
	$LF
]div
[div class=p 
	"Though there were changes later in the development of this TAS, the first draft uses a resolution of 128x96, or 16x12 characters. A maximum of 192 tiles need to be updated in a single vertical blank, compared to the 960 tiles in the previous attempt.
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/PGtWDYh.png 
	]img
	$LF
]div
[div class=p 
	"Here’s the process of turning a frame from Bad Apple into a 16x12 character grid.
	$LF
]div
[div class=p 
	"I began by making a Visual Studio .net forms application. I already made an application that I’ve been using to convert my ASM code into button presses, so I just added another tab to that program.
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/cSe0hSA.png 
	]img
	$LF
]div
[div class=p 
	"To begin with, I needed a bitmap of the frame from the music video. I found an archive online with every frame from the video at a 1440x1080 resolution in the form of .png files. With a frame loaded as a bitmap, I was able to squish the image into a 128x96 resolution bitmap. Then, for each 8x8 pixel cell of this squished bitmap, I would compare every pixel in this cell with every pixel in a cell from the SMB character set. Since this entire video is black and white, I just recorded the difference for each pixel’s r channel and tallied them up. This number represents how different this SMB character is from the cell of the squished bitmap. After checking each of the 256 cells, the cell with the lowest difference is chosen.
	$LF
]div
[div class=p 
	"Here’s the C# code I wrote in the .net application to find the closest matching tile:
	$LF
]div
[pre 
	"int score;
	$LF
	"int best = int.MaxValue;
	$LF
	"int bestID = -1;
	$LF
	"for (int i = 0; i < 256; i++)
	$LF
	"{
	$LF
	" 	score = 0; //set up next tile
	$LF
	" 	for (int x = 0; x < 8; x++)
	$LF
	" 	{
	$LF
	" 	 	for (int y = 0; y < 8; y++)
	$LF
	" 	 	{
	$LF
	" 	 	 	int chunkVal = badAppleTile.GetPixel(x, y).R; //value of bad apple pixel
	$LF
	" 	 	 	int tileVal = tileMap.GetPixel(
	[em 
	]em
	"(i % 16) * 8 + x, (i / 16) * 8 + y).R; //value of mario tile pixel
	$LF
	" 	 	 	score += Math.Abs(tileVal - chunkVal); //get the difference, add it to the score
	$LF
	" 	 	}
	$LF
	" 	}
	$LF
	" 	// this is like golf, so we're aiming for the lowest score
	$LF
	" 	if (score < best)
	$LF
	" 	{
	$LF
	" 	 	best = score;
	$LF
	" 	 	bestID = i;
	$LF
	" 	}
	$LF
	"}
	$LF
	"// now we have the mario tile that closest matches this 8 pixel block of the music video
	$LF
]pre
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/zVnQ5Bi.png 
	]img
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/GTFFzjJ.png 
	]img
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/I2gSqRJ.png 
	]img
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/7jInH66.png 
	]img
	$LF
]div
[div class=p 
	"This process is repeated for every cell, for every frame. The output of this was a giant list of bytes: 192 bytes per frame, 6562 frames.
	$LF
]div
[div class=p 
	"Of course, not every character will need to be redrawn every frame, and sometimes the same character is being drawn many tiles in a row.
	$LF
]div
[h3 id=WhatStepsWereTakenToOptimizeRenderingAFrameInsideTheNes 
	"What steps were taken to optimize rendering a frame inside the NES?
	$LF
]h3
[div class=p 
	"Consider the following:
	$LF
]div
[div class=p 
	"I can only draw during a blanking interval. Vblank is only 2387 CPU cycles. The most efficient way of reading the controller will take 65 CPU cycles each read. It would be foolish to spend the time inside VBlank reading the controller over and over. Instead, once I finish updating the nametables for a frame, I’ll spend the remaining time reading the controller and writing out all the data for the next frame,  storing it on the zero page. This will make the process of reading the information during VBlank as fast as possible.
	$LF
]div
[div class=p 
	"The order of operations is now:
	$LF
]div
[ol 
	[li 
		"Vblank begins.
		$LF
	]li
	[li 
		"Read bytes from the zero page until the nametable is done
		$LF
	]li
	[li 
		"Write the bytes for next frame’s data.
		$LF
	]li
	[li 
		"Wait for Vblank
		$LF
	]li
]ol
[div class=p 
	"In theory, I could write code that is simply:
	$LF
]div
[pre 
	"; -snip- there would be code here to set up the PPU address. This would happen every 16 tiles.
	$LF
	$LF
	"LDA <$00	; A = the next byte
	$LF
	"STA $2007	; Store the next character on the next tile of the Nametable
	$LF
	"LDA <$01	; A = the next byte
	$LF
	"STA $2007	; Store the next character on the next tile of the Nametable
	$LF
	"LDA <$02	; A = the next byte
	$LF
	"STA $2007	; Store the next character on the next tile of the Nametable
	$LF
	"…
	$LF
]pre
[div class=p 
	"And have that repeat 196 times. That’s only 1104 bytes of the available 2048. It would take exactly 1488 cycles every frame, which is less than the 2387 cycles of Vblank! Even though this would work, I wanted to minimize time spent on this even further. After all, the video is really only 30 FPS, so every other frame would spend 1488 cycles for no reason (also bloating the amount of inputs unnecessarily)
	$LF
]div
[div class=p 
	"Instead, I started thinking about how often an entire row of 16 tiles would be all white tiles or all black tiles. It would be way faster to simply write `STA $2007` 16 times in a row. That’s only 64 cycles per row, instead of the 160 cycles of the previous method. An even more important modification to this code would be to simply not overwrite tiles that didn’t change between frames.
	$LF
]div
[div class=p 
	"To fix all these issues, I imagined a “packet” of bytes to draw specific tiles at a specific location. 2 bytes to set the PPU address, 1 byte for the length, then 1 byte to decide what byte is being drawn. In this case, an entire row of tiles can be stored on the zero page as 4 bytes. Of course, most rows aren’t being entirely changed all at once, and this “compression” can start working against the goal of minimizing bytes / CPU cycles. Suppose an entire row has 16 different bytes. I updated the “packet” system to have two methods. 
	$LF
]div
[div class=p 
	"Method 1: 2 bytes for the PPU address, 1 byte for the length, and 1 byte to represent the tile being drawn ‘n’ times.
	$LF
]div
[div class=p 
	"Method 2: 2 bytes for the PPU address, 1 byte for the length (with bit 7 set), then the following ‘n’ bytes are all the different tiles needed.
	$LF
]div
[div class=p 
	"One more optimization, suppose we draw 3 unique tiles, then a strip of 13 identical tiles. What a waste of CPU cycles it would be to update the PPU Address when it doesn’t need to be changed. Since the PPU address will always be between 0x20 and 0x23, I updated the packets so if the first byte is 0x00, the PPU address can stay where it is, and only use 1 byte for the address, saving an extra controller read.
	$LF
]div
[div class=p 
	"These optimizations are primarily to make sure every frame has as much time as possible to play the audio. This method almost worked perfectly! There is a single frame that requires changing every single tile, and every row uses the more cycle-expensive method.
	$LF
]div
[div class=p 
	"Unfortunately, there is just barely not enough time in VBlank to change every single tile using this current method. I’ll explain how this problem was solved later, but right now I want to explain the packet system a little more.
	$LF
]div
[h3 id=PacketExamples 
	"Packet examples.
	$LF
]h3
[div class=p 
	"So, as an example, suppose the following bytes were being read by my code:
	$LF
]div
[pre 
	"21 82 06 24
	$LF
]pre
[div class=p 
	"21 and 82 are the PPU address, $2182
	[br 
	]br
	$LF
	"06 is the length. I add 1 to this number, so I can use length 0 to represent a single tile. In this case, we have 7 tiles to draw.
	[br 
	]br
	$LF
	"24 is the tile being drawn, which corresponds to a white square.
	$LF
]div
[div class=p 
	"So this will place 7 white tiles from $2182 through $2188.
	$LF
]div
[div class=p 
	"Suppose the bytes that followed were:
	$LF
]div
[pre 
	"00 83 33 22 11 00
	$LF
]pre
[div class=p 
	"00 indicates that we’re not moving the PPU address, so it’s currently at $2189
	[br 
	]br
	$LF
	"83 means we have 4 unique tiles. (because I add 1 here, so 80 is a single unique tile. 81 is two tiles…)
	[br 
	]br
	$LF
	"Then the following bytes, 33 22 11 and 00 are the tiles being drawn.
	$LF
]div
[div class=p 
	"The final addition to the packet system is the terminator. If when reading the first byte of a packet, 0xFF is read, then we’ve finished the changes for this frame!
	$LF
]div
[div class=p 
	"For instance, Frame 42 is the second frame to have any graphical changes. Here’s the entire series of packets for that frame:
	$LF
]div
[pre 
	"21 37 00 40
	$LF
	"21 57 00 40
	$LF
	"21 77 00 40
	$LF
	"21 97 00 A8
	$LF
	"21 B7 00 A8
	$LF
	"21 D7 00 3D
	$LF
	"21 F7 00 7E
	$LF
	"22 17 00 A3
	$LF
	"22 36 81 9C 32
	$LF
	"FF
	$LF
]pre
[div class=p 
	"This is the result:
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/m1Niuit.png 
	]img
	$LF
]div
[div class=p 
	"Right now, All I have is a giant list of bytes representing every tile of every frame. Let's convert this data into packets.
	$LF
]div
[h3 id=HowDidTheOutputListOfBytesGetConvertedIntoPackets 
	"How did the output list of bytes get converted into packets?
	$LF
]h3
[div class=p 
	"This was also done in the visual studio .net forms application.
	$LF
]div
[div class=p 
	"To begin with, it was the process of splitting the frame in 12 rows of 16 bytes, and finding the most optimal way to represent those bytes in the packet format. Specifically optimizing for the fewest CPU cycles to execute, even if it would take more controller reads to store this data on the zero page. For instance, if a row of bytes is:
	$LF
]div
[div class=p 
	[code 
		"24 24 24 24 3F 3E 27 27 27 27 27 27 27 27 27 A8
	]code
	$LF
]div
[div class=p 
	"It could be represented as:
	$LF
]div
[pre 
	" 21 28 03 24	; 4 tiles of 0x24
	$LF
	" 00 81 3F 3E	; 2 unique tiles, 3F and 3E
	$LF
	" 00 08 27	; 9 tiles of 27
	$LF
	" 00 00 A8	; 1 tile of A8
	$LF
]pre
[div class=p 
	"(14 bytes)
	$LF
]div
[div class=p 
	"The time spent reading the start of each packet begins to add up, and it saves a significant amount of CPU cycles to simply read the whole row as a series of “unique tiles”, like:
	$LF
]div
[pre 
	"21 28 8F 24 24 24 24 3F 3E 27 27 27 27 A8 24 24 24 24 24 ; 16 “unique” tiles in a row.
	$LF
]pre
[div class=p 
	"(19 bytes)
	$LF
]div
[div class=p 
	"19 is larger than 14 
	[sup 
		"[citation needed]
	]sup
	". Despite this, the 19 byte packet would take fewer CPU cycles to process compared to the set of 4 packets taking up fewer bytes.
	$LF
]div
[div class=p 
	"Of course, not every row is most optimal if read entirely as “unique tiles”. In several cases, most of the row doesn’t need to be changed at all. Suppose the difference between this frame and the one before is a single tile being moved one tile to the left, and replacing the old position with a white square.
	$LF
]div
[pre 
	"22 6C 81 33 24 ; 2 unique tiles in a row
	$LF
]pre
[div class=p 
	"It changes only the tiles that need changed, and nothing more. But what if on one frame, there are the characters, 55 24 24 24 24 66, and on the next frame, it’s 33 24 24 24 24 44? It’s actually faster to overwrite all the existing “24 tiles” with the same values than to change the PPU address, so the packet would look like
	$LF
]div
[pre 
	"22 28 85 33 24 24 24 24 44 ; 6 “unique” tiles in a row.
	$LF
]pre
[div class=p 
	"With this method, It’s faster to overwrite existing tiles for 5 unchanged tiles in a row, but any more than that and it’s faster to start a new packet at an updated PPU address.
	$LF
]div
[div class=p 
	"With this knowledge of optimizing for the fewest CPU cycles, I compressed the data into packets and stored it on the zero page each frame. If a frame has no changes, all that needs to be stored is 0xFF at address $0000.
	$LF
]div
[div class=p 
	"The end result of this program, after creating all the bytes for the packets, converts these bytes into button presses, which I could paste into the TAStudio timeline. 
	$LF
]div
[h3 id=Implementing6502AsmCodeToReadThePackets 
	"Implementing 6502 ASM code to read the packets.
	$LF
]h3
[div class=p 
	"When the ACE exploit begins, all I have is a controller reading loop at address $1181. For the record, there are only 0x800 bytes in RAM. Address $1181 is an exact copy of address $0181, or as we call it in fancy 6502 terms, this address is a “mirror” of $0181.
	$LF
]div
[div class=p 
	"The code changed quite a bit, though I generally kept everything in the same place through each iteration.
	$LF
]div
[pre 
	"Address $000 through $0FF: The zero page. The "packet" data is stored here each frame.
	$LF
	"Address $100 through $1FF: The original "Total control code" is still here. I don't change the stack at all during the video.
	$LF
	"Address $200 through $2FF: Unused space. I'm not using OAM in the TAS, so I could have used this space, though I didn't need it.
	$LF
	"Address $300 through $6FF: The code to parse the packets, then read the controller for writing the next frame data / writes to APU.
	$LF
	"Address $700 through $7FF: Part of the packet parsing involves jump tables, which lead to a series of repeated instructions I put here.
	$LF
]pre
[div class=p 
	"The final version of the ASM code is shared at the end of this write-up.
	$LF
]div
[h3 id=IMeantToTalkAboutAddress2002AndCouldnTFindAGoodSectionToMentionIt 
	"I meant to talk about address $2002, and couldn’t find a good section to mention it.
	$LF
]h3
[div class=p 
	"One more detail about this TAS that I’ll gloss over here but explain at the very end: I read from $2002 to check for Vblank, which can result in a false negative due to a race condition. Anyway, I read the controller, store that value, and then re-use that value to prevent the race condition if needed. Again, I’ll explain how it prevents that in detail later, but you should know I re-use that controller read to exit the “music video loop”. If I press the A button with that controller read, the PC jumps to address $0181, the “total control payload” which lets me write more code. That’s only used at the end of the TAS so I can return to stable SMB1 gameplay. More on that later.
	$LF
]div
[div class=p 
	"I had to mention it though, since I’ll talk about the $2002 race condition later, and it would make no sense if I didn’t even mention it being problematic yet. These following sections flow into each other, and this was the last good break to mention the race condition’s existence. Anyway, back to the TAS.
	$LF
]div
[h2 id=Audio 
	"The audio
	$LF
]h2
[div class=p 
	"Ever since the TASBot showcase at GeekPWN 2016, I have been fascinated with the theoretical limits of the NES audio chip. Streaming music data through the controllers can sound way better than I thought, so why not use that method for the Bad Apple music?
	$LF
]div
[div class=p 
	"The NES audio chip’s DMC channel can play 7-Bit PCM audio. Playing this audio is done by repeated writes to address $4011. My controller reading + writing to $4011 loop takes exactly 71 CPU cycles, (there are 1,789,772.72 CPU cycles in a second, so we can calculate the hertz by dividing that number by 71) so I’m playing audio at 25208.06 Hz.
	$LF
]div
[div class=p 
	"Here’s my code for optimally reading the controller and playing this:
	$LF
]div
[pre 
	"PlayPCMSample:
	$LF
	"	LDA #01
	$LF
	"	STA $4016		; strobe the controllers
	$LF
	"	LSR A
	$LF
	"	STA $4016 		; strobe controllers part 2
	$LF
	"    
	$LF
	"	EOR $4016		; Very fast controller reading using Exclusive OR
	$LF
	"	ASL A			; Credit goes to total for informing me of this.
	$LF
	"	EOR $4016
	$LF
	"	ASL A
	$LF
	"	EOR $4016		; Also this loop is unrolled because it’s faster.
	$LF
	"	ASL A
	$LF
	"	EOR $4016		; Branches waste CPU cycles.
	$LF
	"	ASL A
	$LF
	"	EOR $4016
	$LF
	"	ASL A
	$LF
	"	EOR $4016
	$LF
	"	ASL A
	$LF
	"	EOR $4016
	$LF
	"	ASL A
	$LF
	"	EOR $4016
	$LF
	"	EOR #$C0		; Flip the bits that were flipped from Open Bus.
	$LF
	$LF
	"	STA $4011		; Write this to the audio chip.
	$LF
	"	CLC 			; Clear the carry flag. (the open bus + ASL would set this)
	$LF
	"	ASL A			; Shove bit 7 into the carry flag
	$LF
	"	BCC PlayPCMSample	; If bit 8 was set, we exit. Otherwise, loop.    	
	$LF
]pre
[div class=p 
	"And this will run as many times as possible before Vblank begins.
	$LF
]div
[h3 id=TangentHowDoesThisControllerReadingRoutineWork 
	"Tangent: How does this controller reading routine work?
	$LF
]h3
[div class= 
	[div class= 
		[ul class=nav nav-tabs role=tablist 
			[li class=nav-item 
				[a class=active nav-link data-bs-toggle=tab href=#tabs-33134-0 
					"Hide Tangent
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-33134-1 
					"Show Tangent
				]a
			]li
		]ul
	]div
	[div class=tab-content 
		[div class=tab-pane fade active show id=tabs-33134-0 
		]div
		[div class=tab-pane fade id=tabs-33134-1 
			[div class=p 
				"While we’re here, those reading this with a basic understanding of 6502 ASM might be asking how exactly this controller reading code works, and what in the world that “EOR #$C0” is doing at the end? Let’s quickly review some standard controller reading code:
				$LF
			]div
			[pre 
				"start:
				$LF
				"	LDA  #1
				$LF
				"	STA $4016	; Write 1 to the controller port
				$LF
				"	LDA #0
				$LF
				"	STA $4016	; Write 0 to the controller port
				$LF
				"			; This “strobes” the controller. 
				$LF
				"			; The controller has a shift register inside it that records the buttons pressed.
				$LF
				"			; Reading from the controller grabs 1 button at a time.
				$LF
				$LF
				"	LDX #8		; X = 8. We will read the controller 8 times.
				$LF
				"loop:
				$LF
				"	LDA $4016 	; A = a single bit from the controller in bit 0
				$LF
				"	LSR A		; A is shifted to the right, sending the contents of bit 0 into the carry flag.
				$LF
				"	ROL <$00	; Address $00 is shifted left, and the carry flag is sent to bit 0.
				$LF
				"	DEX		; Decrement X
				$LF
				"	BNE loop	; Loop until X = 0
				$LF
				"			; Once X = 0, the full 8 bits of the controller are stored in address $00
				$LF
				"	LDA <$00	; A = the contents from address $00, which is the full controller data.
				$LF
				"End:
				$LF
			]pre
			[div class=p 
				"This sets up the A register with the buttons stored in the following order (from most significant bit to least): A, B, Select, Start, Up, Down, Left, Right.
				$LF
			]div
			[div class=p 
				"From “start” to “end”, this controller reading routine will take 144 CPU cycles. It also uses an address on the zero page to temporarily store the values being read. There is plenty of room for optimizations, but let’s learn one more fun fact about reading from the controller ports.
				$LF
			]div
			[div class=p 
				"Only bits 0 through bit 4 are read back from register $4016.
				$LF
			]div
			[div class=p 
				"In binary, we’re looking at 00011111. 
				$LF
			]div
			[div class=p 
				"For a little bit of terminology, the bits are numbered from right to left, 0 through 7. So when I say bit 0, it’s the one on the far right. Bits are numbered as 76543210.
				$LF
			]div
			[div class=p 
				"Bit zero will be the value of the next button read from the controller. In our “00011111” example, the other bits set as one are used for various other controller inputs, such as the NES zapper and the Famicom controller’s microphone, which will always be a zero when read from a standard controller. Those bits in “00011111” that are zeroes represent the bits which are not set by a read from $4016. Remember Open Bus? These bits here are going to exhibit open bus behavior.
				$LF
			]div
			[div class=p 
				"Let’s walk through the cycles that occur when reading from the controller.
				$LF
			]div
			[div class=p 
				"LDA $4016 (8D 16 40):
				$LF
			]div
			[ol 
				[li 
					"Fetch the opcode: 8D (10001101)
					$LF
				]li
				[li 
					"Fetch first operand: 16 (00010110)
					$LF
				]li
				[li 
					"Fetch the second operand: 40 (01000000)
					$LF
				]li
				[li 
					"Read from target address: (010xxxxx)
					$LF
				]li
			]ol
			[div class=p 
				"Fascinating! So whenever the console reads from $4016, it will always return a 010 pattern for bits 7,6, and 5.
				$LF
			]div
			[div class=p 
				"With this knowledge, let’s start optimizing the controller reading routine. Step 1, unroll the loop. Branches waste CPU cycles.
				$LF
			]div
			[div class=p 
				"Step 2, instead of shifting bit 0 to the carry flag and shifting the carry flag into another byte, can’t we just keep everything inside the A register?
				$LF
			]div
			[div class=p 
				"What if we try:
				$LF
			]div
			[pre 
				"	ORA $4016	; Bitwise OR A with the controller data (Setting bit 0)
				$LF
				"	ASL A		; Shift to the left. (Scooting bit 0 into bit 1)
				$LF
				"	ORA $4016	; Bitwise OR A with the controller data (Setting bit 0)
				$LF
				"	ASL A		; Shift to the left. (Scooting bit 1 into bit 2, and bit 0 into bit 1)
				$LF
				"	; … and so on
				$LF
			]pre
			[div class=p 
				"Here’s where that pesky Open Bus behavior gets in the way. Suppose in this example all buttons on the controller are held. Bit 6 will be set as well as bit 0.
				$LF
			]div
			[pre 
				"	LDA #0		; A = 00000000
				$LF
				"	ORA $4016	; A = 01000001
				$LF
				"	ASL A		; A = 10000010
				$LF
				"	ORA $4016	; A = 11000011
				$LF
				"	ASL A		; A = 10000110
				$LF
				"	ORA $4016	; A = 11000111
				$LF
				"	ASL A		; A = 10001110
				$LF
				"	ORA $4016	; A = 11001111
				$LF
				"	ASL A		; A = 10011110
				$LF
				"	ORA $4016	; A = 11011111
				$LF
				"	ASL A		; A = 10111110
				$LF
				"	ORA $4016	; A = 11111111
				$LF
				"	ASL A		; A = 11111110
				$LF
				"	ORA $4016	; A = 11111111
				$LF
				"	ASL A		; A = 11111110
				$LF
				"	ORA $4016	; A = 11111111
				$LF
			]pre
			[div class=p 
				"Bit 6 will pollute our otherwise clean controller reading! If we press all the buttons it works out just fine, but if all buttons were unpressed, it will still read as if two of them were set! Now something interesting happens if instead of a bitwise OR we were to use a bitwise Exclusive OR.
				$LF
			]div
			[pre 
				"	LDA #0		; A = 00000000
				$LF
				"	EOR $4016	; A = 01000001
				$LF
				"	ASL A		; A = 10000010
				$LF
				"	EOR $4016	; A = 11000011
				$LF
				"	ASL A		; A = 10000110
				$LF
				"	EOR $4016	; A = 11000111
				$LF
				"	ASL A		; A = 10001110
				$LF
				"	EOR $4016	; A = 11001111
				$LF
				"	ASL A		; A = 10011110
				$LF
				"	EOR $4016	; A = 11011111
				$LF
				"	ASL A		; A = 10111110
				$LF
				"	EOR $4016	; A = 11111111
				$LF
				"	ASL A		; A = 11111110
				$LF
				"	EOR $4016	; A = 10111111
				$LF
				"	ASL A		; A = 01111110
				$LF
				"	EOR $4016	; A = 00111111
				$LF
			]pre
			[div class=p 
				"Instead of bits 6 and 7 always being set, they will be inverted. For instance, if no buttons were pressed, the result would be 11000000. If the buttons pressed should be read as 01010101, it would be read as 10010101. This can easily be solved by simply flipping bits 6 and 7 with EOR #$C0. (Exclusive or with the number 11000000. Flip those 2 bits.)
				$LF
			]div
			[div class=p 
				"Some other optimizations:
				$LF
			]div
			[pre 
				"	LDA #1		; A = 1
				$LF
				"	STA $4016	; strobe the controllers
				$LF
				"	LDA #0		; A = 0
				$LF
				"	STA $4016 	; strobe controllers part 2
				$LF
			]pre
			[div class=p 
				"Can become:
				$LF
			]div
			[pre 
				"	LDA #01		; A = 1
				$LF
				"	STA $4016	; strobe the controllers
				$LF
				"	LSR A		; A = 0
				$LF
				"	STA $4016 	; strobe controllers part 2
				$LF
			]pre
			[div class=p 
				"That takes the same amount of CPU cycles, but it saves us one byte of our payload! This makes the new finalized input code:
				$LF
			]div
			[pre 
				"Start:
				$LF
				"	LDA #01		; A = 1
				$LF
				"	STA $4016	; strobe the controllers
				$LF
				"	LSR A		; A = 0
				$LF
				"	STA $4016 	; strobe controllers part 2
				$LF
				$LF
				"	EOR $4016	; Bitwise XOR with the controller data (Setting bit 0 and 6)
				$LF
				"	ASL A		; Shift to the left
				$LF
				"	EOR $4016	; That bit 6 getting set is from Open Bus, as explained above.
				$LF
				"	ASL A		; 
				$LF
				"	EOR $4016	; 
				$LF
				"	ASL A		; Also we unrolled the loop because it’s faster
				$LF
				"	EOR $4016	; Branches waste CPU cycles.
				$LF
				"	ASL A		; Also if we were using the X or Y registers…
				$LF
				"	EOR $4016	; this avoids overwriting them.
				$LF
				"	ASL A		; It takes more bytes to write it this way.
				$LF
				"	EOR $4016	; But it runs much faster!
				$LF
				"	ASL A		; 
				$LF
				"	EOR $4016	;
				$LF
				"	ASL A		;
				$LF
				"	EOR $4016	;
				$LF
				"	EOR #$C0	; Flip the bits that were flipped from Open Bus.
				$LF
				"End:
				$LF
			]pre
			[div class=p 
				"This takes 63 cycles from “Start” to “End”.
				$LF
			]div
			[div class=p 
				"One optimization I devised about half a month after this submission was made,
				$LF
			]div
			[pre 
				"	LDA #01		; A = 1
				$LF
				"	STA $4016	; strobe the controllers
				$LF
				"	LSR A		; A = 0
				$LF
				"	STA $4016 	; strobe controllers part 2
				$LF
			]pre
			[div class=p 
				"can become
				$LF
			]div
			[pre 
				"	STY $4016	; strobe the controllers
				$LF
				"	STX $4016 	; strobe controllers part 2
				$LF
				"	TXA 	 	; A still needs to be zero here.
				$LF
			]pre
			[div class=p 
				"if X=1, and Y=0. This saves 2 cycles. 
				$LF
				"Another 2 cycles can be saved by removing the CLC instruction in the audio loop, which could improve the audio up to 26,669 Hz.
				$LF
			]div
			[div class=p 
				"Anyway, that’s how the controller reading code was optimized so I can fit as many audio samples into a frame as possible.
				$LF
			]div
		]div
	]div
]div
[h3 id=HowDidYouTurnTheMusicIntoButtonPresses 
	"How did you turn the music into button presses?
	$LF
]h3
[div class=p 
	"Now that we know how the button presses turn into Nes Chip audio, let’s turn Bad Apple into button presses.
	$LF
]div
[div class=p 
	"Remember that archive that had every frame as a 1080p .png file? The archive also provided a .wav file of the music!
	$LF
]div
[div class=p 
	"The .wav file format is a single header, followed by PCM data for the entire remainder of the file. This .wav file had a 0x50 byte header, followed by 16 bit PCM audio (2 bytes per sample) at a rate of 48kHz (48,000 samples per second). Since the NES APU can play PCM audio, I just need to grab a byte from the wav file and convert that to 7 Bit PCM. Some simple math can be used to calculate which byte from the wav file I should convert for a given sample.
	$LF
]div
[div class=p 
	"I’ll be playing my audio at 1 sample per 71 CPU cycles. In order to get the correct sample to send to the audio chip at the right time, I would need to know the exact number of CPU cycles that have passed since the TAS began playing the music video. Luckily, when the screen is rendering, every frame is the same amount of cycles! Well, it’s a consistent pattern of 29780, 29781, 29780, 29781… so we can average it out to 29780.5 cycles per frame.
	$LF
]div
[div class=p 
	"To make a long story short, I used a custom 6502 emulator I wrote to emulate the frame until the first write to the APU and count all the cycles for me. 
	$LF
]div
[div class=p 
	"With the knowledge of exactly how many CPU cycles have occurred since the start of the video and playing the next audio sample, I can simply convert from CPU cycles to bytes inside the wav file. The file is 48,000 samples a second, and there are 1,789,772.72 CPU cycles per second. (When creating this TAS I incorrectly used the number 1,786,830, though I figured I should write down the correct number.) Accounting for the wav file’s 0x50 byte header, and how each sample is 2 bytes long, grabbing the desired byte (The high byte of the sample) is simply:
	$LF
]div
[div class=p 
	[code 
		"(Floor(TimeInSeconds * 48000) * 2) + 0x50 + 1
	]code
	$LF
]div
[div class=p 
	"Where TimeInSeconds is the current CPU cycle divided by 1,786,830.
	$LF
]div
[div class=p 
	"Knowing how many cycles I have left before the frame ends, I was able to pack in as many audio samples as possible before exiting the loop and waiting for VBlank. (Optimizing for the smallest possible wait for VBlank)
	$LF
]div
[div class=p 
	"Of course, the huge drawback here is that for all the time spent updating the nametables and filling in the bytes on the zero page, audio data is halted. A flat line in the audio happens every frame.
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/9bTkrtm.png 
	]img
	$LF
]div
[div class=p 
	"Let’s brainstorm some ideas on playing audio during those busy parts of the frame.
	$LF
]div
[div class=p 
	"In theory, I could try to use the DMC channel’s DPCM audio functionality for the split second between leaving the audio playing loop and re-entering it, but that sounded too complicated. Also using DPCM audio runs the risk of corrupting controller reads, which sounded scary.
	$LF
]div
[h3 id=TangentUsingDifferentialPulseCodeModulationTheWayNintendoDefinitelyHadPlanned 
	"Tangent: Using Differential Pulse-Code Modulation the way Nintendo definitely had planned.
	$LF
]h3
[div class= 
	[div class= 
		[ul class=nav nav-tabs role=tablist 
			[li class=nav-item 
				[a class=active nav-link data-bs-toggle=tab href=#tabs-42945-0 
					"Hide Tangent
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-42945-1 
					"Show Tangent
				]a
			]li
		]ul
	]div
	[div class=tab-content 
		[div class=tab-pane fade active show id=tabs-42945-0 
		]div
		[div class=tab-pane fade id=tabs-42945-1 
			[div class=p 
				"So I tried it anyway.
				$LF
			]div
			[div class=p 
				"DPCM audio cannot play samples from RAM (even if the audio chip overflows beyond address $FFFF, it will remain inside the ROM data by looping to address $8000 instead of $0000), so if I want to fill in these gaps with DPCM audio, I would have to use existing bytes inside the SMB ROM.
				$LF
			]div
			[div class=p 
				"But this got me thinking. Recall how I used the existing character data to approximate the visuals. Okay, now think about that, but taking the game’s ROM and approximating DPCM audio to fill in the gaps where the PCM stops playing.
				$LF
			]div
			[div class=p 
				"The plan: After the final audio input is written for a frame, I need to know when (How many CPU cycles since the movie began) the next frame’s first write to the audio chip will be.
				$LF
			]div
			[div class=p 
				"With that info, I could create a spline along the .wav file’s PCM data from where the gap starts to where it ends, then test how SMB’s ROM data (when read as DPCM audio) compares. With my graphical data I compared every pixel in the 8 by 8 cell against each of the characters. With this I’ll take every “sample” (value of the DMC output) in every possible “sample” (short audio clip) I can create, using the 256 possible starting positions, and 16 possible sample rates, using whatever sample length would get as close to, but without going over the PC reaching the first controller read of the next frame, and compare that against the .wav file’s sample data as a spline. Then, just like with the images, I’ll tally up all the samples and see which one is closest.
				$LF
			]div
			[div class=p 
				"Anyway, to make a long story short, the fastest sample rate of DPCM audio is not enough to get in the minimal sample length before I need the controller again (even for the frame with the longest break between audio loops), so I wrote the code to do that for nothing, and this section of my authors notes could have been omitted. In theory, it would’ve been really cool though.
				$LF
			]div
		]div
	]div
]div
[h3 id=PlanBToMakeTheAudioCleaner 
	"Plan B to make the audio cleaner.
	$LF
]h3
[div class=p 
	"Okay, so DPCM audio is no good.
	$LF
]div
[div class=p 
	"The big issue that needs fixed might not be the large gaps, but rather the steep change when the audio loop resumes.
	$LF
]div
[div class=p 
	"What if I spend the first 16th of the audio loop using linearly interpolated values between the last sample of the previous loop, and the current sample.
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/sYRh1iI.png 
	]img
	$LF
]div
[div class=p 
	"This isn’t a perfect solution, but rest assured this makes the audio sound better. Every frame had a noticeable click before this change, now it’s only a gritty sound.
	$LF
]div
[h3 id=PlanCToMakeTheAudioCleaner 
	"Plan C to make the audio cleaner.
	$LF
]h3
[div class=p 
	"While the previous method made the audio less ear-hurting, I still think there’s room for improvement.
	$LF
]div
[div class=p 
	"The most time consuming aspect of this TAS is filling in the bytes for the zero page on frames that have a lot of data. The most dense frame being 0xE4 bytes! (That problematic frame I talked about earlier) That frame takes 15732 CPU cycles just to fill in, which is almost 53% of the frame spent not writing to the audio chip.
	$LF
]div
[div class=p 
	"Some incredibly rough math done in my head would tell me that I just barely don’t have enough time in a frame to alternate a single write to the APU for each write to the zero page. I *could* write two bytes to the zero page and one byte to the audio chip in a loop though. To optimize this write to the APU, I’ll only read the first 7 bits of the controller, since only 7 bits are sent to the APU. With my method of controller reading, the inputs need to be shifted to the left. So if I wish to send 0x40 to the audio chip, what would normally be just the B button, is now just the A button for this input.
	$LF
]div
[div class=p 
	"The (simplified) order of operations is now:
	$LF
]div
[ol 
	[li 
		"Vblank begins
		$LF
	]li
	[li 
		"Update Nametable
		$LF
	]li
	[li 
		"Read controller to prevent the $2002 race condition / exit the music video loop.
		$LF
	]li
	[li 
		"Read controller to determine number of bytes needed on zero page
		$LF
	]li
	[li 
		"Read controller X + (X/2) times, where every third input is a bit shifted 7-bit input sent to the APU.
		$LF
	]li
	[li 
		"Read controller as many times as possible for highest quality audio
		$LF
	]li
	[li 
		"Wait for Vblank
		$LF
	]li
]ol
[div class=p 
	"While before, the audio would swap from 25208.06Hz to 0Hz, now the TAS will swap from 25208.06Hz, to (a microscopic 0Hz moment, to) 9163.23Hz, to 25208.06Hz, to very briefly, 0Hz when it updates the graphics.
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/K3uekFH.png 
	]img
	$LF
]div
[div class=p 
	"The result is cleaner audio, but something still seems to make the audio sound grainy and bad. 
	$LF
]div
[div class=p 
	"Before I get desperate and try adding audio data to my packet system, I want to try writing to the APU after every write to the Zero Page. Perhaps the change from 25kHz to 9kHz is way too noticeable. This change will bump that 9.16kHz to 13.85kHz. 
	$LF
]div
[div class=p 
	"Big issue: There’s a single problematic frame where there’s not enough time to fill in the data on the zero page if I’m writing to the audio chip this often… right? The problematic frame has 0xE4 bytes to write, and the new loop takes 129 CPU cycles per byte. Hm- let’s see… 0xE4 * 129 = 29412. Which is… less than 29780!
	$LF
]div
[div class=p 
	"Let’s consider the remaining cycles in this frame:
	$LF
]div
[pre 
	"132 		; These happen before the controller reading loop.
	$LF
	"+ 29412		; The cycles are from our graphics data/APU controller reading loop.
	$LF
	"+ 69 		; A minimum of 1 read sent to the APU after the graphical data writing loop.
	$LF
	"+ 15 		; The remaining cycles before spinning (waiting for V-Blank). 
	$LF
]pre
[div class=p 
	"That’s a total of 29629 cycles, which means there’s actually still room for some more writes to the APU! Just *barely*!
	$LF
]div
[div class=p 
	"Well, how does it sound? Does increasing the Hz by almost 5,000 fix the issue?
	$LF
]div
[div class=p 
	"Oh absolutely. There’s still a gritty noise, though it’s much much quieter, and becomes unnoticeable when all the instruments kick in.
	$LF
]div
[div class=p 
	"See if you can can spot where the sample rate dips in the middle of this image:
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/zYvqinx.png 
	]img
	$LF
]div
[div class=p 
	"It would seem like the logical next step would be to fix the audio abruptly stopping when the screen is being updated. Those writes to the nametable leave a pretty clear cut in the audio.
	$LF
]div
[div class=p 
	"Unfortunately, while I could add audio data to the system of graphical packets (at an execution cost of only 10 CPU cycles per packet) adding that data would make that one frame take more than 0xE4 bytes of data, bringing it up to 0xF0 bytes, and then with my new interlaced “write to Zero Page, write to audio chip, write to Zero Page, write to audio chip” method of keeping the audio clean, that one frame would absolutely run out of time.
	$LF
]div
[div class=p 
	"But what if there was a way to fix every one of these issues?
	$LF
]div
[h2 id=BetterVideoBetterAudioTheBigImprovementTheSecondNametable 
	"Better video, better audio. The big improvement. The second nametable.
	$LF
]h2
[div class=p 
	"After going through several hoops to improve the audio, I began wondering if I could up the resolution. After all, I initially created this under the assumption it would be 60FPS. If I’m rewriting the ASM code for the graphics with the knowledge that this is 30 FPS, I can utilize the second nametable. By utilizing the second nametable, I could spend 2 frames to draw it, then swap which nametable the screen is looking at. I would have 2 VBlanks at my disposal, doubling the amount I could draw for a visual frame!
	$LF
]div
[div class=p 
	"Let’s do some math. With the current method, I can draw about 16*12 characters in a single VBlank, which is 192 characters. What’s the largest 4x3 integer ratio where dividing it by two would be less than 192? The answer is… 20 by 15. It’s an improvement, even if it’s a small one. Going a bit further, to 24 by 18 yields (24*18)/2 = 216, which is pretty close, but I don’t believe there’s enough time in a Vblank to make it happen. Let’s start by getting the 20 by 15 version working.
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/SWs9rHY.png 
	]img
	$LF
]div
[div class=p 
	"There are some huge advantages to this Two-Nametable method. Previously I had to draw up to 192 tiles in a single VBlank. Now the limit is 150 tiles in one VBlank. That leaves me with even more time in a frame for the audio, and enough extra bytes on the zero page that I could add audio data into the packets! The more I think about it, the more obvious it is that I should have done this from the beginning. This fixes everything. Let’s make some modifications to the ASM code. 
	$LF
]div
[ul 
	[li 
		"The rendered nametable needs to swap every 2nd frame.
		$LF
	]li
	[li 
		"The series of optimal write instructions to the nametables, as well as the jump tables to go there need to be extended to account for a row of up to 20 tiles.
		$LF
	]li
	[li 
		"The packets need to include 1 byte of audio data now.
		$LF
	]li
]ul
[div class=p 
	"After making these adjustments, I realized I still had 925 bytes in RAM being unused. That’s 45% of RAM! Keep in mind, this entire time I’ve been optimizing for the fewest CPU cycles, so my ASM code is already taking up way more bytes than necessary. Well, can I use these 925 bytes to improve anything? I’ve got another idea to improve the audio a bit.
	$LF
]div
[div class=p 
	"What do you think sounds better? 
	$LF
]div
[ul 
	[li 
		"50% audio quality for 25% of the frame, followed by 100% audio quality for the rest.
		$LF
	]li
	[li 
		"87% audio quality for 75% of the frame, followed by 100% audio quality for the rest.
		$LF
	]li
]ul
[div class=p 
	"My theory is the latter. I might be playing at 100% quality for a shorter amount of time, but I think the dips to 50% are going to be making the audio sound worse, even if it only happens for a very small amount of time. Let’s write some code for dynamic audio quality, based on the amount of bytes I need to write to the zero page!
	$LF
]div
[h3 id=PlanDToMakeTheAudioCleaner 
	"Plan D to make the audio cleaner.
	$LF
]h3
[div class=p 
	"The time spent writing data to the zero page is currently interlacing one write to the audio chip, one write to zero page. Some frames require only a single write to the zero page, others will require upwards of 193. That means for some frames near the average, I might be able to interlace 2 writes to the audio chip, or even 3 writes for each byte depending on the amount of data I need to write to the zero page. The idea here will be to have multiple functions for interlacing audio and graphical data. Different functions will be used depending on how many writes to the zero page are required, and how many writes to the audio chip I can make between the graphical bytes.
	$LF
]div
[div class=p 
	"In any other situation, any reasonable programmer would look at this code and be upset. Stackoverflow.com would have a field day. I would argue that in this particular situation, it would be foolish not to do this!
	$LF
]div
[div class=p 
	"This was the final change made to the TAS.
	$LF
]div
[div class=p 
	"The current order of operations is now:
	$LF
]div
[ol 
	[li 
		"Wait for Vblank
		$LF
		[ol 
			[li 
				"Disable rendering. (In theory this was unneeded, but good practice.)
				$LF
			]li
		]ol
	]li
	[li 
		"Make all the graphical changes
		$LF
		[ol 
			[li 
				"Read the next byte from the zero page. Check for Terminator
				$LF
			]li
			[li 
				"If it wasn't the terminator, check if the PPU Address needs to be moved.
				$LF
				[ul 
					[li 
						"If so, Write to $2006. Read the next byte, and also write to $2006.
						$LF
					]li
				]ul
			]li
			[li 
				"Read the next byte. Write PCM data to APU ($4011)
				$LF
			]li
			[li 
				"Read the next byte. This is the length of data to write to PPU
				$LF
			]li
			[li 
				"Determine if it’s ‘n’ identical tiles, or different tiles. (Is Length >= 0x80?)
				$LF
				[ul 
					[li 
						"If identical tiles, read the next byte. Write ‘n’ bytes to the PPU.
						$LF
					]li
					[li 
						"If different tiles, read the next ‘n’ bytes, writing each one to the PPU.
						$LF
					]li
				]ul
			]li
			[li 
				"Loop
				$LF
			]li
		]ol
	]li
	[li 
		"Post-Graphics stuff
		$LF
		[ol 
			[li 
				"Set PPU Address to $2000 or $2400. This alternates which nametable is visible.
				$LF
			]li
			[li 
				"Enable rendering.
				$LF
			]li
		]ol
	]li
	[li 
		"Read the controller to set up the RaceConditionFix / leave the loop when the video ends.
		$LF
		[ul 
			[li 
				"If ‘A’ is pressed, JMP to $0181. This exits the “Bad Apple Loop”.
				$LF
			]li
			[li 
				"If ‘B’ is pressed, waste a single CPU cycle at the end of the loop
				$LF
			]li
		]ul
	]li
	[li 
		"Read the controller to determine the length of the payload
		$LF
		[ul 
			[li 
				"Determine which interlacing function to use
				$LF
			]li
		]ul
	]li
	[li 
		"Interlaced writes to the audio chip and zero page.
		$LF
	]li
	[li 
		"High quality audio until the frame ends
		$LF
	]li
	[li 
		"Prepare to wait for Vblank
		$LF
		[ul 
			[li 
				"If needed, BNE 0 bytes. Taking the branch uses an extra cycle.
				$LF
			]li
		]ul
	]li
]ol
[div class=p 
	"After setting this all up, I still have 414 unused bytes! I don’t know what else I could improve, so those bytes will just be left unused.
	$LF
]div
[div class=p 
	"After these changes, the video is now 25% larger, and the audio sounds even better!
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/7kjTCjw.png 
	]img
	$LF
]div
[div class=p 
	"That’s “Objective 3” of this TAS complete!
	$LF
]div
[h3 id=TangentOkayButWhatIfWeCouldImproveTheGraphicsAgain 
	"Tangent: Okay, but what if we could improve the graphics again?
	$LF
]h3
[div class= 
	[div class= 
		[ul class=nav nav-tabs role=tablist 
			[li class=nav-item 
				[a class=active nav-link data-bs-toggle=tab href=#tabs-54946-0 
					"Hide Tangent
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-54946-1 
					"Show Tangent
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-54946-2 
					"Bonus Tangent
				]a
			]li
		]ul
	]div
	[div class=tab-content 
		[div class=tab-pane fade active show id=tabs-54946-0 
		]div
		[div class=tab-pane fade id=tabs-54946-1 
			[div class=p 
				"The next step up in graphical quality would be to increase the resolution to 24 by 18 tiles. 
				$LF
			]div
			[div class=p 
				[img class=embed mw-100 src=https://i.imgur.com/zOvBFIB.png 
				]img
				$LF
			]div
			[div class=p 
				"I did some math a few paragraphs ago and determined there’s not enough time with the current system of packets to make all of those changes before VBlank ends. That being said, I am still just estimating that it won’t be enough time with the packet system. The estimate that there won’t be enough time is based on the one problematic frame when I was using 12 packets of 20 bytes. This would require 9 packets of 29 bytes. (If I’m including the write to the APU in these packets)
				$LF
			]div
			[div class=p 
				"As we’ve seen with previous examples, starting new packets takes up a lot of CPU cycles. If I’m using fewer packets, despite their larger size, is there enough time in VBlank to render it all? I opted to simply try and implement it rather than do some rough calculations. I want to be certain.
				$LF
			]div
			[div class=p 
				"Now that a single row can have up to 24 different tiles, I’m thinking about ways I could optimize the big list of “LDA <$00, X”, “INX”, “STA $2007”. After all, running that 24 times is 240 cycles. Here’s what I’m thinking:
				$LF
			]div
			[div class=p 
				"Remove the INX instructions. That’s 2 cycles each, adding up to 48 cycles if all 24 tiles need to be changed.
				$LF
			]div
			[div class=p 
				"The pattern can now be:
				$LF
			]div
			[pre 
				"	…
				$LF
				"	LDA <$03, X ; Offset from three
				$LF
				"	STA $2007
				$LF
				"	LDA <$02, X ; Offset from two
				$LF
				"	STA $2007
				$LF
				"	LDA <$01, X ; Offset from one
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X ; Offset from zero
				$LF
				"	STA $2007
				$LF
			]pre
			[div class=p 
				"Now an entire row of 24 tiles takes 192 cycles. This requires two changes to how the data is stored in the packets.
				$LF
			]div
			[div class=p 
				"Change 1: The data in the packets here is now written in reverse order. So 
				[code 
					"21 80 00 83 33 22 11 00
				]code
				" will write the bytes, 00, 11, 22, 33 in that order.
				$LF
			]div
			[div class=p 
				"Change 2: The X register will now need to be dramatically changed at the end of this sequence, somehow accounting for however many bytes were read. Since these bytes are already being read in reverse order, I’ll add that to be “index zero” in this list, so if the X register needs to be changed to, for example, 0x14, the previous packet would now look like this: 
				[code 
					"21 80 00 83 14 33 22 11 00
				]code
				$LF
			]div
			[div class=p 
				"This makes the means to update the X register now look like this:
				$LF
			]div
			[pre 
				"	LDA <$03, X 	; Offset from three
				$LF
				"	STA $2007
				$LF
				"	LDA <$02, X 	; Offset from two
				$LF
				"	STA $2007
				$LF
				"	LDA <$01, X 	; Offset from one
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X 	; Offset from zero
				$LF
				"	TAX 		; Fix the X register
				$LF
			]pre
			[div class=p 
				"Only 198 cycles for a stream of 24 bytes, when the previous code would’ve taken 240 cycles.
				$LF
			]div
			[div class=p 
				"The largest possible packet is now 30 bytes, and there’s up to 9 packets in a frame. I probably could have done some really quick math before taking the time to optimize that function, because even 29*9 is greater than 256. I don’t have enough space on the zero page to store this much information!
				$LF
			]div
			[div class=p 
				"Here’s the thing: If there are 9 packets (+ the terminator), I have enough time in Vblank to run 260 cycles per packet. So far, I’ve only accounted for the time spent after the jump to the huge list that writes to $2007, so let me add up the rest of the cycles in a packet. 57 cycles parsing through everything and jumping to the list, and 3 cycles to jump back to the beginning of the loop. 198 + 60 = 258 cycles, which is just barely under that 260 threshold I calculated.
				$LF
			]div
			[div class=p 
				"I was going to suggest manually writing “less optimal” packets that require fewer bytes for these frames, but there simply is not enough cycles to spare to let that happen.
				$LF
			]div
			[h4 
				"Alright then, the packet system doesn’t work here. Idea 2:
				$LF
			]h4
			[div class=p 
				"One idea I suggested was to replace the system of packets with an absolutely massive list of reading from the zero page and writing to the PPU. What if we’re only drawing 24 by 9 tiles in a single VBlank? That’s 219 bytes on the zero page (225 if you include the PCM data for the APU). Before we start seriously considering this option, let’s assume the PPU address pointers are magically updated each frame.
				$LF
			]div
			[div class=p 
				"Could this even work? Let’s do some math.
				$LF
			]div
			[div class=p 
				"The frame would begin with upwards of 5 cycles to exit the “spinning” loop. It would immediately begin to execute:
				$LF
			]div
			[pre 
				"	LDA #PPU_Address_Pointer_Lo	; this magically changes between frames
				$LF
				"	STA $2006
				$LF
				"	LDA #PPU_Address_Pointer_Hi	; this magically changes between frames
				$LF
				"	STA $2006
				$LF
				$LF
				"	LDA <$00	; Read byte 0
				$LF
				"	STA $2007	; Write to the PPU
				$LF
				"	LDA <$01	; Read byte 1
				$LF
				"	STA $2007	; Write to the PPU
				$LF
				"	LDA <$02	; Read byte 2
				$LF
				"	STA $2007	; Write to the PPU
				$LF
				"	LDA <$03	; …
				$LF
				"	STA $2007	; …
				$LF
				"	; - snip -
				$LF
				"	LDA <$14	; Read byte 20 (which is 0x14 in hexadecimal)
				$LF
				"	STA $2007	; That’s the 20th byte. The row is complete
				$LF
				$LF
				"	LDA <$15	; Read the next byte
				$LF
				"	STA $4011	; We still want audio data in this hypothetical code.
				$LF
				$LF
				"	LDA #PPU_Address_Pointer_Lo_2	; this magically changes between frames
				$LF
				"	STA $2006
				$LF
				"	LDA #PPU_Address_Pointer_Hi_2	; this magically changes between frames
				$LF
				"	STA $2006	; this updates the PPU address pointer so we can skip all the blank tiles between the end of the previous row and the start of the next one.
				$LF
				$LF
				"	LDA <$16	; Read the next byte
				$LF
				"	STA $2007	; Write to the PPU
				$LF
				"	LDA <$17	; …
				$LF
				"	STA $2007	; …
				$LF
				"	; - snip -	; and so on until we get through 9 rows
				$LF
				"	LDA <$E0	; Read the next byte
				$LF
				"	STA $2007	; The final PPU write
				$LF
				"	
				$LF
				"	LDA <$E1	; Read the next byte
				$LF
				"	STA $2007	; The final APU write
				$LF
			]pre
			[div class=p 
				[code 
					"(width+1)*(height/2)*(bytesPerLDA + bytesPerSTA) + (height/2)*(bytesPerLDA*2 + bytesPerSTA*2)
				]code
				[br 
				]br
				$LF
				[code 
					"25*9*5 + 9*10 = 1215 bytes}{
					$LF
				]code
			]div
			[div class=p 
				[code 
					"(width+1)*(height/2)*cyclesPerSTA2007 + (height/2)*cyclesPerSTA2006
				]code
				[br 
				]br
				$LF
				[code 
					"25*9*7 + 10*12 = 1683 cycles
				]code
				$LF
			]div
			[div class=p 
				"Let’s see… This ASM code would take 1215 bytes of RAM, and it would take 1683 cycles to execute. Wait… Vblank is 2387 CPU cycles long. There’s an insane amount of cycles left
				$LF
				"Over. Before I dare consider a 28 by 21 resolution, let’s see if there’s enough time in a frame to write 225 bytes to the zero page with decent audio quality.
				$LF
			]div
			[div class=p 
				"This method would no longer need the dynamic audio interlacing functions that were written for the previous method, since every frame would require the exact same amount of bytes for the zero page. 
				$LF
			]div
			[div class=p 
				"The controller read to prevent the $2002 race condition must still occur, but we don’t need to check for the length, since it will always be 225. This brings us to:
				$LF
			]div
			[pre 
				"5	; Exiting the loop that waits for vblank
				$LF
				"+1683	; Updating the nametable
				$LF
				"+30	; Update the PPU address before the screen starts being drawn (this also checks for which nametable to draw for this frame)
				$LF
				"+33	; Read only 2 bits from the controller. This is to prevent the race condition.
				$LF
				"= 1751
				$LF
			]pre
			[div class=p 
				"This loop writing to the zero page / APU will begin 1751 cycles after the start of the frame. If it takes 129 cycles each loop, and a frame only has 29780.5 cycles, is there enough time to write 225 bytes? 
				$LF
			]div
			[div class=p 
				[code 
					"(29780-1751) - (129*225) = -996
				]code
				$LF
			]div
			[div class=p 
				"Nope! In order to render the video at 24 by 18 tiles, I would need to make massive audio sacrifices. It’s remarkably close though. Granted, this code still doesn't change the PPU Address pointers that are currently changing by "magic".
				$LF
			]div
			[h4 
				"What if I unroll the loop that interlaces APU writes and ZP writes as much as possible?
				$LF
			]h4
			[div class=p 
				"Instead of:
				$LF
			]div
			[ol 
				[li 
					"Write to zero page
					$LF
				]li
				[li 
					"Write to APU
					$LF
				]li
				[li 
					"Branch back
					$LF
				]li
			]ol
			[div class=p 
				"It would be like:
				$LF
			]div
			[ol 
				[li 
					"Write to zero page
					$LF
				]li
				[li 
					"Write to APU
					$LF
				]li
				[li 
					"Write to zero page
					$LF
				]li
				[li 
					"Write to APU
					$LF
				]li
				[li 
					"Write to zero page
					$LF
				]li
				[li 
					"Write to APU
					$LF
				]li
				[li 
					"Write to zero page
					$LF
				]li
				[li 
					"Write to APU
					$LF
				]li
				[li 
					"Branch back
					$LF
				]li
			]ol
			[div class=p 
				"And repeat that as much as possible without branching. This saves at most 50 cycles, which is nowhere near enough.
				$LF
			]div
			[h4 
				"What if I remove the writes to the APU during VBlank? 
				$LF
			]h4
			[div class=p 
				"This reduces both cycles spent inside VBlank and the required bytes written to the zero page.
				$LF
				"After these changes there’s a few hundred CPU cycles left over, but this doesn’t even account for the magic code that would need to update the PPU address pointers that are used during VBlank.
				$LF
			]div
			[div class=p 
				"To put it bluntly, there’s not going to be a way to make the resolution any larger without completely ruining the audio.
				$LF
			]div
			[div class=p 
				"Therefore, the TAS shall remain at 20 by 15 tiles!
				$LF
			]div
		]div
		[div class=tab-pane fade id=tabs-54946-2 
			[h3 
				"Bonus Tangent: If I were to remove all audio, what’s the largest resolution possible at 30FPS?
				$LF
			]h3
			[div class=p 
				"Let’s take the ridiculous idea from the previous section to its logical extreme. First off, could we get the full 32 by 24 tiles? (Remember, the video is at a 4:3 aspect ratio)
				$LF
			]div
			[div class=p 
				"The PPU Address no longer needs to be updated between rows, since there are now zero bytes between rows. We're looking at a series of "LDA Zero Page" (2 bytes) and "STA $2007" (3 bytes). We're updating half of the 32*24 in one VBlank, so that would be (2+3)*32*12 = 1920.
				$LF
			]div
			[div class=p 
				"It would take 1920 bytes, and 2688 cycles to execute! Well, that’s how much it would be in some fantasy land wherein the zero page could be extended to 384 bytes. Since that’s not the case, many of those two-byte LDA instructions (taking 3 cycles) become three-byte instructions (taking 4 cycles). By making these adjustments, we’re now looking at exactly 2048 bytes. That's exactly the entirety of RAM. No room to read the controller, and no room for the 384 bytes needed to update the nametables. Worse yet, it would take longer than all the available time in Vblank to execute.
				$LF
			]div
			[h4 
				" What if I use "STA Indirect, Y" instructions to save space?
				$LF
			]h4
			[div class=p 
				"By sacrificing 2 bytes on the zero page, You could have a pointer to address  $2007. Now the 3 byte STA instructions can be written as 2 bytes, at the cost of more CPU cycles. (I know this is already over the CPU cycle budget for this Vblank, but let's humor the idea for a bit)
				$LF
			]div
			[div class=p 
				"Before, the entirety of RAM was filled with:
				$LF
			]div
			[pre 
				"LDA <$00	; 2 bytes
				$LF
				"STA $2007	; 3 bytes
				$LF
				"LDA <$01	; 2 bytes
				$LF
				"STA $2007	; 3 bytes
				$LF
				"; ...
				$LF
			]pre
			[div class=p 
				"It could be replaced with
				$LF
			]div
			[pre 
				"LDA <$00	; 2 bytes
				$LF
				"STA ($FE),Y	; 2 bytes
				$LF
				"LDA <$01	; 2 bytes
				$LF
				"STA ($FE),Y	; 2 bytes
				$LF
				"; ...
				$LF
			]pre
			[div class=p 
				"This brings the total byte count for our code down to 1666 bytes, taking 3202 cycles. We need 384 bytes of data, and 2 bytes for that pointer to address $2007, which brings the total to 2052 bytes. Ooh! So close. There's still no room for code that can read the controller to write all this data though.
				$LF
			]div
			[div class=p 
				"At the cost of even more CPU cycles, we could write a loop for all the non-zero page bytes. Of course, we were unrolling this for a reason, but there's no reasonable way to save around 850 cycles here.
				$LF
			]div
			[h4 
				" What about updating graphics in HBlank?
				$LF
			]h4
			[div class=p 
				"So, Horizontal blank contains about 20 CPU cycles where the PPU Address isn't used/updated. Ideally, you would change the PPU address, write something, then change it back to what it needs to be for the next scanline.
				$LF
			]div
			[pre 
				"LDA #$21
				$LF
				"LDX #$80
				$LF
				"LDY #$11
				$LF
				"; HBlank begins
				$LF
				"STA $2006 ; 4 cycles in
				$LF
				"STX $2006 ; 8 cycles in
				$LF
				"STY $2007 ; 12 cycles in
				$LF
				"; Now we need to set the PPU address to whatever it needs to be for the next scanline
				$LF
				"LDA #$23 ; 14 cycles in
				$LF
				"STA $2006 ; 18 cycles in
				$LF
				"LDA #$E0 ; 20 cycles in... uh oh
				$LF
				"; The PPU has begun reading from the VRAM to prepare the first tiles of the next scanline
				$LF
				"STA $2006 ; 24 cycles, too late!  
				$LF
			]pre
			[div class=p 
				"So that's not happening.
				$LF
			]div
			[div class=p 
				"Anyway, let's try and answer the question posed by this tangent, and drop the resolution.
				$LF
			]div
			[h4 
				" How about 28 by 21?
				$LF
			]h4
			[div class=p 
				"336 bytes of data, so again, we're going to need to use more space than the zero page has to offer. Let's use STA Absolute instead of those indirect instructions. We need those CPU cycles.
				$LF
			]div
			[div class=p 
				"(width*height*ZPInstructions) + (width*remainingHeight*AbsoluteInstructions) = 28*9*5 + 28*3*6 = 1764 bytes (+336 bytes of data = 2100) , taking 2436 cycles. Also, we'll need to move the PPU address between rows here, and seeing how this is already unrealistic without that addition, let's move on.
				$LF
			]div
			[h4 
				" So it's 24 by 18?
				$LF
			]h4
			[div class=p 
				"We already confirmed it was possible to do this, at the cost of audio quality, but let's just re check the math. This example will omit the audio data from the packets.
				$LF
			]div
			[div class=p 
				"24*9 < 256, so this can all fit inside the zero page.
				$LF
			]div
			[div class=p 
				"LDA Zero Page and STA Absolute take a total of 5 bytes and 7 CPU cycles.
				$LF
			]div
			[div class=p 
				"For each row, the PPU address needs to be moved, which takes 10 bytes and 12 CPU cycles.
				$LF
			]div
			[div class=p 
				"24*9*5 + 9*10 = 1170 bytes.
				[br 
				]br
				$LF
				"24*9*7 + 9*12 = 1620 cycles.
				$LF
			]div
			[div class=p 
				"this is comfortably within Vblank. It looks like this might be the best resolution possible for a 4:3 video played in SMB at 30 FPS.
				$LF
			]div
			[div class=p 
				"Finding a way to render 30FPS 32x24 tile videos in Super Mario Bros. has been left as an exercise for the reader.
				$LF
			]div
			[h4 
				" A reader did the exercise.
				$LF
			]h4
			[div class=p 
				"A user in the youtube comment section named Lorenz17 suggested replacing the LDA Zero Page and LDA Absolute instructions with LDA Immediate, which would save both bytes and cycles. This would take 1920 bytes (which is less than 2048) and 2304 CPU cycles (which is less than 2387), making it all fit! One small issue is this would take 1920 bytes, leaving us with only 128 for all remaining code. 62 of these bytes are the initial code-writing payload, so we're down to 66 remaining bytes in RAM
				$LF
			]div
			[div class=p 
				"I decided to take this challenge anyway, and see what I could do with this space.
				$LF
			]div
			[pre 
				"AddressZero:
				$LF
				"	<Prevent2002>		
				$LF
				"	<WriteLo>
				$LF
				"	<WriteHi>	
				$LF
				"	<FrameCount>	;-4 bytes of available space
				$LF
				"Nametabler:
				$LF
				"	LDA #<PPUHi>
				$LF
				"	STA $2006
				$LF
				"	LDA #<PPULo>
				$LF
				"	STA $2006	
				$LF
				"	 
				$LF
				"	LDA #<Byte1>
				$LF
				"	STA $2007
				$LF
				"	LDA #<Byte2>
				$LF
				"	STA $2007
				$LF
				"	; ...
				$LF
				"	; snip ; This would be the 1920 bytes for updating the nametables.
				$LF
				$LF
				"	; We have about 70 CPU cycles before VBlank ends.
				$LF
				"	; Update the PPU address to look at the correct nametable
				$LF
				"	LDX #20				; 2 bytes
				$LF
				"	INC <FrameCount		 	; +2 = 4
				$LF
				"	LDA <FrameCount			; +2 = 6 
				$LF
				"	AND #1				; +2 = 8 
				$LF
				"	BEQ Use20			; +2 = 10
				$LF
				"	LDX #24				; +2 = 12
				$LF
				"Use20:
				$LF
				"	STX $2006			; +3 = 15
				$LF
				"	STY $2006			; +3 = 18 		; (Y=0)
				$LF
				$LF
				"	; Set up data writing pointer
				$LF
				"	STY <WriteLo			; +2 = 20		;  It begins by overwriting "Prevent2002". 5 bytes later is PPUHi
				$LF
				"	STY <WriteHi			; +2 = 22  		;  5 more bytes is PPULo, then 5 more is Byte1 and so on.
				$LF
				$LF
				"Controller:
				$LF
				"	LDA #1				; +2 = 24
				$LF
				"	STA $4016			; +3 = 27
				$LF
				"	LSR A				; +1 = 28
				$LF
				"	STA $4016			; +3 = 31
				$LF
				"	LDX #8				; +2 = 33
				$LF
				"Loop:
				$LF
				"	EOR $4016			; +3 = 36
				$LF
				"	DEX				; +1 = 37
				$LF
				"	BNE Loop			; +2 = 39
				$LF
				"	EOR #C0				; +2 = 41
				$LF
				$LF
				"	BEQ PostLoop			; +2 = 43		; never draw tile 0 to the nametable
				$LF
				"								; instead, use zero to exit the controller reading loop.
				$LF
				"								; store at the "write pointer" then update it
				$LF
				"	STA (WriteLo),Y			; +2 = 45
				$LF
				"	LDA <WriteLo			; +2 = 47
				$LF
				"	CLC				; +1 = 49	
				$LF
				"	ADC #5				; +2 = 50		; Move the pointer 5 bytes
				$LF
				"	STA <WriteLo			; +2 = 52
				$LF
				"	TYA				; +1 = 53		; (Y=0)
				$LF
				"	ADC #0				; +2 = 55		; Update the high byte if needed.
				$LF
				"	STA <WriteHi			; +2 = 57
				$LF
				"	BPL Controller			; +2 = 59		; always branch
				$LF
				$LF
				"PostLoop:
				$LF
				"	LDA <Prevent2002		; +2 = 61
				$LF
				"	BNE #0				; +2 = 63
				$LF
				"	CMP #$FF			; +2 = 65
				$LF
				"	BNE Wait4VBlank:		; +2 = 67
				$LF
				" 	JMP TotalControl: 	 	; +3 = 70
				$LF
				$LF
				"Wait4VBlank:
				$LF
				"	LDA $2002			; +3 = 73
				$LF
				"	BPl Wait4Vblank			; +2 = 75
				$LF
				"	JMP Nametabler			; +3 = 78 		; 12 bytes over budget! (and 4 more bytes at address $0000)
				$LF
			]pre
			[div class=p 
				"Oh no! I used 16 too many bytes! Luckily, I have an ace up my sleeve. 18 bytes from the initial code-writing payload could be removed, then once I finally jump back to the code writing routine, I could simply use it to re-complete the payload!
				$LF
			]div
			[div class=p 
				"As for actually testing this code, I ran into new fun issues. Recall when I said that overwriting all of RAM would require some finesse to overwrite the code-writing loop? I'm able to write a copy of it elsewhere and execute that, but it uses the stack. If I'm overwriting the entire stack, there's going to be bytes inside the stack that are being updated by the JSR instruction.
				$LF
			]div
			[div class=p 
				"Never mind that- let's imagine we were actually able to set this code up and run it. How many cycles would it take to overwrite the operands for all 384 LDA instructions? This controller reading + pointer updating loop will take 115 cycles each iteration. To make a long story short, there's not enough time in the rest of the frame to update all those with this code. 
				[code 
					"115*384 > (29780 - 2304)
				]code
				$LF
			]div
			[div class=p 
				"It might still be possible, but once again, It's an excercise for the reader.
				$LF
			]div
		]div
	]div
]div
[h2 id=HowTheTasEnds 
	"How the TAS ends
	$LF
]h2
[div class=p 
	"I did it! The entire Bad Apple music video is played at the best possible audio and video quality I could manage. What happens next? To make the TAS have a nice ending, It should return the game to a stable state. Recall that the controller read that is used to prevent the $2002 race condition is also used to check if the video has ended, in which case it will run JMP $0181, taking the PC back to the original total control code writing loop. Some new code is written to spoof the level transition screen, set the nametable to mimic the end of 8-4, then almost every byte in RAM is modified to be a copy of RAM from a state where mario is about to land on the axe in 8-4. Some bytes were specifically modified to set mario’s position, the score, etc. (I modify Mario’s score to be the maxout of “9999990”, satisfying “Objective 4”.) Once RAM is all set up, the NMI is enabled and the PC jumps to where SMB waits for the next frame.
	$LF
]div
[div class=p 
	"When the next frame runs, it’s almost as if nothing had happened at all! Mario gracefully falls to the axe, defeating Bowser and saving the princess. Mario touches the axe with a time of 4:53.78  (17656 frames) since the console boot. (Including the time spent inside Super Mario Bros. 3 setting up the RAM pre-cart-swap) This satisfies the final objective of this TAS!
	$LF
]div
[h2 id=FunDetailsAboutTheCreationOfThisTas 
	"Fun details about the creation of this TAS
	$LF
]h2
[div class=p 
	"Since my ASM code cannot be compiled, I had to manually convert it into bytes and place those bytes on the TAStudio timeline. To optimize this process, I wrote a program to turn a string of bytes into TAStudio’s input string format. Some smaller modifications to the code were simply done by modifying the inputs on the timeline. Changes to the code were made frequently while experimenting with the audio, which could occasionally make a perfectly fine branch instruction cross a page boundary, (every time the branch is taken, it costs 1 extra CPU cycle) throwing off my calculations for how many inputs I could fit before the end of a frame. Remember, all 5.8 million inputs of this TAS were generated by a program I wrote, which means I had to know exactly how many cycles I had to spare before exiting the audio loop, jumping to the “wait for VBlank” loop.
	$LF
]div
[div class=p 
	"Since I cannot use the NMI to wait for a new frame, I need to rely on reading address $2002 to check for VBlank, which can occasionally yield a false negative. Bit 7 should be set to 1 if VBlank has begun, and reading from this address will automatically clear bit 7. There exists a PPU cycle specific window where when this address is read, bit 7 is not set (for V-Blank has not begun), VBlank then begins, and after reading from this address bit 7 is cleared. To work around this, every frame will spend a single controller read (either 0 or 1) and if “1” is read, I waste a single CPU cycle by branching 0 bytes. Since the branch is taken, a single CPU cycle is spent moving the PC zero bytes, which will make the read instruction happen on a different PPU cycle, thus preventing the race condition.
	$LF
]div
[div class=p 
	"I got to learn about how the .wav file format works during the creation of this TAS, so I could convert the 16 Bit PCM data of a .wav file to 7 Bit data for the audio chip. I’ve also recently learned about the inner workings of the .gif format, and I’m enjoying learning about how file formats store their data.
	$LF
]div
[div class=p 
	"While submitting this TAS, I ran into an issue, as the file size was larger than the maximum allowed size. By a pretty hefty amount too. The .bk2 file was 15 Megabytes, and there's a 2 Mb limit. With the help of 7z, I could get it down to 8.3 Mb, which is still not nearly enough. Spikestuff was able to help me compress it into a 5.6 Mb file, though it uses a compression method that bizhawk is unable to parse.
	$LF
]div
[h2 id=Conclusion 
	"Conclusion
	$LF
]h2
[div class=p 
	"This is without hyperbole my entire knowledge about the NES. 6502 Assembly, unofficial opcodes, ASM optimizations, controller reading, the audio chip, PCM audio, writing to the nametables, color palettes, attribute tables, open bus, uninitialized ram, cartridge swapping, The Address $2002 Vblank-Race-Condition, how many bytes and CPU cycles each instruction takes, Hblank, and more! It all comes together to form a music video being played inside an unmodified cartridge of Super Mario Bros.
	$LF
]div
[div class=p 
	"I’m curious to know if a video using all 4 color palettes could be achieved. My process for optimally converting an image into “mario tiles” was easy, since I was working with greyscale images. It’s an entirely different beast if I need to consider all the possible colors, and how the attribute tables would assign palettes. That’s definitely worth exploring. 
	$LF
]div
[div class=p 
	"This website makes me do silly things.
	$LF
]div
[div class=p 
	"Suggested screenshot (Frame 1,502,323 / Vblank 7768)
	$LF
]div
[div class=p 
	[img class=embed mw-100 src=https://i.imgur.com/aLQ9yYm.png 
	]img
	$LF
]div
[h2 id=SpecialThanks 
	"Special Thanks:
	$LF
]h2
[div class=p 
	"The NESdev wiki for its outstanding documentation of the NES.
	[br 
	]br
	$LF
	"Total for informing me of the extra fast controller reading with EOR.
	[br 
	]br
	$LF
	"Alyosha and Bigbass for their help last April replaying my SMB1 ACE proof of concept TAS on console and helping me discover the open bus inaccuracies inside Bizhawk pre-version-2.9
	[br 
	]br
	$LF
	"DwangoAC for help console verifying this TAS, and his incredible patience as we ran into wall after wall debugging. We weren't able to play much of the video before desyncing, but the time spent working on this is greatly appreciated!
	[br 
	]br
	$LF
	"Bigbass again for additional help with console verification, and his incredible patience as we also ran into many walls debugging. We were able to get around 10 seconds in before something desynced, which, all things considered (using $2002 to check for VBlank, which is PPU cycle dependant) was amazing!
	[br 
	]br
	$LF
	"Spikestuff and CasualPokePlayer for help compressing this massive TAS to allow it to be uploaded.
	[br 
	]br
	$LF
	"negative_seven for her research into SMB1 ACE, which helped during my own investigations.
	[br 
	]br
	$LF
	"Alyosha again for 
	[a href=https://www.youtube.com/watch?v=OJXxmD_Qk2o rel=noopener external nofollow 
		"console verifying this TAS!
	]a
	".
	$LF
]div
[h2 id=HereSTheAsmCode 
	"Here’s the ASM code:
	$LF
]h2
[div class= 
	[div class= 
		[ul class=nav nav-tabs role=tablist 
			[li class=nav-item 
				[a class=active nav-link data-bs-toggle=tab href=#tabs-77156-0 
					"Hide Code
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-77156-1 
					"Initial Payload
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-77156-2 
					"Setup
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-77156-3 
					"Bad Apple Loop
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-77156-4 
					"Post-Video
				]a
			]li
		]ul
	]div
	[div class=tab-content 
		[div class=tab-pane fade active show id=tabs-77156-0 
		]div
		[div class=tab-pane fade id=tabs-77156-1 
			[div class=p 
				"This was written before cartidge swapping to Super Mario Bros.
				$LF
			]div
			[div class=p 
				"It can be written with a subframe TAS of SMB3 in 47 frames.
				$LF
			]div
			[div class=p 
				"Initial payload: (This let’s me write more ASM code in RAM)
				$LF
			]div
			[pre 
				"			; $16B, The controller reading loop. 
				$LF
				"ReadController:
				$LF
				"	LDA #$01
				$LF
				"	STA $4016	; Strobe the controller
				$LF
				"	STA <$C0
				$LF
				"	LSR A
				$LF
				"	STA $4016	; Strobe the controller part 2
				$LF
				"Read4016:
				$LF
				"	LDA $4016
				$LF
				"	LSR A
				$LF
				"	ROL <$C0	; This isn’t the most optimal controller reading routine
				$LF
				"	BCC Read4016    ; But it takes up fewer bytes, which is important here.
				$LF
				"	LDA <$C0
				$LF
				"	RTS		; This specific part is a subroutine.
				$LF
				$LF
				"Setup:			; $181
				$LF
				"	LDX #$02	; this is the first line executed when the ACE begins. X=2
				$LF
				"Loop1:
				$LF
				"	JSR $016B	; Read the controller
				$LF
				"	STA <$C1, X	; Store at C3, C2, and C1. That’s the 16 bit pointer and payload length.
				$LF
				"	DEX		; X--
				$LF
				"	BPL Loop1	; Loop unless X is 0xFF
				$LF
				"	LDY #$00	; Y=0
				$LF
				"Loop2:
				$LF
				"	JSR $016B	; Read controller
				$LF
				"	STA ($C2), Y	; Store at the target address with offset Y.
				$LF
				"	INY		; Y++
				$LF
				"	CPY <$C1	; If Y < Payload Length
				$LF
				"	BCC Loop2	; Loop. This will loop until the payload is finished.
				$LF
				"			; Post loop:
				$LF
				"	JSR $016B	; Read controller. Do we write more code, or jump somewhere?
				$LF
				"	BEQ Setup	; If zero, we got more code to write. Branch back to $181, the setup.
				$LF
				$LF
				"	JSR $016B	; Read controller. Let’s figure out where we’re jumping
				$LF
				"	STA <$C3	; Store at $C3 (The high byte)
				$LF
				"	JSR $016B	; Read controller
				$LF
				"	STA <$C2	; Store at $C2 (The low byte)
				$LF
				"	JMP ($00C2)	; This indirect jump goes wherever we just pointed.
				$LF
			]pre
		]div
		[div class=tab-pane fade id=tabs-77156-2 
			[div class=p 
				"The setup code: (Clear the nametable, set up the color palette, halt audio, etc.)
				$LF
			]div
			[pre 
				"			; I wrote this at address $300
				$LF
				"BadAppleSetup:
				$LF
				"	LDA #$00	; A=0, This will be used to silence the APU
				$LF
				"	TAX		; X=0
				$LF
				"APULoop:
				$LF
				"	STA $4000, X	; Store 0 at the APU register
				$LF
				"	INX		; X++
				$LF
				"	CPX #$10	; If X!=0x10
				$LF
				"	BNE APULoop	; Loop.
				$LF
				$LF
				"	STX $400C	; I also want to write 0x10 to address $400C
				$LF
				"	STA $2005	; Set the fine scroll X. A still equals 0.
				$LF
				"	STA $2005	; Sets fine scroll Y. This step gets overwritten by writing to $2006, oops!
				$LF
				"VBLoop:
				$LF
				"	LDA $2002	; Wait for Vblank
				$LF
				"	BPL VBLoop	; Loop
				$LF
				$LF
				"	LDA #$00	; A=0
				$LF
				"	STA $2001	; Disable rendering
				$LF
				"	LDA #$10	; A=10
				$LF
				"	STA $2000	; Set PPU Address increment mode.
				$LF
				"	LDA #$20	; Set up PPU Read/Write Address
				$LF
				"	STA $2006	; High byte is 0x20
				$LF
				"	LDA #$00	; Low byte is 0x00
				$LF
				"	STA $2006	; Address set to $2000
				$LF
				"NTLoop:
				$LF
				"	LDA #$27	; A = 0x27. This represents a blank tile
				$LF
				"	LDX #$00	; X=0
				$LF
				"	LDY #$04	; Y=4
				$LF
				"	STA $2007	; Write 0x400 bytes to $2000
				$LF
				"	DEX		; X--
				$LF
				"	BNE NTLoop	; if X != 0, loop
				$LF
				"	DEY		; Y--
				$LF
				"	BNE NTLoop	; if Y != 0, loop
				$LF
				$LF
				"	LDA #$23	; Set up PPU Address to $23C0
				$LF
				"	STA $2006	; This is the attribute table.
				$LF
				"	LDA #$C0	; We want the attribute table to be all zeroes.
				$LF
				"	STA $2006	; PPU Address = $23C0
				$LF
				"	LDA #$00	; A=0
				$LF
				"	LDX #$40	; X=0x40
				$LF
				"ATLoop:	
				$LF
				"	STA $2007	; Write to attribute table
				$LF
				"	DEX		; X--
				$LF
				"	BNE ATLoop	; If X != 0, loop
				$LF
				"	LDA #$24	; We need to clear a second name table.
				$LF
				"	STA $2006	; This is pretty much the same code as before
				$LF
				"	LDA #$00	; but using different PPU addresses.
				$LF
				"	STA $2006	; PPU Address = $2400
				$LF
				"	LDA #$27	; A=0x27, the blank tile.
				$LF
				"	LDX #$00	; X=0;
				$LF
				"	LDY #$04	; Y=4;
				$LF
				"NTLoop2:
				$LF
				"	STA $2007	; Write to nametable
				$LF
				"	DEX		; X--
				$LF
				"	BNE NTLoop2	; if X != 0, loop.
				$LF
				"	DEY		; Y--
				$LF
				"	BNE NTLoop2	; if Y != 0, loop
				$LF
				$LF
				"	STA $2006	; And the attribute table. A is already 27, which was the tile ID.
				$LF
				"	LDA #$C0	; Remarkably, I’m setting up the address to $27C0
				$LF
				"	STA $2006	; So I didn’t need to change A for the first write to $2006.
				$LF
				"	LDA #$00	; A = 0
				$LF
				"	LDX #$40	; X= 0x40
				$LF
				"ATLoop2:
				$LF
				"	STA $2007	; Write to attribute table
				$LF
				"	DEX		; X--
				$LF
				"	BNE ATLoop2	; if X != 0, loop
				$LF
				$LF
				"VBLoop2:
				$LF
				"	LDA $2002	; Wait for Vblank. I’ll change the background color while rendering is disabled.
				$LF
				"	BPL VBLoop2	; If not VBlank, loop. This would have a visible artifact if outside Vblank.
				$LF
				$LF
				"	LDA #$3F	; Palette stuff.
				$LF
				"	STA $2006	; Set up PPU Address to $3F00
				$LF
				"	LDA #$00	; We’re only going to change a single palette
				$LF
				"	STA $2006	; The PPU Address is all set up.
				$LF
				"	LDA #$30	; Color $30, white
				$LF
				"	STA $2007	; Write to palettes
				$LF
				"	LDA #$10	; Color $10, light grey
				$LF
				"	STA $2007	; Write to palettes
				$LF
				"	LDA #$00	; Color $00, grey
				$LF
				"	STA $2007	; Write to palettes
				$LF
				"	LDA #$0F	; Color $0F, black
				$LF
				"	STA $2007	; Write to palettes
				$LF
				"	LDA #$0E	; Enable rendering
				$LF
				"	STA $2001	; This is still in VBlank, so it’s okay to do things in this order.
				$LF
				"	LDA #$20	; Set up PPU Address to $2000
				$LF
				"	STA $2006	; This is used for rendering the screen with $2000 in the upper left.
				$LF
				"	LDA #$00	; Right now, the entire screen will be blank.
				$LF
				"	STA $2006	; Final write to $2006 in the setup.
				$LF
				"	JMP $0181	; Jump back to the initial payload. We have more to write.
				$LF
			]pre
		]div
		[div class=tab-pane fade id=tabs-77156-3 
			[div class=p 
				"The Bad Apple Loop:
				$LF
			]div
			[pre 
				" 	 		; I wrote this at address $300
				$LF
				"Top:
				$LF
				"	LDA $100	; Load from Address $100. If non-zero, waste a single CPU cycle.
				$LF
				"	BNE #00		; Branch 0 bytes. If taken, it costs 1 extra cycle.
				$LF
				"VBLoop:
				$LF
				"	LDA $2002	; Wasting 1 cycle can be used to prevent the false-negative read.
				$LF
				"	BPL VBLoop	; Wait for Vblank.
				$LF
				"	LDA #$00	; A=0
				$LF
				"	STA $2001	; Disable rendering
				$LF
				"Main:			; This loop is at address $30F.
				$LF
				"	LDA <$00, X	; Read the first byte of a packet. The first time this runs, X = 0.
				$LF
				"	BMI Terminator	; If A == 0xFF, we exit this graphical loop, “Main”.
				$LF
				"	BEQ NoPPU	; if A == 0, We don’t change the PPU read/write address.
				$LF
				"	STA $2006	; We are changing the read/write address. Store the packet’s first byte.
				$LF
				"	INX		; X++
				$LF
				"	LDA <$00, X	; Read the next byte of the packet.
				$LF
				"	STA $2006	; Also store this one to address $2006. The PPU address is set up.
				$LF
				"NoPPU:
				$LF
				"	INX		; X++
				$LF
				"	LDA <$00, X	; Read the next byte. This will be PCM data for the audio chip.
				$LF
				"	STA $4011	; Store it at $4011, writing to the audio chip.
				$LF
				"	INX		; X++
				$LF
				"	LDY <$00, X	; Read the next byte (length) into the Y register.
				$LF
				"	BMI Indies	; If the length is >= 0x80, it’s a group of individual tiles.
				$LF
				"	INX		; otherwise, X++
				$LF
				"	LDA $0740, Y	; There’s a LookUp Table at $740, grab the right byte
				$LF
				"	STA $0101	; Store at $101 (Address 102 = 0x07, so this will always point somewhere in page 7)
				$LF
				"	LDA <$00, X	; Read the next byte (what tile to draw multiple times)
				$LF
				"	JMP ($0101)	; Jump to a huge chain of “STA $2007” over and over.
				$LF
				$LF
				"Indies:
				$LF
				"	INX		; X++
				$LF
				"	LDA $074F, Y	; There’s a LookUp Table at $7CF. LDA from $74F, since bit 7 of Y is set, adding 0x80.
				$LF
				"	STA $0101	; Store at $101 (Address 102 = 0x07, so this will always point somewhere in page 7)
				$LF
				"	JMP ($0101)	; Jump to a huge chain of “STA $2007, INX, LDA <00,X” over and over.
				$LF
				$LF
				"	NOP		; I modified the code here, but I kept the length the same. This NOP never runs.
				$LF
				$LF
				"Terminator:		; If the first byte of a packet is 0xFF, it branches here.
				$LF
				"	INC $0103	; Increment Address $103
				$LF
				"	LDA $0103	; Address $103 is used to track which nametable the screen is looking at.
				$LF
				"	AND #$03	; Only look at bits 0 and 1.
				$LF
				"	TAX		; X = bits 0 and 1 of $103.
				$LF
				"	LDA #$20	; A = 20
				$LF
				"	CPX #$02	; if X < 2
				$LF
				"	BMI Use20	; Branch, and write 0x20 to Address $2006
				$LF
				"	ORA #$04	; Otherwise, we’re writing 0x24 there.
				$LF
				"Use20:
				$LF
				"	STA $2006	; Store 0x20 or 0x24 to $2006.
				$LF
				"	LDA #$00	; A=0
				$LF
				"	STA $2006	; Store 0 to $2006. The PPU Address is now either $2000 or $2400
				$LF
				"	NOP		; I used to have a different system for swapping the nametable.
				$LF
				"	NOP		; I replaced it with this code, which is more optimal, and took fewer bytes.
				$LF
				"	NOP		; I didn’t want to figure out where all those LookUp Tables would end up.
				$LF
				"	NOP		; I’m not actually compiling this code, so moving pointers is a pain.
				$LF
				"	NOP		; More importantly though, the audio playing loop would cross a page boundary.
				$LF
				"	NOP		; Then it would take 1 extra cycle each loop, breaking a lot of my math.
				$LF
				"	LDA #$0E	; Anyway, A = 0x0E
				$LF
				"	STA $2001	; Enable rendering.
				$LF
				"	LDA #$01	; A=1
				$LF
				"	STA $4016	; Strobe controllers
				$LF
				"	LSR A		; A=0
				$LF
				"	STA $4016	; Strobe controllers part 2
				$LF
				"	LDA $4016	; Read from controller port.
				$LF
				"	ASL A		; Shift the bits
				$LF
				"	EOR $4016	; EOR next bit for controller
				$LF
				"	AND #$0F	; We only want bits 0 and 1 here.
				$LF
				"	STA $0100	; Store this at address $100. This is used to waste a single cycle before Vblank.
				$LF
				"	CMP #$02	; This is also used to exit the loop, if A = 2.
				$LF
				"	BNE SkipJMP	; If A != 2, branch ahead 3 bytes
				$LF
				"	JMP $0181	; Jump out of the Bad Apple Loop, back to the total control loop.
				$LF
				$LF
				"SkipJMP:
				$LF
				"	LDA #$01	; A=1
				$LF
				"	STA $4016	; Strobe controllers
				$LF
				"	LSR A		; A=0
				$LF
				"	STA $4016	; Strobe controllers part 2
				$LF
				"	EOR $4016	; Very fast controller reading with EOR
				$LF
				"	ASL A		; Shift bits
				$LF
				"	EOR $4016	; Read from controller
				$LF
				"	ASL A		; Shift bits
				$LF
				"	EOR $4016	; Read from controller
				$LF
				"	ASL A		; Shift bits
				$LF
				"	EOR $4016	; Read from controller
				$LF
				"	ASL A		; Shift bits
				$LF
				"	EOR $4016	; Read from controller
				$LF
				"	ASL A		; Shift bits
				$LF
				"	EOR $4016	; Read from controller
				$LF
				"	ASL A		; Shift bits
				$LF
				"	EOR $4016	; Read from controller
				$LF
				"	ASL A		; Shift bits
				$LF
				"	EOR $4016	; Read from controller
				$LF
				"	EOR #$C0	; Exclusive or with 0xC0 to flip those bits that were affected by open bus.
				$LF
				"	TAX		; X = the data read from the controller. That’s the length of data for the zero page.
				$LF
				"	LDY #$00	; Y = 0
				$LF
				"	CMP #$91	; If the Data Length >= 0x91
				$LF
				"	BCS IMode1	; Branch so Y isn’t incremented at all. This will jump to “Interlace Mode 1”.
				$LF
				"	CMP #$6E	; if the Data Length >= 0x6E
				$LF
				"	BCS IMode2	; Branch to set Y up for a jump to “Interlace Mode 2”		
				$LF
				"	CMP #$59	; If the Data Length >= 0x59
				$LF
				"	BCS IMode3	; Branch to set Y up for a jump to “Interlace Mode 3”	
				$LF
				"	INY		; Otherwise, Y is set up for “Interlace Mode 4”.
				$LF
				"	INY		; The “Interlace Modes” will write ‘n’ bytes to the APU, 1 byte to the zero page.
				$LF
				"IMode3:		 	; This is how I have dynamic audio quality based on the number of ZP writes.
				$LF
				"	INY		; The more bytes required for the zero page, the fewer writes to the audio chip.
				$LF
				"	INY		; Those magic numbers used in the CMP instructions are how many writes…
				$LF
				"IMode2:		 	; … to the zero page I can make with each interlace mode before running out…
				$LF
				" 	INY		; … of CPU cycles in a single frame.
				$LF
				" 	INY		; This guarantees the highest possible audio quality during the ZP writes.
				$LF
				"IMode1:
				$LF
				"	NOP		; This was changed a few times, so here’s a few lingering NOPs.
				$LF
				"	NOP		; I still need these to prevent the audio main loop from crossing a page boundary.
				$LF
				"	LDA $0403, Y	; Finally, using the value in Y, grab bytes from a LookUp Table
				$LF
				"	STA <$01	; Store the High byte at address $01
				$LF
				"	LDA $0402, Y	; Grab the low byte from the LUT.
				$LF
				"	STA <$00	; It’s perfectly fine to write these in the zero page. They will be overwritten.
				$LF
				"	JMP ($0000)	; Jump to the interlacing mode that best fits this frame.
				$LF
				$LF
				"MainAudio:		; The interlace modes all end by jumping here. Let’s count CPU cycles!
				$LF
				"	LDA #$01	; 2 cycles. A = 1. 
				$LF
				"	STA $4016	; +4 = 6 cycles. Strobe controllers.
				$LF
				"	LSR A		; +2 = 8 cycles. A = 0
				$LF
				"	STA $4016	; +4 = 12 cycles. Strobe controllers part 2.
				$LF
				"	EOR $4016	; +4 = 16 cycles. Very fast controller reading with EOR
				$LF
				"	ASL A		; +2 = 18 cycles.
				$LF
				"	EOR $4016	; +4 = 22 cycles.
				$LF
				"	ASL A		; +2 = 24 cycles.
				$LF
				"	EOR $4016	; +4 = 28 cycles.
				$LF
				"	ASL A		; +2 = 30 cycles.
				$LF
				"	EOR $4016	; +4 = 34 cycles.
				$LF
				"	ASL A		; +2 = 36 cycles.
				$LF
				"	EOR $4016	; +4 = 40 cycles.
				$LF
				"	ASL A		; +2 = 42 cycles.
				$LF
				"	EOR $4016	; +4 = 46 cycles.
				$LF
				"	ASL A		; +2 = 48 cycles.
				$LF
				"	EOR $4016	; +4 = 52 cycles.
				$LF
				"	ASL A		; +2 = 54 cycles.
				$LF
				"	EOR $4016	; +4 = 58 cycles.
				$LF
				"	EOR #$C0	; +2 = 60 cycles.
				$LF
				"	STA $4011	; +4 = 64 cycles. This write to the audio chip happens every 71 cycles.
				$LF
				"	CLC		; +2 = 66 cycles. Clear carry flag
				$LF
				"	ASL A		; +2 = 68 cycles. Bit 7 goes into the carry flag. 
				$LF
				"	BCC MainAudio	; +3 = 71 cycles. If bit 7 was not set, loop!
				$LF
				"	JMP $0300	; Now that all the time in a frame has run out, jump back to the top of the loop.
				$LF
				$LF
				"InterlaceModeJumpTable:	; Address $402
				$LF
				"	.byte $0A, $04	; Address $040A, Interlace Mode 1
				$LF
				"	.byte $68, $04	; Address $0468, Interlace Mode 2
				$LF
				"	.byte $EF, $04	; Address $04EF, Interlace Mode 3
				$LF
				"	.byte $9F, $05	; Address $059F, Interlace Mode 4
				$LF
				$LF
				"InterlaceMode1: 	; The comments for this section will be sparse
				$LF
				"	LDA #$01	; The code here is repetitive.
				$LF
				"	STA $4016	; Read the controller
				$LF
				"	LSR A
				$LF
				"	STA $4016	
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA <$FF, X	; Store the contents of the controller to the zero page
				$LF
				"	LDA #$01	; Read the controller again
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to Audio chip.
				$LF
				"	DEX		; if X == data length, branch 3 bytes
				$LF
				"	BEQ PostInterlaceMode1 
				$LF
				"	JMP $040A	; Otherwise, back to the start of InterlaceMode1
				$LF
				"PostInterlaceMode1:
				$LF
				"	JMP $03CE	; This jumps to MainAudio.
				$LF
				$LF
				"InterlaceMode2:
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				" 	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA <$FF, X	; Write to ZP
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				" 	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to APU (1)
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to APU (2)
				$LF
				"	DEX
				$LF
				"	BEQ PostInterlaceMode2
				$LF
				"	JMP $0468	; Back to the top of InterlaceMode2
				$LF
				"PostInterlaceMode2:
				$LF
				"	JMP $03CE	; Otherwise, jump to MainAudio
				$LF
				$LF
				"InterlaceMode3:
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA <$FF, X	; Write to Zero Page
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to APU (1)
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to APU (2)
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to APU (3)
				$LF
				"	DEX
				$LF
				"	BEQ PostInterlaceMode3
				$LF
				"	JMP $04EF	; Back to the top of InterlaceMode3
				$LF
				"PostInterlaceMode3:
				$LF
				"	JMP $03CE	; Jump to MainAudio
				$LF
				$LF
				"InterlaceMode4:
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA <$FF, X	; Write to Zero Page
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to APU (1)
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to APU (2)
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to APU (3)
				$LF
				"	LDA #$01	; Read controller
				$LF
				"	STA $4016
				$LF
				"	LSR A
				$LF
				"	STA $4016
				$LF
				"	EOR $4016
				$LF
				"	ASL
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	ASL A
				$LF
				"	EOR $4016
				$LF
				"	EOR #$C0
				$LF
				"	STA $4011	; Write to APU (4)
				$LF
				"	DEX
				$LF
				"	BEQ PostInterlaceMode4
				$LF
				"	JMP $059F	; Back to the top of InterlaceMode4
				$LF
				"PostInterlaceMode4:
				$LF
				"	JMP $03CE	; Jump to MainAudio
				$LF
				$LF
				"InitialSetup:
				$LF
				"	LDX #$00	; This is where I jump to when I begin the Bad Apple Loop.
				$LF
				"	JMP $0300	; Basically it just sets up the X register, then jumps to the main loop.
				$LF
				$LF
				" 	 	 	; There’s a handful of unused bytes here between $67D, and $6FF
				$LF
				$LF
				" 	 	 	; $700
				$LF
				"IdenticalByteRow:
				$LF
				"	STA $2007	; Here’s where the jump tables during VBlank end up.
				$LF
				"	STA $2007	; Basically, if I need to draw the same tile 20 times, then “STA $2007” runs 20 times.
				$LF
				"	STA $2007	; Taking a jump table is faster than looping.
				$LF
				"	STA $2007	
				$LF
				"	STA $2007	; Writing to $2007 is how you change a character on the nametable.
				$LF
				"	STA $2007	
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	STA $2007
				$LF
				"	INX		; X++, getting ready for the first byte of the next packet.
				$LF
				"	JMP $030F	; Jump to “Main”
				$LF
				$LF
				"IdenticalByteLUT:
				$LF
				"	.byte $39, $36, $33, $30, $2D, $2A, $27, $24, $21, $1E, $1B, $18, $15, $12, $0F, $0C, $09, $06, $03, $00
				$LF
				"	 	 	; If Y = 0, for example, it will grab that “$39”, making a jump to $739, executing a single STA instruction
				$LF
				"	 	 	; This is why it draws "Length+1" tiles. If Y = 19, it would jump to $700, executing all 20 STA's.
				$LF
				"IndividualByteRow:
				$LF
				"	LDA <$00, X	; Read the next byte of the packet
				$LF
				"	INX		; X++
				$LF
				"	STA $2007	; Store the value to the nametable.
				$LF
				"	LDA <$00, X	; Read the next byte of the packet
				$LF
				"	INX		; X++
				$LF
				"	STA $2007	; Store the value to the nametable
				$LF
				"	LDA <$00, X
				$LF
				"	INX		; This is very similar to the previous function, but for a run of individual tiles.
				$LF
				"	STA $2007	; Again, this is much faster than making a loop.
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX
				$LF
				"	STA $2007
				$LF
				"	LDA <$00, X
				$LF
				"	INX		; X is now ready to read the first byte of the next packet.
				$LF
				"	STA $2007
				$LF
				"	JMP $030F	; Jump to “Main”
				$LF
				$LF
				"IndividualByteLUT:
				$LF
				"	.byte $C6, $C0, $BA, $B4, $AE, $A8, $A2, $9C, $96, $90, $8A, $84, $7E, $78, $72, $6C, $66, $60, $5A, $54
				$LF
				"	 	 	; Another LUT that is used for a jump table. 
				$LF
				"	 	 	; And that’s it!
				$LF
			]pre
		]div
		[div class=tab-pane fade id=tabs-77156-4 
			[div class=p 
				"This runs after the video. It spoofs the level transition screen:
				$LF
			]div
			[pre 
				"	 	 	; This was written at address $300
				$LF
				"PostVideo:
				$LF
				"	LDA $2002	; Wait for Vblank
				$LF
				"	BPL PostVideo	; Branch until VBlank
				$LF
				$LF
				"	LDA #$00	; A = 0
				$LF
				"	STA $2001	; Disable Rendering
				$LF
				$LF
				"	LDA #$3F	; Set PPU Address to $3F00
				$LF
				"	STA $2006	; Palette info
				$LF
				"	LDA #$00	; Restore the palette to the castle level palette
				$LF
				"	STA $2006	; PPU Address = $$3F00
				$LF
				"	LDA #$0F	; A = 0x0F, Black
				$LF
				"	STA $2007	; Write to palette
				$LF
				"	LDA #$30	; A = 0x30, Whtie
				$LF
				"	STA $2007	; Write to palette
				$LF
				"	LDA #$10	; A = 0x10, Light Grey
				$LF
				"	STA $2007	; Write to palette
				$LF
				"	LDA #$00	; A = 0x00, Grey
				$LF
				"	STA $2007	; Write to palette
				$LF
				"	LDA #$3F	; Set up PPU Address to $3F10
				$LF
				"	STA $2006	; $3F10 is the palette used for Mario
				$LF
				"	LDA #$10	; It's still using the fire flower palette
				$LF
				"	STA $2006	; So I set it to the regular mario palette.
				$LF
				"	LDA #$0F	; A = 0x0F, Black. Ths background color.
				$LF
				"	STA $2007	; Write to palette
				$LF
				"	LDA #$16	; A= 0x16, Red
				$LF
				"	STA $2007	; Write to palette
				$LF
				"	LDA #$27	; A = 0x27, Light Orange
				$LF
				"	STA $2007	; Write to palette
				$LF
				"	LDA #$18	; A = 0x18, a Brownish-Green
				$LF
				"	STA $2007	; Write to palette
				$LF
				"	LDA #$3F	; Set PPU Address to $3F0D
				$LF
				"	STA $2006	; This is the color used for the blinking coin in the HUD
				$LF
				"	LDA #$0D	; It's always 0x27 during the screen transitions.
				$LF
				"	STA $2006	; 
				$LF
				"	LDA #$27	; A = 0x27, a Light Orange
				$LF
				"	STA $2007	; Write to palette
				$LF
				$LF
				"	LDA #$20	; Change PPU Address to $2000
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$00	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$24	; A = 0x24, an emtpy square
				$LF
				"	LDX #$C0	; We're going to change $3C0 tiles.
				$LF
				"	LDY #$04	; Recall that the blank square was tile 0x27 when setting up the bad apple loop.
				$LF
				"NTLoop:
				$LF
				"	STA $2007	; Now I need to cover the whole screen with tile 0x24.
				$LF
				"	DEX		; X--
				$LF
				"	BNE NTLoop	; If X != 0, loop
				$LF
				"	DEY		; Y--
				$LF
				"	BNE NTLoop	; If Y != 0, loop
				$LF
				$LF
				"	LDA #$20	; Now I'm going to draw individual tiles.
				$LF
				"	STA $2006	; Set up the PPU Address to $2043
				$LF
				"	LDA #$43	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$16	; "M"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$0A	; "A"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$1B	; "R"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$12	; "I"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$18	; "O"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$20	; Change PPU Address
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$52	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$20	; "W"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$18	; "O"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$1B	; "R"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$15	; "L"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$0D	; "D"
				$LF
				"	STA $2007	; 
				$LF
				"	LDA #$24	; " "
				$LF
				"	STA $2007	; 
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$1D	; "T"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$12	; "I"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$16	; "M"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$0E	; "E"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$20	; Change PPU Address
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$62	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$09	; "9"
				$LF
				"	STA $2007	; The number 9 is drawn 6 times.
				$LF
				"	STA $2007	; This is Mario's score.
				$LF
				"	STA $2007	;
				$LF
				"	STA $2007	;
				$LF
				"	STA $2007	;
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$00	; "0" It ends in a zero.
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$24	; " "
				$LF
				"	STA $2007	; Two spaces
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$2E	; "Coin Icon"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$29	; "x"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$00	; "0"
				$LF
				"	STA $2007	; Zero is drawn twice
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$24	; " "
				$LF
				"	STA $2007	; 4 spaces 
				$LF
				"	STA $2007	;
				$LF
				"	STA $2007	;
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$08	; "8"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$28	; "-"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$04	; "4"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$21	; Change PPU Address
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$4B	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$20	; "W"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$18	; "O"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$1B	; "R"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$15	; "L"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$0D	; "D"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$24	; " "
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$08	; "8"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$28	; "-"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$04	; "4"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$21	; Change PPU Address
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$CF	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$29	; "x"
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$24	; " "
				$LF
				"	STA $2007	; two spaces
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$03	; "3"
				$LF
				"	STA $2007	; This number is how many lives Mario has.
				$LF
				"	LDA #$23	; Change PPU Address
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$C2	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$C0	; Changing the Nametable's attribute table to make the coin the correct color.
				$LF
				"	STA $2007	;
				$LF
				"	LDA #$F8	; Clear OAM
				$LF
				"	LDX #$00	; This entire time it was still the data of mario shooting fireballs at bowser.
				$LF
				"OAMLoop:
				$LF
				"	STA $0200, X	; All of bowser's hammers are still there too!
				$LF
				"	DEX		; X--
				$LF
				"	BNE OAMLoop	; If X != 0, loop
				$LF
				$LF
				"	LDX #$00	; X= 0
				$LF
				"OAMLoop2:
				$LF
				"	LDA $0513, X	; A = next byte from a LookUp Table. This fills in OAM with the mario graphic for the screen.
				$LF
				"	STA $0200, X	; Store the next byte in OAM.
				$LF
				"	INX		; X++
				$LF
				"	CPX #$24	; if X != 0x24
				$LF
				"	BNE OAMLoop2	; loop
				$LF
				$LF
				"	LDA #$02	; A = 2
				$LF
				"	STA $4014	; OAM DMA. This sends $200 through $2FF to the PPU for sprite data.
				$LF
				"	LDA #$24	; While we're here, let's restore Nametable 2 to Bowser's castle.
				$LF
				"	STA $2006	; Set PPU Address to $2400
				$LF
				"	LDA #$00	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDX #$00	; We have 0x400 bytes to change.
				$LF
				"	LDY #$04	;
				$LF
				"NT2Loop:
				$LF
				"	JSR $016B	; Read the controller
				$LF
				"	STA $2007	; Store it on the nametable.
				$LF
				"	DEX		; X--
				$LF
				"	BNE NT2Loop	; If X != 0, loop
				$LF
				"	DEY		; Y--
				$LF
				"	BNE NT2Loop	; if Y != 0, loop
				$LF
				$LF
				"	LDA $2002	; I made changes here, and could've made this 3 NOPs, but this takes fewer cycles.
				$LF
				"WaitForVBlank:
				$LF
				"	LDA $2002	; Wait for Vblank
				$LF
				"	BPL WaitForVBlank
				$LF
				$LF
				"	LDA #$20	; Set the PPU Address to $2000
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$00	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$00	; Set the fine X scroll to zero
				$LF
				"	STA $2005	; This step needs to happen after the writes to $2006
				$LF
				"	LDA #$00	; Otherwise writing to $2006 messes with the fine Y scroll
				$LF
				"	STA $2005	; Which will also be 0 in this case.
				$LF
				"	LDA #$1E	; A = 0x1E
				$LF
				"	STA $2001	; Enable rendering, both the background and sprites.
				$LF
				$LF
				"WaitAFewFrames:
				$LF
				"	JSR $016B	; Read the controller
				$LF
				"	BMI PostScreen	; If I press "A" this loop ends.
				$LF
				"	BNE #0		; If I press anything else, waste 1 cycle.
				$LF
				"VBlankLoop2: 
				$LF
				"	LDA $2002	; Vblank loop again, this time with false-negative prevention.
				$LF
				"	BPL VBlankLoop2 ; Wait for VBlank, then always branch back to "WaitAFewFrames"
				$LF
				"	BMI WaitAFewFrames
				$LF
				$LF
				"PostScreen:
				$LF
				"	LDA #$00	; It's time to leave the fake screen, and restore the game to a stable state.
				$LF
				"	STA $2001	; Disable rendering
				$LF
				"	LDA #$20	; Set the ppu address to $2006
				$LF
				"	STA $2006	; ^
				$LF
				"	LDA #$00	; ^
				$LF
				"	STA $2006	; ^
				$LF
				"	LDX #$00	; Time to overwrite the nametable that was showing the fake screen transition.
				$LF
				"	LDY #$04	; $400 bytes to change
				$LF
				"NTLoop3:
				$LF
				"	JSR $016B	; Read the controller
				$LF
				"	STA $2007	; Write to nametable
				$LF
				"	DEX		; X--
				$LF
				"	BNE NTLoop3	; If X != 0, loop
				$LF
				"	DEY		; Y--
				$LF
				"	BNE NTLoop3	; if Y != 0, loop
				$LF
				$LF
				"	JMP $0181	; Return to total control loop
				$LF
				" 			; Then use the total control loop to write to every byte in RAM (except in the stack)
				$LF
				"			; We're essentially "loading a savestate" by doing this.
				$LF
				"			; Once that's all set up, enable the NMI and Jump to where SMB waits for the next frame. 
				$LF
				"OAMLookUpTable: 	; Address $513
				$LF
				"	.byte $F8, $00, $00, $00 	; This is a copy of OAM data during the screen transition.
				$LF
				"	.byte $58, $FC, $00, $60 	; An invisible object at screen coordinates (60, 58) Mario is short here.
				$LF
				"	.byte $58, $FC, $00, $68 	; An invisible object at screen coordinates (68, 58) If mario was tall, this would be his upper half.
				$LF
				"	.byte $60, $FC, $00, $60 	; An invisible object at screen coordinates (60, 60) Instead, it's invisible objects.
				$LF
				"	.byte $60, $FC, $00, $68	; An invisible object at screen coordinates (68, 60)
				$LF
				"	.byte $68, $3A, $00, $60	; The upper left of Mario's head at coords  (60, 68)
				$LF
				"	.byte $68, $37, $00, $68	; The upper right of Mario's head at coords (68, 68)
				$LF
				"	.byte $70, $4F, $00, $60	; The lower left of Mario's body at coords  (60, 70)
				$LF
				"	.byte $70, $4F, $40, $68	; The lower right of Mario's body at coords (68, 70)
				$LF
			]pre
		]div
	]div
]div
[h3 id=FunStatistics 
	" Fun statistics
	$LF
]h3
[div class=p 
	"For a little extra bit of fun, here's an ordered list of the characters drawn on screen during the music video, ranked by number of appearances.
	$LF
]div
[div class= 
	[div class= 
		[ul class=nav nav-tabs role=tablist 
			[li class=nav-item 
				[a class=active nav-link data-bs-toggle=tab href=#tabs-104291-0 
					"Hide List
				]a
			]li
			[li class=nav-item 
				[a class=nav-link data-bs-toggle=tab href=#tabs-104291-1 
					"Show List
				]a
			]li
		]ul
	]div
	[div class=tab-content 
		[div class=tab-pane fade active show id=tabs-104291-0 
		]div
		[div class=tab-pane fade id=tabs-104291-1 
			[pre 
				"0.   : Character 0x27 : 932396 instances.
				[br 
				]br
				$LF
				"1.   : Character 0x24 : 764660 instances.
				[br 
				]br
				$LF
				"2.   : Character 0x2A : 21826 instances.
				[br 
				]br
				$LF
				"3.   : Character 0x40 : 21037 instances.
				[br 
				]br
				$LF
				"4.   : Character 0xA2 : 16911 instances.
				[br 
				]br
				$LF
				"5.   : Character 0x2F : 13054 instances.
				[br 
				]br
				$LF
				"6.   : Character 0xA3 : 11675 instances.
				[br 
				]br
				$LF
				"7.   : Character 0x7E : 11604 instances.
				[br 
				]br
				$LF
				"8.   : Character 0xDD : 10895 instances.
				[br 
				]br
				$LF
				"9.   : Character 0x9D : 9784 instances.
				[br 
				]br
				$LF
				"10.  : Character 0xFF : 9646 instances.
				[br 
				]br
				$LF
				"11.  : Character 0x3D : 8853 instances.
				[br 
				]br
				$LF
				"12.  : Character 0x9B : 8005 instances.
				[br 
				]br
				$LF
				"13.  : Character 0x9E : 7806 instances.
				[br 
				]br
				$LF
				"14.  : Character 0x32 : 7457 instances.
				[br 
				]br
				$LF
				"15.  : Character 0x77 : 7449 instances.
				[br 
				]br
				$LF
				"16.  : Character 0x9C : 7222 instances.
				[br 
				]br
				$LF
				"17.  : Character 0x5C : 6125 instances.
				[br 
				]br
				$LF
				"18.  : Character 0x31 : 5872 instances.
				[br 
				]br
				$LF
				"19.  : Character 0xAD : 5767 instances.
				[br 
				]br
				$LF
				"20.  : Character 0xA8 : 5507 instances.
				[br 
				]br
				$LF
				"21.  : Character 0x3F : 4972 instances.
				[br 
				]br
				$LF
				"22.  : Character 0x26 : 4468 instances.
				[br 
				]br
				$LF
				"23.  : Character 0xAF : 4406 instances.
				[br 
				]br
				$LF
				"24.  : Character 0xCB : 4282 instances.
				[br 
				]br
				$LF
				"25.  : Character 0xA5 : 4011 instances.
				[br 
				]br
				$LF
				"26.  : Character 0xD3 : 3303 instances.
				[br 
				]br
				$LF
				"27.  : Character 0xE5 : 2762 instances.
				[br 
				]br
				$LF
				"28.  : Character 0x7D : 2709 instances.
				[br 
				]br
				$LF
				"29.  : Character 0x39 : 2577 instances.
				[br 
				]br
				$LF
				"30.  : Character 0xAC : 2540 instances.
				[br 
				]br
				$LF
				"31.  : Character 0x33 : 2534 instances.
				[br 
				]br
				$LF
				"32.  : Character 0xA6 : 2096 instances.
				[br 
				]br
				$LF
				"33.  : Character 0xCA : 2073 instances.
				[br 
				]br
				$LF
				"34.  : Character 0xD7 : 1833 instances.
				[br 
				]br
				$LF
				"35.  : Character 0xA7 : 1781 instances.
				[br 
				]br
				$LF
				"36.  : Character 0x0F : 1599 instances.
				[br 
				]br
				$LF
				"37.  : Character 0x48 : 1274 instances.
				[br 
				]br
				$LF
				"38.  : Character 0xAE : 1170 instances.
				[br 
				]br
				$LF
				"39.  : Character 0xBF : 1157 instances.
				[br 
				]br
				$LF
				"40.  : Character 0x66 : 1056 instances.
				[br 
				]br
				$LF
				"41.  : Character 0x07 : 1050 instances.
				[br 
				]br
				$LF
				"42.  : Character 0x25 : 1036 instances.
				[br 
				]br
				$LF
				"43.  : Character 0x3E : 981 instances.
				[br 
				]br
				$LF
				"44.  : Character 0x5B : 928 instances.
				[br 
				]br
				$LF
				"45.  : Character 0xC2 : 875 instances.
				[br 
				]br
				$LF
				"46.  : Character 0x4A : 757 instances.
				[br 
				]br
				$LF
				"47.  : Character 0x46 : 734 instances.
				[br 
				]br
				$LF
				"48.  : Character 0x79 : 630 instances.
				[br 
				]br
				$LF
				"49.  : Character 0x30 : 583 instances.
				[br 
				]br
				$LF
				"50.  : Character 0xD2 : 524 instances.
				[br 
				]br
				$LF
				"51.  : Character 0x8B : 470 instances.
				[br 
				]br
				$LF
				"52.  : Character 0xCC : 459 instances.
				[br 
				]br
				$LF
				"53.  : Character 0xD0 : 459 instances.
				[br 
				]br
				$LF
				"54.  : Character 0xE1 : 426 instances.
				[br 
				]br
				$LF
				"55.  : Character 0x98 : 419 instances.
				[br 
				]br
				$LF
				"56.  : Character 0x41 : 400 instances.
				[br 
				]br
				$LF
				"57.  : Character 0xD1 : 398 instances.
				[br 
				]br
				$LF
				"58.  : Character 0x99 : 345 instances.
				[br 
				]br
				$LF
				"59.  : Character 0xD6 : 341 instances.
				[br 
				]br
				$LF
				"60.  : Character 0x78 : 334 instances.
				[br 
				]br
				$LF
				"61.  : Character 0x65 : 319 instances.
				[br 
				]br
				$LF
				"62.  : Character 0xC6 : 309 instances.
				[br 
				]br
				$LF
				"63.  : Character 0x6C : 298 instances.
				[br 
				]br
				$LF
				"64.  : Character 0x9A : 291 instances.
				[br 
				]br
				$LF
				"65.  : Character 0x8E : 289 instances.
				[br 
				]br
				$LF
				"66.  : Character 0x15 : 285 instances.
				[br 
				]br
				$LF
				"67.  : Character 0xD9 : 284 instances.
				[br 
				]br
				$LF
				"68.  : Character 0x28 : 277 instances.
				[br 
				]br
				$LF
				"69.  : Character 0xDC : 275 instances.
				[br 
				]br
				$LF
				"70.  : Character 0x6D : 264 instances.
				[br 
				]br
				$LF
				"71.  : Character 0x7F : 263 instances.
				[br 
				]br
				$LF
				"72.  : Character 0x8F : 240 instances.
				[br 
				]br
				$LF
				"73.  : Character 0x1D : 238 instances.
				[br 
				]br
				$LF
				"74.  : Character 0xDE : 225 instances.
				[br 
				]br
				$LF
				"75.  : Character 0x2B : 218 instances.
				[br 
				]br
				$LF
				"76.  : Character 0x6E : 217 instances.
				[br 
				]br
				$LF
				"77.  : Character 0x42 : 202 instances.
				[br 
				]br
				$LF
				"78.  : Character 0xBD : 188 instances.
				[br 
				]br
				$LF
				"79.  : Character 0xE8 : 183 instances.
				[br 
				]br
				$LF
				"80.  : Character 0xBE : 171 instances.
				[br 
				]br
				$LF
				"81.  : Character 0xD5 : 170 instances.
				[br 
				]br
				$LF
				"82.  : Character 0x56 : 165 instances.
				[br 
				]br
				$LF
				"83.  : Character 0xC7 : 164 instances.
				[br 
				]br
				$LF
				"84.  : Character 0xC4 : 162 instances.
				[br 
				]br
				$LF
				"85.  : Character 0xC9 : 150 instances.
				[br 
				]br
				$LF
				"86.  : Character 0x95 : 149 instances.
				[br 
				]br
				$LF
				"87.  : Character 0xD4 : 142 instances.
				[br 
				]br
				$LF
				"88.  : Character 0x81 : 141 instances.
				[br 
				]br
				$LF
				"89.  : Character 0x97 : 132 instances.
				[br 
				]br
				$LF
				"90.  : Character 0x87 : 128 instances.
				[br 
				]br
				$LF
				"91.  : Character 0xAB : 120 instances.
				[br 
				]br
				$LF
				"92.  : Character 0xBC : 117 instances.
				[br 
				]br
				$LF
				"93.  : Character 0x2C : 114 instances.
				[br 
				]br
				$LF
				"94.  : Character 0xE2 : 105 instances.
				[br 
				]br
				$LF
				"95.  : Character 0x2E : 97 instances.
				[br 
				]br
				$LF
				"96.  : Character 0xCD : 94 instances.
				[br 
				]br
				$LF
				"97.  : Character 0xB4 : 88 instances.
				[br 
				]br
				$LF
				"98.  : Character 0x45 : 85 instances.
				[br 
				]br
				$LF
				"99.  : Character 0x91 : 84 instances.
				[br 
				]br
				$LF
				"100. : Character 0x14 : 83 instances.
				[br 
				]br
				$LF
				"101. : Character 0x22 : 79 instances.
				[br 
				]br
				$LF
				"102. : Character 0x57 : 71 instances.
				[br 
				]br
				$LF
				"103. : Character 0x59 : 71 instances.
				[br 
				]br
				$LF
				"104. : Character 0x72 : 71 instances.
				[br 
				]br
				$LF
				"105. : Character 0x86 : 71 instances.
				[br 
				]br
				$LF
				"106. : Character 0x01 : 67 instances.
				[br 
				]br
				$LF
				"107. : Character 0x4D : 63 instances.
				[br 
				]br
				$LF
				"108. : Character 0x13 : 61 instances.
				[br 
				]br
				$LF
				"109. : Character 0xE3 : 60 instances.
				[br 
				]br
				$LF
				"110. : Character 0x16 : 53 instances.
				[br 
				]br
				$LF
				"111. : Character 0x7C : 53 instances.
				[br 
				]br
				$LF
				"112. : Character 0x4B : 52 instances.
				[br 
				]br
				$LF
				"113. : Character 0x19 : 51 instances.
				[br 
				]br
				$LF
				"114. : Character 0x34 : 51 instances.
				[br 
				]br
				$LF
				"115. : Character 0x23 : 50 instances.
				[br 
				]br
				$LF
				"116. : Character 0x1F : 48 instances.
				[br 
				]br
				$LF
				"117. : Character 0x68 : 47 instances.
				[br 
				]br
				$LF
				"118. : Character 0xCE : 46 instances.
				[br 
				]br
				$LF
				"119. : Character 0xF2 : 44 instances.
				[br 
				]br
				$LF
				"120. : Character 0x64 : 41 instances.
				[br 
				]br
				$LF
				"121. : Character 0x96 : 38 instances.
				[br 
				]br
				$LF
				"122. : Character 0xB8 : 37 instances.
				[br 
				]br
				$LF
				"123. : Character 0x0C : 36 instances.
				[br 
				]br
				$LF
				"124. : Character 0x67 : 36 instances.
				[br 
				]br
				$LF
				"125. : Character 0xA0 : 36 instances.
				[br 
				]br
				$LF
				"126. : Character 0x0E : 34 instances.
				[br 
				]br
				$LF
				"127. : Character 0x12 : 34 instances.
				[br 
				]br
				$LF
				"128. : Character 0x73 : 33 instances.
				[br 
				]br
				$LF
				"129. : Character 0xDF : 33 instances.
				[br 
				]br
				$LF
				"130. : Character 0xF1 : 33 instances.
				[br 
				]br
				$LF
				"131. : Character 0x8C : 32 instances.
				[br 
				]br
				$LF
				"132. : Character 0xBA : 31 instances.
				[br 
				]br
				$LF
				"133. : Character 0x60 : 28 instances.
				[br 
				]br
				$LF
				"134. : Character 0xB9 : 28 instances.
				[br 
				]br
				$LF
				"135. : Character 0x7B : 27 instances.
				[br 
				]br
				$LF
				"136. : Character 0x80 : 26 instances.
				[br 
				]br
				$LF
				"137. : Character 0x71 : 25 instances.
				[br 
				]br
				$LF
				"138. : Character 0xDB : 25 instances.
				[br 
				]br
				$LF
				"139. : Character 0x2D : 22 instances.
				[br 
				]br
				$LF
				"140. : Character 0x04 : 21 instances.
				[br 
				]br
				$LF
				"141. : Character 0x29 : 21 instances.
				[br 
				]br
				$LF
				"142. : Character 0x52 : 21 instances.
				[br 
				]br
				$LF
				"143. : Character 0x58 : 21 instances.
				[br 
				]br
				$LF
				"144. : Character 0x83 : 21 instances.
				[br 
				]br
				$LF
				"145. : Character 0xE9 : 21 instances.
				[br 
				]br
				$LF
				"146. : Character 0x6B : 20 instances.
				[br 
				]br
				$LF
				"147. : Character 0x85 : 20 instances.
				[br 
				]br
				$LF
				"148. : Character 0xA9 : 20 instances.
				[br 
				]br
				$LF
				"149. : Character 0x75 : 19 instances.
				[br 
				]br
				$LF
				"150. : Character 0xA1 : 18 instances.
				[br 
				]br
				$LF
				"151. : Character 0xAA : 18 instances.
				[br 
				]br
				$LF
				"152. : Character 0x6A : 17 instances.
				[br 
				]br
				$LF
				"153. : Character 0x6F : 17 instances.
				[br 
				]br
				$LF
				"154. : Character 0x74 : 17 instances.
				[br 
				]br
				$LF
				"155. : Character 0x35 : 16 instances.
				[br 
				]br
				$LF
				"156. : Character 0x70 : 16 instances.
				[br 
				]br
				$LF
				"157. : Character 0x8A : 16 instances.
				[br 
				]br
				$LF
				"158. : Character 0x17 : 15 instances.
				[br 
				]br
				$LF
				"159. : Character 0x92 : 14 instances.
				[br 
				]br
				$LF
				"160. : Character 0xF6 : 14 instances.
				[br 
				]br
				$LF
				"161. : Character 0x1E : 12 instances.
				[br 
				]br
				$LF
				"162. : Character 0x20 : 11 instances.
				[br 
				]br
				$LF
				"163. : Character 0x62 : 11 instances.
				[br 
				]br
				$LF
				"164. : Character 0x00 : 10 instances.
				[br 
				]br
				$LF
				"165. : Character 0x43 : 10 instances.
				[br 
				]br
				$LF
				"166. : Character 0x4F : 10 instances.
				[br 
				]br
				$LF
				"167. : Character 0x76 : 10 instances.
				[br 
				]br
				$LF
				"168. : Character 0x7A : 10 instances.
				[br 
				]br
				$LF
				"169. : Character 0x37 : 9 instances.
				[br 
				]br
				$LF
				"170. : Character 0x63 : 9 instances.
				[br 
				]br
				$LF
				"171. : Character 0xC0 : 9 instances.
				[br 
				]br
				$LF
				"172. : Character 0xC5 : 9 instances.
				[br 
				]br
				$LF
				"173. : Character 0xDA : 9 instances.
				[br 
				]br
				$LF
				"174. : Character 0x03 : 8 instances.
				[br 
				]br
				$LF
				"175. : Character 0x0D : 8 instances.
				[br 
				]br
				$LF
				"176. : Character 0x51 : 8 instances.
				[br 
				]br
				$LF
				"177. : Character 0x69 : 8 instances.
				[br 
				]br
				$LF
				"178. : Character 0x82 : 8 instances.
				[br 
				]br
				$LF
				"179. : Character 0xB5 : 8 instances.
				[br 
				]br
				$LF
				"180. : Character 0x05 : 7 instances.
				[br 
				]br
				$LF
				"181. : Character 0x09 : 7 instances.
				[br 
				]br
				$LF
				"182. : Character 0x11 : 7 instances.
				[br 
				]br
				$LF
				"183. : Character 0x54 : 7 instances.
				[br 
				]br
				$LF
				"184. : Character 0x61 : 7 instances.
				[br 
				]br
				$LF
				"185. : Character 0xB7 : 7 instances.
				[br 
				]br
				$LF
				"186. : Character 0x21 : 6 instances.
				[br 
				]br
				$LF
				"187. : Character 0x55 : 6 instances.
				[br 
				]br
				$LF
				"188. : Character 0xC3 : 6 instances.
				[br 
				]br
				$LF
				"189. : Character 0xC8 : 6 instances.
				[br 
				]br
				$LF
				"190. : Character 0xFA : 6 instances.
				[br 
				]br
				$LF
				"191. : Character 0x47 : 5 instances.
				[br 
				]br
				$LF
				"192. : Character 0x49 : 5 instances.
				[br 
				]br
				$LF
				"193. : Character 0x5F : 5 instances.
				[br 
				]br
				$LF
				"194. : Character 0x90 : 5 instances.
				[br 
				]br
				$LF
				"195. : Character 0x0A : 4 instances.
				[br 
				]br
				$LF
				"196. : Character 0x18 : 4 instances.
				[br 
				]br
				$LF
				"197. : Character 0x50 : 4 instances.
				[br 
				]br
				$LF
				"198. : Character 0xE0 : 4 instances.
				[br 
				]br
				$LF
				"199. : Character 0xFB : 4 instances.
				[br 
				]br
				$LF
				"200. : Character 0x44 : 3 instances.
				[br 
				]br
				$LF
				"201. : Character 0x53 : 3 instances.
				[br 
				]br
				$LF
				"202. : Character 0x5E : 3 instances.
				[br 
				]br
				$LF
				"203. : Character 0x8D : 3 instances.
				[br 
				]br
				$LF
				"204. : Character 0xB3 : 3 instances.
				[br 
				]br
				$LF
				"205. : Character 0xD8 : 3 instances.
				[br 
				]br
				$LF
				"206. : Character 0xFC : 3 instances.
				[br 
				]br
				$LF
				"207. : Character 0x02 : 2 instances.
				[br 
				]br
				$LF
				"208. : Character 0x06 : 2 instances.
				[br 
				]br
				$LF
				"209. : Character 0x1B : 2 instances.
				[br 
				]br
				$LF
				"210. : Character 0x38 : 2 instances.
				[br 
				]br
				$LF
				"211. : Character 0x3C : 2 instances.
				[br 
				]br
				$LF
				"212. : Character 0x4C : 2 instances.
				[br 
				]br
				$LF
				"213. : Character 0x5D : 2 instances.
				[br 
				]br
				$LF
				"214. : Character 0x84 : 2 instances.
				[br 
				]br
				$LF
				"215. : Character 0x9F : 2 instances.
				[br 
				]br
				$LF
				"216. : Character 0xA4 : 2 instances.
				[br 
				]br
				$LF
				"217. : Character 0xF0 : 2 instances.
				[br 
				]br
				$LF
				"218. : Character 0x1A : 1 instance.
				[br 
				]br
				$LF
				"219. : Character 0x36 : 1 instance.
				[br 
				]br
				$LF
				"220. : Character 0x3B : 1 instance.
				[br 
				]br
				$LF
				"221. : Character 0x5A : 1 instance.
				[br 
				]br
				$LF
				"222. : Character 0x88 : 1 instance.
				[br 
				]br
				$LF
				"223. : Character 0x93 : 1 instance.
				[br 
				]br
				$LF
				"224. : Character 0xB0 : 1 instance.
				[br 
				]br
				$LF
				"225. : Character 0xB2 : 1 instance.
				[br 
				]br
				$LF
				"226. : Character 0xB6 : 1 instance.
				[br 
				]br
				$LF
				"227. : Character 0xCF : 1 instance.
				[br 
				]br
				$LF
				"228. : Character 0xEB : 1 instance.
				[br 
				]br
				$LF
				"229. : Character 0xF8 : 1 instance.
				[br 
				]br
				$LF
				"230. : Character 0x08 : 0 instances.
				[br 
				]br
				$LF
				"231. : Character 0x0B : 0 instances.
				[br 
				]br
				$LF
				"232. : Character 0x10 : 0 instances.
				[br 
				]br
				$LF
				"233. : Character 0x1C : 0 instances.
				[br 
				]br
				$LF
				"234. : Character 0x3A : 0 instances.
				[br 
				]br
				$LF
				"235. : Character 0x4E : 0 instances.
				[br 
				]br
				$LF
				"236. : Character 0x89 : 0 instances.
				[br 
				]br
				$LF
				"237. : Character 0x94 : 0 instances.
				[br 
				]br
				$LF
				"238. : Character 0xB1 : 0 instances.
				[br 
				]br
				$LF
				"239. : Character 0xBB : 0 instances.
				[br 
				]br
				$LF
				"240. : Character 0xC1 : 0 instances.
				[br 
				]br
				$LF
				"241. : Character 0xE4 : 0 instances.
				[br 
				]br
				$LF
				"242. : Character 0xE6 : 0 instances.
				[br 
				]br
				$LF
				"243. : Character 0xE7 : 0 instances.
				[br 
				]br
				$LF
				"244. : Character 0xEA : 0 instances.
				[br 
				]br
				$LF
				"245. : Character 0xEC : 0 instances.
				[br 
				]br
				$LF
				"246. : Character 0xED : 0 instances.
				[br 
				]br
				$LF
				"247. : Character 0xEE : 0 instances.
				[br 
				]br
				$LF
				"248. : Character 0xEF : 0 instances.
				[br 
				]br
				$LF
				"249. : Character 0xF3 : 0 instances.
				[br 
				]br
				$LF
				"250. : Character 0xF4 : 0 instances.
				[br 
				]br
				$LF
				"251. : Character 0xF5 : 0 instances.
				[br 
				]br
				$LF
				"252. : Character 0xF7 : 0 instances.
				[br 
				]br
				$LF
				"253. : Character 0xF9 : 0 instances.
				[br 
				]br
				$LF
				"254. : Character 0xFD : 0 instances.
				[br 
				]br
				$LF
				"255. : Character 0xFE : 0 instances.
				[br 
				]br
				$LF
			]pre
		]div
	]div
]div
[h2 id=WhyDoesThisTasRunSlowlyInTheEmulator 
	"Why does this TAS run slowly in the emulator?
	$LF
]h2
[div class=p 
	"Many people have asked why this TAS runs so slow in the emulator, and I thought I'd answer that here.
	$LF
]div
[div class=p 
	"This TAS uses the SubNesHawk core. Let's take a brief moment to talk about why this core exists. If you read the section about how the NES reads controllers, you might recall that this isn't something the console automatically does once per frame. The programmers write code to "strobe the controller" (store 1 then 0 to address $4016) and then "read the controller" (read 1 button at a time from address $4016). With this TAS, I read different inputs from the controller around 500 times every frame. In order to do that, the emulator needs to be able to provide multiple differing inputs in a single frame.
	$LF
]div
[div class=p 
	"I'm simplifying, but SubNesHawk works by creating "fake frames" every time the controllers are strobed. Now a single frame of Super Mario Bros. in the NesHawk Core becomes two frames in SubNesHawk. Starting from the beginning of VBlank up until the controller is strobed, then a new "frame" from the moment the controller is stobed up until the start of the next VBlank. Games like Super Mario Bros. 3 read the controller multiple times in a frame to prevent a hardware issue, so with SubNesHawk, a typical frame of Super Mario Bros. 3 is actually 5 "frames" long. (Beginning at the start of Vblank, 2 reads of controller 1, 2 reads of controller 2)
	$LF
]div
[div class=p 
	"Now consider the average frame of this TAS. With 500 inputs on average per frame, running this in SubNesHawk will create about 500 "frames" per frame. Since the emulator wants to run at approximately 60 frames per second, the SubNesHawk core tends to run much slower than the NesHawk Core due to the extra "frames" it needs, and in the case of this TAS that's about 500 times slower during the music video. This is not an optimization issue with Bizhawk. This is just how this emulator plays Subframe TASes.
	$LF
]div
[hr 
]hr
[div class=p 
	[a class=intlink href=/Users/Profile/InfoTeddy 
		"InfoTeddy
	]a
	": nice
	$LF
]div
[div class=p 
	[a class=intlink href=/Users/Profile/InfoTeddy 
		"InfoTeddy
	]a
	": I know everyone has said this a billion times already but I have to say it too - this is genuinely really freaking impressive. Not only figuring out how to play the video and audio and streaming both of them through controller inputs, but also documenting the process thoroughly in this submission so others could do it too (if they wanted to). What's more is that the audience really enjoyed it too with staggering positive feedback, making it worth it in the end. Dare I say, this is one of the best April Fools' submissions ever made on this site.
	$LF
]div
[div class=p 
	"I wasn't able to get the "official" submission working; my Bizhawk install crashes when I try it. But the 
	[a class=intlink href=/UserFiles/Info/638479355124534524 
		"uploaded userfile
	]a
	" does sync for me, albeit really slowly on emulator. Unfortunately, I can't replace the submission with that file because I have a submission file limit too, so I think leaving the actual file used for sync as a userfile is acceptable.
	$LF
]div
[div class=p 
	"Due to the impressive technical feats and overwhelming positive audience reception, I am accepting to Alternative under the "arbitrary code execution" goal.
	$LF
]div
[hr 
]hr
[div class=p 
	[a class=intlink href=/Users/Profile/Spikestuff 
		"Spikestuff
	]a
	": Processing...
	$LF
]div
[div class=p 
	[a class=intlink href=/Users/Profile/feos 
		"feos
	]a
	": Replacing with the correct movie.
]div
