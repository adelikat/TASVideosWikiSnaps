9
[h2 id=LuaFunctions 
	" Lua functions
	$LF
]h2
[div class=p 
	"This page collects useful Lua functions for use in game bots.
	$LF
]div
[div class=card mb-2 
	[div class=card-header 
		[strong 
			"Table of contents
		]strong
	]div
	[div class=card-body 
		[ul 
			[li 
				[a href=#LuaFunctions 
					" Lua functions
					$LF
				]a
				[ul 
					[li 
						[a href=#FunctionExplainInput 
							" function explain_input()
							$LF
						]a
					]li
					[li 
						[a href=#FunctionTableClone 
							" function table.clone()
							$LF
						]a
					]li
					[li 
						[a href=#ClassInputsimplifier 
							" class InputSimplifier
							$LF
						]a
					]li
					[li 
						[a href=#FunctionSimplebotloop 
							" function SimpleBotLoop()
							$LF
						]a
					]li
					[li 
						[a href=#ExampleUseOfInputgenerator 
							" Example use of InputGenerator
							$LF
						]a
					]li
					[li 
						[a href=#ExampleUseOfInputsimplifier 
							" Example use of InputSimplifier
							$LF
						]a
					]li
					[li 
						[a href=#ExampleImplementationOfClassInputgenerator 
							" Example implementation of class InputGenerator
							$LF
						]a
					]li
					[li 
						[a href=#ExampleImplementationOfClassGamestate 
							" Example implementation of class Gamestate
							$LF
						]a
					]li
					[li 
						[a href=#MultiplayerLuaBotFramework 
							" Multiplayer LUA bot framework
							$LF
						]a
					]li
				]ul
			]li
		]ul
	]div
]div
[h3 id=FunctionExplainInput 
	" function explain_input()
	$LF
]h3
[pre 
	[code class=language-lua 
		"----
		$LF
		"-- This converts the sequence of input into a string for printing.
		$LF
		"-- Not specific to any particular game.
		$LF
		"-- The input is assumed to be an array of joypad input objects.
		$LF
		"-- It aims to express the input in minimal readable length.
		$LF
		"-- For example, the result "3*R, 4*R_A, 10*R"
		$LF
		"-- means "hold right for 3 frames,
		$LF
		"--        then hold right+A for 4 frames,
		$LF
		"--        then hold right for 10 frames".
		$LF
		"-----
		$LF
		"keynames={A="A",B="B",select="SE",start="ST",
		$LF
		"          up="U",down="D",left="L",right="R"}
		$LF
		$LF
		"local function explain_input(input)
		$LF
		"  local inputdesc=""
		$LF
		"  local lastinput={}
		$LF
		"  local inpcount=0
		$LF
		"  local function inpkeys(keys)
		$LF
		"    local msg=""
		$LF
		"    local num_keys=0
		$LF
		"    local p=function(s)
		$LF
		"      if(num_keys>0) then msg=msg.."_" end
		$LF
		"      msg=msg..s 
		$LF
		"      num_keys=num_keys+1
		$LF
		"    end
		$LF
		"    for member,name in pairs(keynames) do if(keys[member]) then p(name) end end
		$LF
		"    if(num_keys==0) then p("00") end
		$LF
		"    return msg
		$LF
		"  end
		$LF
		"  local function inpflush()
		$LF
		"    if(inpcount > 0)then
		$LF
		"      local msg = inpcount.."*"..lastinput
		$LF
		"      if(inputdesc ~= "") then inputdesc = inputdesc..", " end
		$LF
		"      inputdesc = inputdesc..msg
		$LF
		"    end
		$LF
		"  end
		$LF
		"  for i,v in ipairs(input) do
		$LF
		"    local k = inpkeys(v)
		$LF
		"    if(k ~= lastinput) then inpflush(); inpcount=0; lastinput=k end
		$LF
		"    inpcount = inpcount+1
		$LF
		"  end
		$LF
		"  inpflush()
		$LF
		"  if(inputdesc == "") then inputdesc = "<no input>" end
		$LF
		"  return inputdesc
		$LF
		"end
		$LF
	]code
]pre
[h3 id=FunctionTableClone 
	" function table.clone()
	$LF
]h3
[div class=p 
	"Tables in Lua are assigned by reference. Use this function if you need to make a copy of a table that you can change without affecting the original.
	$LF
]div
[pre 
	[code class=language-lua 
		"table.clone = function(table)
		$LF
		"  local res = {}
		$LF
		"  for k,v in pairs(table)do
		$LF
		"    res[k]=v
		$LF
		"  end
		$LF
		"  return res
		$LF
		"end
		$LF
	]code
]pre
[h3 id=ClassInputsimplifier 
	" class InputSimplifier
	$LF
]h3
[pre 
	[code class=language-lua 
		"----
		$LF
		"-- This simplifies an input sequence   
		$LF
		"-- Not specific to any particular game.
		$LF
		"-- Inputs generated by random algorithms are highly... random.
		$LF
		"-- This function can be used to refine the input by removing as many
		$LF
		"-- unnecessary keypresses as possible.
		$LF
		"-----
		$LF
		"InputSimplifier = {
		$LF
		"  new=function(self,inputhistory,strat)
		$LF
		"    local res = {history=inputhistory,pos=1,attempt={},done=0,
		$LF
		"                 resetpoint=1,strategy=strat,anysuccess=0
		$LF
		"                 }
		$LF
		"    return setmetatable(res, self.mt)
		$LF
		"  end,
		$LF
		"  reset=function(self,attemptno)
		$LF
		"    self.attempt = table.clone(self.history)
		$LF
		"    local counter = 0
		$LF
		"    -- First, try removing redundant frames
		$LF
		"    for frameno,data in pairs(self.attempt)do
		$LF
		"      counter = counter+1
		$LF
		"      if counter == self.pos then
		$LF
		"        table.remove(self.attempt, frameno)
		$LF
		"        table.insert(self.attempt, self.attempt[#self.attempt])
		$LF
		"        if explain_input(self.attempt) ~= explain_input(self.history) then
		$LF
		"          self.resetpoint = counter
		$LF
		"          return
		$LF
		"        end
		$LF
		"        self.pos = self.pos + 1
		$LF
		"      end
		$LF
		"    end
		$LF
		"    if self.strategy == "full" then
		$LF
		"      -- Next, try removing extra input
		$LF
		"      for frameno,data in pairs(self.attempt)do
		$LF
		"        self.attempt[frameno] = table.clone(self.attempt[frameno])
		$LF
		"        -- Try removing some key
		$LF
		"        for member,name in pairs(keynames)do
		$LF
		"          counter = counter+1
		$LF
		"          if counter == self.pos then
		$LF
		"            if data[member] then
		$LF
		"              self.attempt[frameno][member] = nil
		$LF
		"              self.resetpoint = counter
		$LF
		"              return
		$LF
		"            end
		$LF
		"            self.pos = self.pos + 1
		$LF
		"          end
		$LF
		"        end
		$LF
		"--         -- Try copying the previous keys
		$LF
		"--         -- Note: Disabled. This can cause an infinite loop,
		$LF
		"--         --       where input is first removed, then copied
		$LF
		"--         --       from the previous frame, then removed again, etc.
		$LF
		"--         counter = counter+1
		$LF
		"--         if counter == self.pos then
		$LF
		"--           if (frameno > 1)
		$LF
		"--           and (explain_input(data) ~= explain_input(self.attempt[frameno-1])) then
		$LF
		"--             self.attempt[frameno] = table.clone(self.attempt[frameno-1])
		$LF
		"--             self.resetpoint = counter
		$LF
		"--             return
		$LF
		"--           end
		$LF
		"--           self.pos = self.pos + 1
		$LF
		"--         end
		$LF
		"      end
		$LF
		"    end
		$LF
		"    -- We've tried everything now.
		$LF
		"    if(self.resetpoint > 1)and(self.anysuccess > 0)then
		$LF
		"      -- The last reset was a partial one.
		$LF
		"      -- Do one more full pass in case we missed something
		$LF
		"      self.resetpoint = 1
		$LF
		"      self.pos        = 1
		$LF
		"      self.anysuccess = 0
		$LF
		"      return self:reset(attemptno)
		$LF
		"    end
		$LF
		"    self.done = 1
		$LF
		"  end,
		$LF
		"  generate=function(self,frameno)
		$LF
		"    if(frameno >= #self.attempt) then return {} end
		$LF
		"    return self.attempt[frameno]
		$LF
		"  end,
		$LF
		"  are_you_done = function(self) 
		$LF
		"    return self.done > 0
		$LF
		"  end,
		$LF
		"  you_failed = function(self)
		$LF
		"    -- Ignore the latest attempt
		$LF
		"    self.pos     = self.pos + 1
		$LF
		"  end,
		$LF
		"  you_rule = function(self)
		$LF
		"    -- Our attempt worked, go and find a new thing to change!
		$LF
		"    self.history    = self.attempt
		$LF
		"    self.pos        = self.resetpoint
		$LF
		"    self.anysuccess = 1
		$LF
		"  end,
		$LF
		"  get_result = function(self)
		$LF
		"    return self.history
		$LF
		"  end,
		$LF
		"  
		$LF
		"  explain_progress = function(self)
		$LF
		"    local counter = 0
		$LF
		"    for frameno,data in pairs(self.attempt)do
		$LF
		"      counter = counter+1
		$LF
		"    end
		$LF
		"    if self.strategy == "full" then
		$LF
		"      for frameno,data in pairs(self.attempt)do
		$LF
		"        for member,name in pairs(keynames)do
		$LF
		"          counter = counter+1
		$LF
		"        end
		$LF
		"        counter = counter+1
		$LF
		"      end
		$LF
		"    end
		$LF
		"    return self.pos.."/"..counter
		$LF
		"  end
		$LF
		"}
		$LF
		"InputSimplifier.mt={__index=InputSimplifier}
		$LF
	]code
]pre
[h3 id=FunctionSimplebotloop 
	" function SimpleBotLoop()
	$LF
]h3
[div class=p 
	"A simple engine for creating input using an abstract gamestate
	$LF
	"object and an abstract input generator object, and callback
	$LF
	"functions for fails and successes.
	$LF
]div
[pre 
	[code class=language-lua 
		"----
		$LF
		"-- Main program
		$LF
		"-----
		$LF
		"local function SimpleBotLoop(
		$LF
		"                   state, -- This object tells whether we've achieved a goal
		$LF
		"                   input, -- This object generates input for us
		$LF
		"                   has_ended_func, -- This function tells whether we should stop
		$LF
		"                   when_fail_func, -- This function reports the caller that we failed
		$LF
		"                   when_succ_func) -- This function reports the caller that we succeeded
		$LF
		$LF
		"  local attempts, state_actions = 0,
		$LF
		"    {[-1]=when_fail_func,  -- when getstate() returns -1, report failure
		$LF
		"      [0]=function(i)end,  -- when getstate() returns 0, carry on
		$LF
		"      [1]=when_succ_func}  -- when getstate() returns +1, report success
		$LF
		$LF
		"  while(has_ended_func(attempts) == false) do
		$LF
		"    state:reset()
		$LF
		"    input:reset(attempts)
		$LF
		$LF
		"    local inputhistory = {}
		$LF
		$LF
		"    repeat
		$LF
		"      local inp = input:generate(state.frame+1) -- +1 so we get 1..n for frameno
		$LF
		"      table.insert(inputhistory, inp)
		$LF
		"      joypad.set(1, inp)
		$LF
		"      FCEU.frameadvance()
		$LF
		"      local s = state:getstate()
		$LF
		"      state_actions[s](inputhistory)
		$LF
		"    until s ~= 0
		$LF
		"    attempts=attempts+1
		$LF
		"  end
		$LF
		"end
		$LF
	]code
]pre
[h3 id=ExampleUseOfInputgenerator 
	" Example use of InputGenerator
	$LF
]h3
[div class=p 
	"Example of using SimpleBotLoop to find the best input sequence.
	$LF
]div
[div class=p 
	"First, some bookkeeping. The Bestness object is
	$LF
	"responsible of keeping track of the best attempt.
	$LF
]div
[pre 
	[code class=language-lua 
		"state = Gamestate:new()
		$LF
		$LF
		"local Bestness = {
		$LF
		"  bestattempt=9999,
		$LF
		"  bestsave   =savestate.create(9), -- Best attempt will be saved to slot 9
		$LF
		"  bestinput  ={},
		$LF
		$LF
		"  save = function(self)
		$LF
		"    savestate.save(self.bestsave)
		$LF
		"    savestate.persist(self.bestsave)
		$LF
		"  end,
		$LF
		" 
		$LF
		"  is_success = function(self,inputhistory)
		$LF
		"    if state.frame < self.bestattempt then
		$LF
		"      self.bestattempt = state.frame
		$LF
		"      self.bestinput   = table.clone(inputhistory)
		$LF
		"      maxframe         = state.frame
		$LF
		"      self:save()
		$LF
		"      return true   
		$LF
		"    end
		$LF
		"    return false
		$LF
		"  end
		$LF
		"}
		$LF
		$LF
		"FCEU.speedmode("maximum")
		$LF
	]code
]pre
[div class=p 
	"The actual game loop:
	$LF
]div
[pre 
	[code class=language-lua 
		"-- Find great inputs randomly
		$LF
		"SimpleBotLoop(state, InputGenerator:new(),
		$LF
		"  function(attempts)
		$LF
		"    return attempts >= 25000
		$LF
		"  end,
		$LF
		"  function(inputhistory)
		$LF
		"    FCEU.message("Fail in "..state.frame.." frames: "..explain_input(inputhistory))
		$LF
		"  end,
		$LF
		"  function(inputhistory)
		$LF
		"    if Bestness:is_success(inputhistory) then
		$LF
		"      FCEU.message("\aSuccess in "..state.frame.." frames")
		$LF
		"      local inputdesc = explain_input(inputhistory)
		$LF
		"      FCEU.message(inputdesc)
		$LF
		"    end
		$LF
		"  end
		$LF
		")
		$LF
	]code
]pre
[h3 id=ExampleUseOfInputsimplifier 
	" Example use of InputSimplifier
	$LF
]h3
[div class=p 
	"Example of using InputSimplifier and SimpleBotLoop to simplify a sequence of input.
	$LF
	"(The candidate input is in Bestness.bestinput and it is assumed that that input verbatim will produce a success response from the 
	[em 
		"state
	]em
	" object):
	$LF
]div
[pre 
	[code class=language-lua 
		"local simplifier = InputSimplifier:new(Bestness.bestinput, "full")
		$LF
		"SimpleBotLoop(state, simplifier,
		$LF
		"  function(attempts)
		$LF
		"    return simplifier:are_you_done()
		$LF
		"  end,
		$LF
		"  function(inputhistory)
		$LF
		"    -- If this simplification caused the solution no longer
		$LF
		"    -- to work, inform the simplifier so it won't keep the
		$LF
		"    -- failed input.
		$LF
		"    FCEU.message("ack "..state.frame.." "..simplifier:explain_progress())
		$LF
		"    simplifier:you_failed()
		$LF
		"  end,
		$LF
		"  function(inputhistory)
		$LF
		"    FCEU.message("cool "..state.frame.."\n"..explain_input(inputhistory))
		$LF
		"    simplifier:you_rule()
		$LF
		"    -- Be prepared for the situation that the simplification
		$LF
		"    -- yielded an even faster completion time
		$LF
		"    Bestness:is_success() -- the return value is not relevant.
		$LF
		"  end
		$LF
		")
		$LF
	]code
]pre
[h3 id=ExampleImplementationOfClassInputgenerator 
	" Example implementation of class InputGenerator
	$LF
]h3
[div class=p 
	"Example of a random input generator:
	$LF
]div
[pre 
	[code class=language-lua 
		"----
		$LF
		"-- This generates random input
		$LF
		"-----
		$LF
		"InputGenerator = {  
		$LF
		"  new=function(self)
		$LF
		"    local res = {lrstate=0,roundno=0}
		$LF
		"    return setmetatable(res, self.mt)
		$LF
		"  end,
		$LF
		"  reset=function(self,attemptno)
		$LF
		"    self.nextchange = 0
		$LF
		"    self.roundno = self.roundno + 1
		$LF
		"  end,
		$LF
		"  generate=function(self,frameno)
		$LF
		"    if self.nextchange == 0 then
		$LF
		"      self.nextchange = math.random(1,12)
		$LF
		"      self.lrstate = math.random(0,31)
		$LF
		"    end
		$LF
		"    self.nextchange = self.nextchange - 1
		$LF
		"    local inp = {}
		$LF
		"    for button,bitmask in pairs({left=1, right=2, up=4, A=8, B=16}) do
		$LF
		"      if(AND(self.lrstate, bitmask) > 0) then inp[button]=1 end
		$LF
		"    end
		$LF
		"    return inp
		$LF
		"  end
		$LF
		"}
		$LF
		"InputGenerator.mt={__index=InputGenerator}
		$LF
	]code
]pre
[h3 id=ExampleImplementationOfClassGamestate 
	" Example implementation of class Gamestate
	$LF
]h3
[pre 
	[code class=language-lua 
		"----
		$LF
		"-- This controls the interface between the bot and the game.
		$LF
		"-- Specific to Yie Ar Kung-fu.
		$LF
		"-----   
		$LF
		"function generateobject(code) return setmetatable({}, {__index=code}) end
		$LF
		"function memoize(obj,name,f) obj[name]=f; return f end   
		$LF
		$LF
		"hpreader = generateobject(function(self,name)
		$LF
		"  local addr=({enemy=0x331, own=0x340})[name]
		$LF
		"  return memoize(self,name,
		$LF
		"    function() return
		$LF
		"      -- This pattern recurses an unnamed function.
		$LF
		"      (function(a,b,f) return f(a,b,f) end)(0,0,
		$LF
		"         function(n,v,f)
		$LF
		"           return v+(n>8 and 0 or
		$LF
		"                     f(n+1, (memory.readbyte(addr+n) ~= 0xEF and 1 or 0),f))
		$LF
		"         end) end)
		$LF
		"  -- Yes, I'm aware of that the above could have been made with a for-loop as well.
		$LF
		"end)
		$LF
		$LF
		"Gamestate = {
		$LF
		"  -- Construct a game state object
		$LF
		"  new=function(self)
		$LF
		"    local res = {ohp=hpreader.own(),ehp=hpreader.enemy(),
		$LF
		"                 frame=0,anchor=savestate.create()}
		$LF
		"    savestate.save(res.anchor)
		$LF
		"    return setmetatable(res, self.mt)
		$LF
		"  end,
		$LF
		"  -- Begin a new attempt
		$LF
		"  reset=function(self)
		$LF
		"    savestate.load(self.anchor)
		$LF
		"    self.frame = 0
		$LF
		"  end,
		$LF
		"  -- Check what happened this frame (called after frame advance)
		$LF
		"  -- Return values: 0=ok, 1=success, -1=failure
		$LF
		"  getstate=function(self)
		$LF
		"    self.frame = self.frame+1
		$LF
		"    if(self.ohp   > hpreader.own())  then return -1 end  -- failed, took damage  
		$LF
		"    if(self.ehp   > hpreader.enemy())then return 1  end  -- success, did damage  
		$LF
		"    if(self.frame >= maxframe)       then return -1 end  -- failed, too much time
		$LF
		"    return 0
		$LF
		"  end
		$LF
		"}
		$LF
		"Gamestate.mt={__index=Gamestate}
		$LF
	]code
]pre
[h3 id=MultiplayerLuaBotFramework 
	" Multiplayer LUA bot framework
	$LF
]h3
[div class=p 
	"This framework uses a centralized server for multiplayer LUA games.
	$LF
]div
[pre 
	[code class=language-lua 
		"-- In Debian GNU/Linux, install these libraries to use:
		$LF
		"--  - liblua5.1-soap-dev
		$LF
		"--  - liblua5.1-bit-dev
		$LF
		"--
		$LF
		$LF
		"require "soap/http"
		$LF
		"require "bit"
		$LF
		$LF
		"local buttonmap =
		$LF
		"{A=1,B=2,select=4,start=8, up=16,down=32,left=64,right=128,
		$LF
		" C=256,X=512,Y=1024,L=2048,R=4096, L1=8192,L2=16384,L3=32768,
		$LF
		" R1=65536,R2=131072,R3=262144,Z=524288}
		$LF
		$LF
		"function soapcall(fname, params)
		$LF
		"  local p = { tag="nums" }
		$LF
		"  for param,value in pairs(params) do
		$LF
		"    table.insert(p, {tag=param, value})
		$LF
		"  end
		$LF
		"  local ns,meth,ent = soap.http.call(
		$LF
		"    "http://bisqwit.iki.fi/utils/lua_server.php",
		$LF
		"    "urn:TasvideosLUAserverQuery",
		$LF
		"    fname, {p})
		$LF
		"  return ent
		$LF
		"end
		$LF
		$LF
		"Server = {
		$LF
		"  register = function(gameno,ctrlno,password)
		$LF
		"    return Server.decode(soapcall("register", {gameno=gameno, ctrlno=ctrlno, password=password})[1])
		$LF
		"  end,
		$LF
		"  submit = function(gameno,ctrlno,password,ctrl)
		$LF
		"    local ctrl_mod = 0x00
		$LF
		"    for button,bitmask in pairs(buttonmap) do
		$LF
		"      if(ctrl[button]) then ctrl_mod = ctrl_mod + bitmask end
		$LF
		"    end
		$LF
		"    return Server.decode(soapcall("submit", {gameno=gameno, ctrlno=ctrlno, password=password, ctrl=ctrl_mod})[1])
		$LF
		"  end,
		$LF
		"  getframe = function(gameno,ctrlno,password)
		$LF
		"    local response = Server.decode(soapcall("getframe", {gameno=gameno, ctrlno=ctrlno, password=password})[1])
		$LF
		"    if(type(response) == 'table') then
		$LF
		"      for ctrlno,bitset in pairs(response) do
		$LF
		"        local keymap = {}
		$LF
		"        for button,bitmask in pairs(buttonmap) do
		$LF
		"          if(bit.band(bitset,bitmask)~=0)then keymap[button]=1 end
		$LF
		"        end
		$LF
		"        response[ctrlno]=keymap
		$LF
		"      end
		$LF
		"    end
		$LF
		"    return response
		$LF
		"  end,
		$LF
		"  
		$LF
		"  decode = function(soapresponse)
		$LF
		"    -- print_r(soapresponse)
		$LF
		"    if soapresponse.attr['xsi:type'] == 'SOAP-ENC:Array' then
		$LF
		"      local response = {}
		$LF
		"      for i, elem in ipairs(soapresponse) do
		$LF
		"        response[i] = Server.decode(elem)
		$LF
		"      end
		$LF
		"      return response
		$LF
		"    elseif soapresponse.attr['xsi:type'] == 'ns2:Map' then
		$LF
		"      local response = {}
		$LF
		"      for i, elem in ipairs(soapresponse) do
		$LF
		"        response[Server.decode(elem[1])] = Server.decode(elem[2])
		$LF
		"      end
		$LF
		"      return response
		$LF
		"    elseif soapresponse.attr['xsi:type'] == 'xsd:int' then
		$LF
		"      return soapresponse[1]+0
		$LF
		"    else
		$LF
		"      return soapresponse[1]
		$LF
		"    end
		$LF
		"  end
		$LF
		"}
		$LF
	]code
]pre
[div class=p 
	"Example game loop (this is for FCEU, but for other emulators, it's pretty much the same):
	$LF
]div
[pre 
	[code class=language-lua 
		"local gameno   = 0x1501096    -- identifies the game you're participating
		$LF
		"local password = "g9uzs09qek" -- password for your robot in this game
		$LF
		"local ctrlno   = 1            -- which controller's input you are providing
		$LF
		$LF
		"if Server.register(gameno, ctrlno, password) ~= 0 then
		$LF
		"  print("Error registering to the server")
		$LF
		"  os.exit()
		$LF
		"else
		$LF
		"  while(true)do
		$LF
		"    local joypadinput = {A=1}
		$LF
		"    
		$LF
		"    Server.submit(gameno,ctrlno,password, joypadinput)
		$LF
		"    local inputs = Server.getframe(gameno,ctrlno,password)
		$LF
		"    if inputs == 0 then
		$LF
		"      print("Game over")
		$LF
		"      break
		$LF
		"    end
		$LF
		"    for a=1,4 do
		$LF
		"      joypad.set(a, inputs[a])
		$LF
		"    end
		$LF
		"    FCEU.frameadvance()
		$LF
		"  end
		$LF
		"end
		$LF
	]code
]pre
[div class=p 
	"It uses a centralized game server at 
	[code 
		"bisqwit.iki.fi
	]code
	".
	$LF
	"A password is required for each game to prevent bots
	$LF
	"from screwing up other players' games.
	$LF
]div
